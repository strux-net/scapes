if ! (has("perl"))
  finish
endif
perl <<EOT
package XPE;
#
# Autogenerated from perl_tru using XPE.plTR
# do not edit this file, look for XPE.plTR and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
# based on XPE.plTR , version : 3.0
#****************************************
# This file holds perl-functions used by LL.dirsettings
# 
# per convention:
#   subs with argument flag are dealing with Xi, Xf, Xd and Xo
#     1	Xi	in-command (executed once before the first x-per-entry-command)
#     2	Xf	x-per-file-command
#     3	Xd	x-per-dir-command
#     4	Xo	out-command (executed once after the last x-per-entry-command)
#     
# to force rereading this file do (in vim)
#   :verbose runtime plugin/XPE.vim
#****************************************
### 
#  show the name of the module
#  find it in section
#    =head1 NAME

sub perl
{
  if (open(local *I,"<$F")) {
    local @A;
    while (<I>) {
      chop;
      if (/^=head1 NAME/.../^=/) {
        push(@A,$_);
      }
    }
    shift @A;
    pop @A;
    return join('',grep(/./,@A));
  }
}
### 
#  extract the description from 00-INDEX

sub kerneldoc($)
{
  local ($flag) = @_;
  if ($flag==1) {
    if (open(local *I,"<00-INDEX")) {
      while (<I>) {
        chop;
        if (/^\s+- /) {
          $Index[-1].=$_;
        } else {
          push @Index,$_;
        }
      }
    }
  } elsif ($flag==2) {
    $_=(grep(/^$F\t/,@Index))[0];
    s/.*?\t- //;
    return $_;
  } elsif ($flag==3) {
    $_=(grep(/^$F\/\t/,@Index))[0];
    s/.*?\t- (directory with\s+)?//;
    return $_;
  } elsif ($flag==4) {
    undef(@Index);
  }
}
### 
#  show the description

sub irssi
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (s/.*description["']?\s*=>\s*(['"])//) {
        chomp;
        s/$1[^$1]*$//;
        s/\\//g;
        return $_;
      }
    }
  }
}
### 
#  show the whatis for this device
#  for loop-files show the losetup

sub dev
{
  if ($F =~ /^loop/) {
    $_ = `losetup "$F" 2>/dev/null`;
    chop;
    s/.*?\[/[/;
    return "4\tloop device $_";
  }
  if (defined($whatis{$F}) and $whatis{$fs} =~ /^4/) {
    return $whatis{$F};
  }
  (local $fs=$F) =~ s/\d+$//;
  if (defined($whatis{$fs}) and $whatis{$fs} =~ /^4/) {
    return $whatis{$fs};
  }
}
### 
#  a whatever/CVS dir contains 3 files:
#    Entries
#    Root
#    Repository
#  show the contents of Root and Repository.
#  show the number of dirs and files of Entries

sub cvs
{
  if (open(local *I,"<$F")) {
    if ($F eq "Entries") {
      my @Array=<I>;
      my $dirs=grep(/^D/,@Array);
      my $files=@Array-$dirs;
      return "dirs : $dirs , files : $files";
    } else {
      chomp(my $s=<I>);
      return $s;
    }
  }
}
### 
#  show the title

sub htmlTitle
{
  if ($F =~ /\.html$/ and open(local *I,"<$F")) {
    while (<I>) {
      if (s/.*?<title> *//) {
        s:</title>.*$::;
        chomp;
        return $_;
      }
    }
  }
}
### 
#  show the description for this preset.
#  find it in the first line starting with desc=

sub gimpPreset
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (/^desc=(.*)/) {
        return $1;
      }
    }
  }
}
### 
#  show the description for a file based on README.txt.

sub READMEbased($)
{
  local ($flag) = @_;
  if ($flag==1) {
    if (open(local *I,"<README.txt")) {
      @README=<I>;
    }
  } elsif ($flag==2) {
    (grep(/^$F\s/,@README))[0] =~ /.+?\s+(.*)/;
    return $1;
  } elsif ($flag==4) {
    undef(@README);
  }
}
### 
#  show the description for this script.
#  basically find it in the third element of script-fu-register

sub gimpScript
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (/script-fu-register/) {
        <I>;
        $_=<I>;
        s/.*?"//;
        s/".*?$//;
        chomp;
        return $_;
      }
    }
  }
}
### 
#  show the language for the menu-file

sub vimLang
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (/^" Menu Translations:\s*(.*)/) {
        return $1;
      }
    }
  }
}
### 
#  show the background-setting

sub vimColors
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (/^:?set\s+(bg|background)=(.*)/) {
        return $2;
      }
    }
  }
}
### 
#  show the Header line for a tutor file
#  this is basically the second line in the file

sub vimTutor
{
  if ($F =~ /^README/ or $F =~ /\.vim$/) {
    return "";
  }
  if (open(local *I,"<$F")) {
    <I>;                                           # skip first line
    $_=<I>;                                        # read the second line
    s/^ *= *//;                                    # remove leading 'garbage'
    return $_;
  }
}
### 
#  show the (programming-)language a plugin is made for.
#  find it in the plugin by looking for the first line that looks like either
#    " Compiler: whatever
#  or
#    " Language: whatever

sub vimFt
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (s/^" *Compiler:\s+// or s/^" *Language:\s+//) {
        chomp;
        return $_;
      }
    }
  }
}
### 
#  show the description for a top-level-plugin.
#  This is basically the very first line which in most files starts with a " (quote), 
#  One file though (strangly) starts with :"  (vim7.3)

sub vimRoot
{
  if (open(local *I,"<$F")) {
    (my $s=<I>) =~ s/^:?"\s*//;
    chomp($s);
    return $s;
  }
}
### 
#  show the summary for the help-file.
#  basically look for the first non-empty line after the 4th line.
#  It does not work perfectly since there is no style-guide for the help-files (vim7.3)

sub vimDoc
{
  if ($F eq "tags") {
    return "the tags-file for vim's help-system";
  }
  if (!($F =~ /\.txt$/)) {
    return "";
  }
  if (open(local *I,"<$F")) {
    my $s;
    <I>;                                           # skip first 4 lines
    <I>;
    <I>;
    <I>;
    do {
      $s=<I>;
      chomp($s);
      $s =~ s/\*.*//;                              # * starts a tag
      $s =~ s/^\s+//;                              # leading spaces
    } until	$s ne "";
    return $s;
  }
}
### 
#  show the pos and flags
#  The files loook like
#    pos:	240
#    flags:	0100000

sub procFdinfo
{
  if (open(local *I,"<$F")) {
    (my $s) = <I> =~ /(\d+)/;
    <I> =~ /(\d+)/;
    return "$s\t$1";
  }
}
### 
#  show the very first line

sub procSys
{
  if (open(local *I,"<$F")) {
    chomp(my $s=<I>);
    return $s;
  }
}
### 
#  show the very first line for some selected files

sub procFile
{
  if ($F =~ /^(version_signature|version|uptime|loadavg|dma|cmdline)$/) {
    if (open(local *I,"<$F")) {
      chomp(my $s=<I>);
      return " \t$s";
    }
  }
}
### 
#  show the three fields
#    stat	status	cmdline
#  @stat 3rd field from $F/stat
#  @status part after tab in first line fo $F/status
#  @cmdline $F/cmdline ( \0 replaced with space)

sub procDir
{
  if ($F !~ /\d+/) {
    return;
  }
  my $s;
  if (open(local *I,"<$F/stat")) {
    $s .= (split(/\s+/,<I>))[2]." ";
  }
  if (open(local *I,"<$F/status")) {
    $s .= (split(/\t+|\n/,<I>))[1]."\t";
  }
  if (open(local *I,"<$F/cmdline")) {
    (my $x = <I>) =~ s/\0/ /g;
    $s.=$x;
  }
  $s;
}
### 
#  show the three fields
#    from	to	subject

sub mail
{
  if (open(local *I,"<$F")) {
    my ($subject,$from,$to);
    $subject="no subject";
    while (<I>) {
      if (/^$/) {
        last;
      }
      if (/^From: (.*)/) {
        $from=$1;
      }
      if (/^To: (.*)/) {
        $to=$1;
      }
      if (/^Subject: (.*)/) {
        $subject=$1;
      }
    }
    return "$from\t$to\t$subject";
  }
}
### 
#  show the description of a service

sub initdRules
{
  if (open(local *I,"<$F")) {
    $description = " ";
    while (<I>) {
      if (/^# Short\-Description:\s+(.*)/) {
        return $1;
      }
    }
  }
}
### 
#  show the three fields
#    Description	start on	stop on

sub initRules
{
  if (open(local *I,"<$F")) {
    $description = " ";
    while (<I>) {
      if (/^description\s+"(.*)"/) {
        $description = $1;
      }
      if (/^start on (.*)/) {
        $start = $1;
      }
      if (/^stop on (.*)/) {
        $stop = $1;
      }
    }
    return "$description\t$start\t$stop";
  }
}
### 
#  show the comment if given and nonempty. Else show the name

sub desktop
{
  if (!($F =~ /\.desktop/)) {
    return "";
  }
  if (open(local *I,"<$F")) {
    local $name;
    while (<I>) {
      if (/^Name=(.+)/) {
        $name = $1;
      }
      if (/^Comment=(.+)/) {
        return $1;
      }
    }
    return $name;
  }
}
### 
#  show the whatis for this file

sub bin($)
{
  local ($flag) = @_;
  if ($flag==1) {
    if (!(%whatis)) {
      map {
        local ($name,$mansection,$txt) = /([^ ]+) \((.*?)\) +\- (.*)/;
        $whatis{$name}="$mansection\t$txt";
      } `whatis -s 1,4,6,7,8 -r '.*'`;
    }
  } elsif ($flag==2) {
    return $whatis{$F};
  }
}
### 
#  extract the title

sub locale
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (m/^title\s+"(.*)"$/) {
        return $1;
      }
    }
  }
}
### 
#  extract the Exec

sub dbus
{
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (m/^Exec=(.*)$/) {
        return $1;
      }
    }
  }
}
### 
#  basically return the second line

sub calendar
{
  if (open(local *I,"<$F")) {
    <I>;                                           # skip first line
    $_=<I>;
    chomp;
    s/..//;
    return $_;
  }
}
### 
#  basically return the first line

sub nano
{
  if (open(local *I,"<$F")) {
    if (($_=<I>) =~ /#+\s*(.*)/) {
      return $1;
    }
  }
}
### 
#  basically return the second line

sub vsllib
{
  if (open(local *I,"<$F")) {
    <I>;                                           # skip first line
    $_=<I>;
    /...(.*)/;
    return $1;
  }
}
### 
#  return the two fields
#    mime	comment

sub mime
{
  if (open(local *I,"<$F")) {
    local $type;
    while (<I>) {
      if (/type="(.*?)"/) {
        $type = $1;
      }
      if (m:<comment>(.*?)</comment>:) {
        return "$type\t$1";
      }
    }
  }
}
### 
#  show the git-status of the files

sub git($)
{
  local ($flag) = @_;
  if ($flag==1) {
    @GIT = split(/\0/,`git status --ignored -z . 2>/dev/null`);
    $InGitDir = !$?;
    if (@GIT) {
      local $tl = `git rev-parse --show-toplevel`;
      local $r = substr($d,length($tl))."/";
      map {
        s/ $r/ /;
      } @GIT;
    }
  } elsif ($flag==2) {
    if ($InGitDir) {
      $indicator = substr((grep(substr($_,3) eq $F,@GIT))[0],0,2);
    } else {
      $indicator = substr(`git -C $p status $f -s 2>/dev/null`,0,2);
    }
    if ($indicator eq "!!") {
      return "";
    }
    if ($indicator eq "") {
      $indicator = "  ";
    }
    if ($indicator eq " D" ) {
      $desc = "deleted  , not updated , deleted in work tree";
    } elsif ($indicator eq " M" ) {
      $desc = "modified , not updated , work tree changed since index";
    } elsif ($indicator eq "M " ) {
      $desc = "modified , updated in index , index and work tree matches";
    } elsif ($indicator eq "MM" ) {
      $desc = "modified , updated in index";
    } elsif ($indicator eq "MD" ) {
      $desc = "modified , updated in index , deleted in work tree";
    } elsif ($indicator eq "A " ) {
      $desc = "added    , added to index , index and work tree matches";
    } elsif ($indicator eq "AM" ) {
      $desc = "added    , added to index , work tree changed since index";
    } elsif ($indicator eq "AD" ) {
      $desc = "added    , added to index , deleted in work tree";
    } elsif ($indicator eq "D " ) {
      $desc = "deleted  , deleted from index";
    } elsif ($indicator eq "DM" ) {
      $desc = "deleted  , deleted from index";
    } elsif ($indicator eq "R " ) {
      $desc = "renamed  , renamed in index , index and work tree matches";
    } elsif ($indicator eq "RM" ) {
      $desc = "renamed  , renamed in index , work tree changed since index";
    } elsif ($indicator eq "RD" ) {
      $desc = "renamed  , renamed in index , deleted in work tree";
    } elsif ($indicator eq "C " ) {
      $desc = "copied   , copied in index , index and work tree matches";
    } elsif ($indicator eq "CM" ) {
      $desc = "copied   , copied in index , work tree changed since index";
    } elsif ($indicator eq "CD" ) {
      $desc = "copied   , copied in index , deleted in work tree";
    } elsif ($indicator eq "DD" ) {
      $desc = "unmerged , both deleted";
    } elsif ($indicator eq "AU" ) {
      $desc = "unmerged , added by us";
    } elsif ($indicator eq "UD" ) {
      $desc = "unmerged , deleted by them";
    } elsif ($indicator eq "UA" ) {
      $desc = "unmerged , added by them";
    } elsif ($indicator eq "DU" ) {
      $desc = "unmerged , deleted by us";
    } elsif ($indicator eq "AA" ) {
      $desc = "unmerged , both added";
    } elsif ($indicator eq "UU" ) {
      $desc = "unmerged , both modified";
    } elsif ($indicator eq "??" ) {
      $desc = "untracked";
    } elsif ($indicator eq " T" ) {
      $desc = "typechange";
    } elsif ($indicator eq "  " ) {
      $desc = "unmodified";
    } else {
      $desc = "unknown tag";
    }
    return "$indicator $desc";
  } elsif ($flag==3) {
    if ($F eq ".git") {
      return "git db";
    }
    $F.="/";
    $indicator = substr((grep(substr($_,3,length($F)) eq $F,@GIT))[0],0,2);
    if ($indicator eq "!!") {
      return "";
    } elsif ($indicator eq "??" or ! $indicator) {
      return $indicator;
    } else {
      return "changed files inside";
    }
  } elsif ($flag==4) {
    undef(@GIT);
  }
}
### 
#  extract the indenterName (only for .ini-files)

sub universalindentgui_indenters
{
  if (!($F =~ m/\.ini$/)) {
    return "";
  }
  if (open(local *I,"<$F")) {
    while (<I>) {
      if (m/^indenterName=(.*)/) {
        return $1;
      }
    }
  }
}
### 
#  extract name and server

sub remmina
{
  if (open(local *I,"<$F")) {
    local $name, $server;
    while (<I>) {
      if (m/^name=(.*)/) {
        $name=$1;
      }
      if (m/^server=(.*)/) {
        $server=$1;
      }
    }
    return "$name\t$server";
  }
}
EOT
