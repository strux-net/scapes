#!/usr/bin/perl
#
# Autogenerated from perl_tru using acmd.plTR
# do not edit this file, look for acmd.plTR and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
#  protos
sub usage;
sub main;
sub acmd_init;
sub errorMsg($);
sub showPoss;
sub interactive;
sub vim_do_I($);
sub vim_do_o($);
sub vim_do_G($);
sub vim_do_s($);
sub so_do_I($);
sub so_do_o($);
sub so_do_G($);
sub so_do_s($);
sub so_do_p($);
sub choice($);
sub poss($$);
sub find_entries($);
sub parseAF;
sub Dump;
$opt_V = 0;
$opt_a = '';
$opt_l = '';
$opt_f = '';
if (@ARGV == 1 and $ARGV[0] eq '-?') {
  usage();
}
# based on acmd.plTR , version : 4.0

sub usage
{
  print STDERR <<'EOU';
usage : acmd <file>
offer a menu of choices of what to do with <file>

Reads
  ~/acmd.rc
  ~/strux/etc/acmd.rc
  /etc/acmd.rc

All found files are read (in the order given above) to build the database.
The commands are valid in the order found.
OPTIONS:
  -V	Verbose
  -a:<file>	Use only this acmd-file
  -l:<file>	Use this acmd-file as a last resort
  -f:<file>	Use this acmd-file as a first resort
  -version	show version information
EOU
  exit(1);
}
#****************************************
# The main datastuctures are
#   @AF			connects RE to command groups
#   @G			connects txt to command for each group
#   @POSSIBILITIES	holds the actual hits
#   
#   @AF = [..]
#     [ 'RE 1', 0 ]	files matching 'RE 1' can be processed with commands from group 0
#     [ 'RE 2', 0 ]	files matching 'RE 2' can also be processed with commands from group 0
#     [ 'RE 3', 1 ]	files matching 'RE 3' can be processed with commands from group 1
#     
#   @G = [..]
#     [..]
#       [ 't','txt 1','cmd 1' ]	group 0 consists of one command 'cmd 1' with text 'txt 1'
#     [..]
#       [ 't','txt 2','cmd 2' ]	group 1 consists of three commands
#       [ 't','txt 3','cmd 3' ]
#       [ 't','txt 4','cmd 4' ]
#   ]
#   
#   @POSSIBILITIES = [..]
#     [ 'RE1' ],		the file matches RE1 as well as RE2 below
#     [ 't','txt 1','cmd 1' ],	from RE1 we have this command
#     [ 'RE2' ],
#     [ 't','txt 1','cmd 1' ],	from RE2 we have these three commands
#     [ 't','txt 1','cmd 1' ],
#     [ 't','txt 1','cmd 1' ]
#****************************************

sub main
{
  if ( $ARGV[0] eq "-version" ) {
    print "Version :\n";
    print "  acmd.plTR	4.0\n";
    exit 0
  }
  sub Print($);
  @acmd_files = ("$ENV{HOME}/acmd.rc","$ENV{HOME}/strux/etc/acmd.rc","/etc/acmd.rc");
  use Getopt::Long;
  usage() if !GetOptions('f=s','l=s','a=s','V');
    # -V : Verbose
    # -a : Use only this acmd-file
    if ($opt_a) {
      @acmd_files = ($opt_a);
    }
    # -l : Use this acmd-file as a last resort
    if ($opt_l) {
      push @acmd_files,$opt_l;
    }
    # -f : Use this acmd-file as a first resort
    if ($opt_f) {
      unshift @acmd_files,$opt_f;
    }
  acmd_init;                                       # parse all acmd_files
  if ($opt_vimcall) {
    *do_I = \&vim_do_I;
    *do_o = \&vim_do_o;
    *do_G = \&vim_do_G;
    *do_s = \&vim_do_s;
    1;                                             # we are required so we return 1 for ok
  } else {
    *do_I = \&so_do_I;
    *do_o = \&so_do_o;
    *do_G = \&so_do_G;
    *do_s = \&so_do_s;
    find_entries $ARGV[0];
    interactive;
  }
  #Dump
}

sub acmd_init
{
  $group=-1;                                       # group number
  @G=@AF=();
  for my $f (@acmd_files) {
    if (-e $f) {
      if (open(AF,$f)) {
        if ($opt_V) {
          print "reading $f\n";
        }
        $group++;
        parseAF;
        close AF;
      } else {
        errorMsg("cannot open $f : $!\n");
      }
    } else {
      if ($opt_V) {
        print "skipping $f\n";
      }
    }
  }
  if (@G == ()) {
    errorMsg("none of @acmd_files readable, acmd not usable\n");
  }
}

sub errorMsg($)
{
  local ($str) = @_;
  if ($opt_vimcall) {
    VIM::Msg($str);
  } else {
    print STDERR "$str";
  }
}

sub showPoss
{
  for ($i=0;$i<@POSSIBILITIES;$i++) {
    print "$i\t".poss(\@POSSIBILITIES,$i)."\n";
  }
}

sub interactive
{
  if (!(@ARGV == 1)) {
    usage;
  }
  if (!(@POSSIBILITIES)) {
    print "no rule for $f\n";
    exit;
  }
  showPoss;
  while (1) {
    do {
      print "choice : ";
      if (!($_ = <STDIN>)) {
        return;
      }
      chop $_;
    } until	$_ ne "";
    if ($_ eq "q") {
      return;
    }
    if ($_ eq "?") {
      showPoss;next;
    }
    if ($_=choice($_)) {
      print "$_\n";
    }
  }
}

sub vim_do_I($)
{
  local ($i) = @_;
  WriteTmpScript(qq($xterm $POSSIBILITIES[$i][2]),$f,'' ,'t'); # calculations for $f, $p, $e, $F and $r are repeated there
  VIM::DoCommand("call ExecuteScript('t')");
}

sub vim_do_o($)
{
  local ($i) = @_;
  vim_do_I($i);return;
  eval qq( \$cmd = qq($POSSIBILITIES[$i][2]) );
  $cmd =~ s/([!%#])/\\$1/g;
  VIM::DoCommand("new|r! $cmd");
  VIM::DoCommand("1d|set nomodified");
}

sub vim_do_G($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2] >/dev/null 2>/dev/null &)); # &>/dev/null does not work since system invokes sh (not bash)
}

sub vim_do_s($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2]&));
}

sub so_do_I($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2]));
}

sub so_do_o($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2]));
}

sub so_do_G($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2]));
}

sub so_do_s($)
{
  local ($i) = @_;
  eval qq(system qq($POSSIBILITIES[$i][2]));
}

sub so_do_p($)
{
  local ($i) = @_;
  eval qq($POSSIBILITIES[$i][2]);
}

sub choice($)
{
  local ($i) = @_;
  my $showcommand=0;
  if ($i <0) {
    $showcommand=1;
    $i=-$i;
  }
  if (@G == ()) {
    return "acmd not usable";
  }
  if ($i<0 or $i>$#POSSIBILITIES) {
    return "no good choice";
  }
  if (!($#{$POSSIBILITIES[$i]})) {
    return "not here";
  }
  if ($showcommand) {
    return "$POSSIBILITIES[$i][2]";
  } else {
    if ($POSSIBILITIES[$i][0] eq 'I') {
      do_I($i);
    } elsif ($POSSIBILITIES[$i][0] eq 'o') {
      do_o($i);
    } elsif ($POSSIBILITIES[$i][0] eq 'G') {
      do_G($i);
    } elsif ($POSSIBILITIES[$i][0] eq 's') {
      do_s($i);
    } elsif ($POSSIBILITIES[$i][0] eq 'p') {
      so_do_p($i);
    } else {
      return "no such tag $POSSIBILITIES[$i][0]";
    }
  }
  if ($@) {
    my $r=$@ ; $@="" ; return $r;
  }
}

sub poss($$)
{
  local ($P,$i) = @_;
  if ($#{@$P[$i]}) {
    return "  @{@$P[$i]}[0..1]";
  } else {
    return "@{@$P[$i]}[0]";
  }
}

sub find_entries($)
{
  local ($file) = @_;
  #****************************************
  # sets filevars
  #   $f = filename with path		/path/to/file/name.ext
  #   $p = path				/path/to/file
  #   $F = filename as given		name.ext
  #   $r = filename without extension	name
  #   $e = extension			ext
  #****************************************
  $r=$f=$F=$file;
  $r=~s/\.[^.]*$//;
  $e=~s/.*\.//;
  if ($file =~ /\./) {
    ($e=$file) =~ s/.*\.//;
  } else {
    $e = "";
  }
  if ($f =~ m:^/:) {
    ($p=$f) =~ s:/[^/]+$::;
  } else {
    $p=`pwd`;
    chop $p;
    $f="$p/$f";
  }
  if (!(@HITS=grep { $f =~ @$_[0] } @AF)) {
    @HITS=grep { $f =~ /@$_[0]/i } @AF;
  }
  @POSSIBILITIES=();
  map {
    push @POSSIBILITIES,[@$_[0]];
    map {
      push @POSSIBILITIES,$_;
    } @{$G[@$_[1]]};
  } @HITS;
}

sub parseAF
{
  #****************************************
  # parse the lines in file readable by <AF>
  # and put them in the datastructure @AF
  #****************************************
  my $l=0;                                         # previous level
  my $lc;                                          # last comand pushed, more to be added
  while (<AF>) {
    chop;
    if ($_=~ /^#/) {
      next;
    } elsif ($_=~ /^\s*$/) {
      next;
    } elsif ($_=~ /^[^ ]/) {
      if ($l) {
        $group++;$l=0;
      }
      push @AF,[$_,$group];
    } elsif ($_=~ /^  [^ ]/) {
      $l=1;
      s/^  //;
      ($type,$txt,$cmd) = split /\t+/;
      if (!($cmd =~ /\$/)) {
        $cmd.=' "$f"';
      }
      push @{$G[$group]},[$type,$txt,$cmd];
      $lc=\@{@{$G[$group]}[$#{$G[$group]}]}[2];    # reference of last pushed cmd
    } else {
      s/^    //;
      $$lc.="\n".$_;
    }
  }
}

sub Dump
{
  use Data::Dumper;
  print "----------- G ---------------\n";
  print Dumper(\@G);
  print "----------- AF ---------------\n";
  print Dumper(\@AF);
  print "------------ POSSIBILITIES --------------\n";
  print Dumper(\@POSSIBILITIES);
}
main();
