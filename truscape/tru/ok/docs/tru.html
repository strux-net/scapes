<!DOCTYPE html><html>
<!--
  Autogenerated from html_tru using docs/tru.txtTR
  do not edit this file, look for above mentioned and make your changes there.
  or you may loose all your changes and probably choose the wrong method.
-->
<head>
<link rel="stylesheet" href="trudoc.css"/>
  <meta name="generator" content="html_tru (www.strux.net)"/>
  <title>tru Reference Card</title>
</head>
<body>
<a name="tru202d20parsing20structured20text"></a>
<h1>tru - parsing structured text</h1>
<div>
tru generates truers (or parsers) for a special kind of texts that are<br/>
<ul>
<li>properly indented and have
</li>
<li>tab separated fields
</li>
<br/>
</ul>
<a name="Using20a20truer"></a>
<h2>Using a truer</h2>
<div>
Two simples steps for a truer<br/>
<ol>
<li>create a parser from one or more .tru-files (parser description files for a truer).
</li>
<li>call this parser for adequate input and produce corresponding output.
</li>
<br/>
</ol>
The procedure may be as simple as:<br/>
<ul>
<li>Create parser
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>tru s.tru &gt; s_tru </kbd></td>
</tr>
</table><br/>
The parser s_tru is generated from the .tru-file s.tru.<br/>
<br/>
</li>
<li>Run parser
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>s_tru input &gt; output</kbd></td>
</tr>
</table><br/>
Runs parser s_tru for one input-file.<br/>
The parser reads it's input and produces it's output.<br/>
this assumes that you did.<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>chmod +x s_tru</kbd></td>
</tr>
</table><br/>
</li>
</ul>
or as complex as:<br/>
<ul>
<li>Create parser
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>tru s1.tru s2.tru s3.tru &gt; s_tru</kbd></td>
</tr>
</table><br/>
The parser s_tru is generated from several .tru-files s1.tru .. s3.tru<br/>
The order of the description files is very important.<br/>
<br/>
</li>
<li>Run parser
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>s_tru file1 file2 file3 &gt; output</kbd></td>
</tr>
</table><br/>
The parser reads the three files in sequence and produces it's output.<br/>
<br/>
</li>
</ul>
or even more complex<br/>
<ul>
<li>extend an existing truer
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;html_tru -source | tru -- - special_html.tru &gt;special_html_tru</kbd></td>
</tr>
</table><br/>
The .tru-equivalent for html_tru is used together with special_html.tru<br/>
</li>
</ul>
</div>
By default the parser reads from STDIN and writes to STDOUT<br/>
<br/>
<a name="Options20of20tru"></a>
<h2>Options of tru</h2>
<div>
<table>
<tr>
  <td>-q</td>
  <td>Do not print any warnings</td>
</tr>
<tr>
  <td>-s:file</td>
  <td>Print some statistics to the file</td>
</tr>
<tr>
  <td>-l:limit[100]</td>
  <td>limit for recursions when expanding a group</td>
</tr>
<tr><td></td></tr>
</table><br/>
The statistics (option -s) consists of one line per action.<br/>
Each line consists of 7 fields, where the first 6 are counters.<br/>
The fields are:<br/>
<table>
<tr>
  <td>H</td>
  <td>hits in the action-section(s)</td>
</tr>
<tr>
  <td>&gt;</td>
  <td>definitions for &gt;</td>
</tr>
<tr>
  <td>-</td>
  <td>definitions for -</td>
</tr>
<tr>
  <td>&lt;</td>
  <td>definitions for &lt;</td>
</tr>
<tr>
  <td>d</td>
  <td>short descriptions</td>
</tr>
<tr>
  <td>s</td>
  <td>used in structure</td>
</tr>
<tr>
  <td>name</td>
  <td>the name of the action</td>
</tr>
<tr><td></td></tr>
</table><br/>
</div>
</div>
<a name="General20form20of20a202etru2dfile"></a>
<h1>General form of a .tru-file</h1>
<div>
<a name="Comments"></a>
<h2>Comments</h2>
<div>
Lines that start with a # are comments and are otherwise ignored.<br/>
The comment-character #  must be the very first character in a line, no leading white-space is allowed.<br/>
</div>
<a name="sections"></a>
<h2>sections</h2>
<div>
a .tru file consists of severals sections, each introduced by a word on the very far left, followed by some indented lines defining the section.<br/>
The sections are described here and an example is given for each section in a separate file<br/>
<a name="structure"></a>
<h3>structure</h3>
<div>
Here the structure of the text to be parsed is defined.<br/>
This section is described in detail in the fully commented truer <a href="examples/truscape/tru/structure_demo.tru" >structure_demo.tru</a> and the inputfile <a href="examples/truscape/tru/structure_demo.in" >structure_demo.in</a><br/>
The file <a href="examples/truscape/tru/structure_demo.out" >structure_demo.out</a> contains the results of running:<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>tru -q structure_demo.tru &gt; structure_demo_tru &amp;&amp; chmod +x structure_demo_tru</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>structure_demo_tru -debug -debStructure <a href="examples/truscape/tru/structure_demo.in" >structure_demo.in</a></kbd></td>
</tr>
</table><br/>
Additionally the graphical-debugger can help to understand the structure definition.<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd><a href="tru_jar.html" >tru.jar</a> structure_demo_tru <a href="examples/truscape/tru/structure_demo.in" >structure_demo.in</a></kbd></td>
</tr>
</table><br/>
</div>
<a name="actions"></a>
<h3>actions</h3>
<div>
Here the actions are defined.<br/>
Actions are named pieces of code, that are executed if a corresponding structure-item matches or when they are called directly (see &gt;&gt; =&gt; -&gt;)<br/>
Actions have arguments.<br/>
The arguments are separated from each other with one or more tabs.<br/>
arguments (and action-names) can contain any letter except<br/>
<table>
<tr>
  <td>\t (tab)</td>
  <td>for obvious reasons</td>
</tr>
<tr>
  <td>$sdel</td>
  <td>per default : \x00 (a null byte)</td>
</tr>
</table><br/>
Many actions can be defined in the actions-section and many action sections can exist.<br/>
<br/>
Actions have three different entry points, called pit (for Point In Time).<br/>
<table>
<tr>
  <td>&gt;</td>
  <td>inaction</td>
</tr>
<tr>
  <td>-</td>
  <td>depthaction</td>
</tr>
<tr>
  <td>&lt;</td>
  <td>outaction</td>
</tr>
<tr><td></td></tr>
</table><br/>
The lines after &gt;, - and &lt; are perl-code. The arguments are accessible in the code in the natural (perl-)way (by prepending a $).<br/>
If such a line starts with a tab, then it is an output-statement.<br/>
See perl_code.tru and outstatements.tru for more details about these issues.<br/>
<br/>
The inaction is executed when a line is matched.<br/>
The depthaction is executed when the next line with the same or a smaller indent is matched.<br/>
<ul>
<li>The output for the depthaction is put after the output of the inaction.
</li>
</ul>
The outaction is executed directly after the depthaction.<br/>
<ul>
<li>The output for the outaction is put after the output of all actions for the lines with a larger indent after the matched line.
</li>
<br/>
</ul>
any of above described elements may be missing or may occur one or more times in any order.<br/>
If the definition of an action occurs more than once, all subactions are performed in<br/>
the given order except for the outactions which are performed in the reverse order<br/>
Find details in <a href="examples/truscape/tru/action_examples/intro.tru">action_examples/intro.tru</a><br/>
as well as in <a href="examples/truscape/tru/action_examples/perl_code.tru" >perl_code.tru</a> and in <a href="examples/truscape/tru/action_examples/outstatements.tru" >outstatements.tru</a><br/>
<br/>
some actions are special:<br/>
<ul>
<li>DOC
<br/>
wraps around the whole document<br/>
receives ARGV as arguments<br/>
$_ is also set to ARGV<br/>
READ is not applied to this<br/>
you do not see it in the structure<br/>
at level 0<br/>
$DOC has no useful meaning.<br/>
Use $ARGV to access the currently processed file<br/>
Find details in <a href="examples/truscape/tru/action_examples/DOC.tru">action_examples/DOC.tru</a><br/>
</li>
<li>UNMATCHED
<br/>
used if a line is not otherwise matched<br/>
If you do not supply one, tru will provide one for you which prints to STDERR a string indicating the line-number and the contents of the line which does not match.<br/>
It is not necessarily a fault to have unmatched lines.<br/>
Find details in <a href="examples/truscape/tru/action_examples/UNMATCHED.tru">action_examples/UNMATCHED.tru</a><br/>
Find details in <a href="examples/truscape/tru/action_examples/UNMATCHED_default.tru">action_examples/UNMATCHED_default.tru</a><br/>
</li>
<li>VERSION
<br/>
This defines the version of this file<br/>
It can be any string.<br/>
<br/>
If you provide a VERSION, then the truer will have the additional option -version<br/>
<br/>
As shown in the example for OPTIONSandUSAGEpart2, which is build from two input-files,<br/>
there can be many VERSION-Entries for one truer<br/>
</li>
<li>OPTIONS
<br/>
Here you can define the options a truer accepts.<br/>
Options<br/>
<ul>
<li>are case sensitive     (-a and -A are different Options)
</li>
<li>cannot be concatenated (-a -b cannot be said as -ab)
</li>
<li>can be toggle (on/off) or they can accept an argument.
</li>
<br/>
</ul>
for an option with name 'Name' a perl-var with name $opt_Name is created.<br/>
<br/>
technical note:<br/>
<ul>
<li>Options are parsed using the perl-module Getopt::Long
</li>
<li>this module is used in it's default configuration with the exception of "no_ignore_case"
</li>
</ul>
</li>
<li>USAGE
<br/>
Here you can define the usage text.<br/>
the text is defined by simply stripping one leading tab from each line.<br/>
this text is printed to stderr automatically whenever an invalid option is given.<br/>
you can also call usage() to print this text.<br/>
the truer is terminated, when the usage is output.<br/>
more than one USAGE can exist.<br/>
they all together make up the usage-text.<br/>
exactly the first USAGE should have a short text.<br/>
Find details in <a href="examples/truscape/tru/action_examples/OPTIONSandUSAGE.tru">action_examples/OPTIONSandUSAGE.tru</a><br/>
Find details in <a href="examples/truscape/tru/action_examples/OPTIONSandUSAGEpart2.tru">action_examples/OPTIONSandUSAGEpart2.tru</a><br/>
</li>
<li>here text
<br/>
Here named arrays that can be filled with constant text are defined.<br/>
Find details in <a href="examples/truscape/tru/action_examples/HereText.tru">action_examples/HereText.tru</a><br/>
</li>
<li>BEGIN
<br/>
<a name="At20the20beginning2c20but20after20Options20are20parsed20according20to20action20OPTIONS2e"></a>
<h7>At the beginning, but after Options are parsed according to action OPTIONS.</h7>
<div>
$_ and @F are set according to @ARGV.<br/>
<br/>
</div>
Here you can:<br/>
<ul>
<li>preset some vars.
</li>
<li>define perl subs.
</li>
<li>set $stream to 1 here instead of giving -stream to the generated truer.
</li>
<li>set the encoding
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/BEGIN.tru">action_examples/BEGIN.tru</a><br/>
</li>
<li>READ
<br/>
<a name="After20a20line20is20read20and2024level20is20calculated2e"></a>
<h7>After a line is read and $level is calculated.</h7>
<div>
not applied to<br/>
<ul>
<li>lines in @ATTIC
<br/>
you can call tru::read() before unshifting if you wish to apply READ<br/>
</li>
<li>empty lines
<br/>
this has consequences illustrated in READempty.tru<br/>
</li>
</ul>
</div>
$_ holds the line as read (including all indent and tabs)<br/>
You can<br/>
<ul>
<li>modify $_ at will.
</li>
<li>adjust $level here.
</li>
</ul>
Return<br/>
<ul>
<li>1 to skip this line
</li>
<li>2 to end processing
</li>
<li>0 for normal processing (supplied automatically)
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/READ.tru">action_examples/READ.tru</a><br/>
</li>
<li>READ and empty lines:
<br/>
READ is not applied to empty lines.<br/>
Empty lines are not processed until the next non-empty line is read or the end of input is reached.<br/>
This is so that the level for empty lines can be calculated.<br/>
For the same reason READ has to be applied for this (non-empty) line.<br/>
Find details in <a href="examples/truscape/tru/action_examples/READempty.tru">action_examples/READempty.tru</a><br/>
</li>
<li>WRITE
<br/>
When a line is due to be output.<br/>
performed in order of production.<br/>
$_ holds the line to be written.<br/>
In stream-mode it is executed just before a line is written.<br/>
In the default (no-stream-mode) it does not yet do the write. It rather inserts the line in @tru::O for later use by FLUSH.<br/>
use return 1 if you want to suppress a line.<br/>
a return 0 is supplied automatically as last statement<br/>
Find details in <a href="examples/truscape/tru/action_examples/WRITE.tru">action_examples/WRITE.tru</a><br/>
</li>
<li>ATTICREAD
<br/>
After a line is unshifted from ATTIC and $level is calculated.<br/>
not applied to<br/>
<ul>
<li>lines read from input
</li>
<li>empty lines
</li>
</ul>
$_ holds the line as read (including all indent and tabs)<br/>
You can<br/>
<ul>
<li>modify $_ at will.
</li>
<li>adjust $level here.
</li>
</ul>
Return<br/>
<ul>
<li>1 to skip this line
</li>
<li>2 to end processing
</li>
<li>0 for normal processing (supplied automatically)
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/ATTICREAD.tru">action_examples/ATTICREAD.tru</a><br/>
</li>
<li>NEWFILE
<br/>
Whenever an input-file is completely read and the truer is going to switch to the next input-file.<br/>
<br/>
$ARGV holds the name of the now to be closed and completely read file.<br/>
$ARGV[0] holds the name of the next file to be opened.<br/>
<br/>
the default action here is to set $. (the line-number) to 0.<br/>
if you do not wish this behaviour but instead want your truer to continue counting when crossing file-boundaries, then simply put as a last statement:<br/>
<ul>
<li>return 0;
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/NEWFILE.tru">action_examples/NEWFILE.tru</a><br/>
</li>
<li>SPLITAPPLY
<br/>
After having read a line and split into fields. Applied to each field.<br/>
for each line the local var $i is guaranteed to be initialized to 0<br/>
you can use it to count the fields and do specific things for specific fields<br/>
the code given here is called for each field in sequence with $_ set to the field<br/>
it does not affect $_ seen in the action<br/>
Find details in <a href="examples/truscape/tru/action_examples/SPLITAPPLY.tru">action_examples/SPLITAPPLY.tru</a><br/>
</li>
<li>FLUSH
<br/>
When all buffered lines shall actually be written to STDOUT rsp. to the file given with -o.<br/>
It is not processed in stream-mode.<br/>
@_ contains the whole output so far. It is now in sequence. You can modify or otherwise use this output.<br/>
A print @_ is supplied automatically as the last statement. If this is not what you want use return to bypass this.<br/>
Here only perl-statements are allowed, no outstatements, actioncalls or mark using.<br/>
<ul>
<li>Therefore a leading tab does not switch from perl to outstatement.
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/FLUSH.tru">action_examples/FLUSH.tru</a><br/>
</li>
</ul>
</div>
<a name="hooks"></a>
<h3>hooks</h3>
<div>
You can have hooks, that are triggered when text is put at a mark.<br/>
This is described in detail below under <a href="#mark20hooks" >mark hooks</a><br/>
</div>
</div>
</div>
<a name="flow20control"></a>
<h1>flow control</h1>
<div>
<a name="perl20statements"></a>
<h2>perl statements</h2>
<div>
lines in any action pit that start with at least 3 spaces    and<br/>
lines in the hooks ATTICREAD,READ,NEWFILE,SPLITAPPLY,WRITE,BEGIN and FLUSH that start with at least 1 space<br/>
are perl-code<br/>
An exception are lines starting with either<br/>
<ul>
<li>&gt;&gt;
</li>
<li>-&gt;
</li>
<li>--&gt;
</li>
<li>atmark(
</li>
</ul>
These are described in<br/>
<table>
<tr>
  <td>&gt;&gt;</td>
  <td>redirecting actions</td>
</tr>
<tr>
  <td>-&gt;</td>
  <td>calling actions</td>
</tr>
<tr>
  <td>--&gt;</td>
  <td>calling actions</td>
</tr>
<tr>
  <td>atmark(</td>
  <td>marks</td>
</tr>
<tr><td></td></tr>
</table><br/>
The above mentioned exceptions do not hold for FLUSH.<br/>
Find details in <a href="examples/truscape/tru/action_examples/perl_code.tru">action_examples/perl_code.tru</a><br/>
</div>
<a name="output20statements"></a>
<h2>output statements</h2>
<div>
lines starting with a tab are output statements.<br/>
they are valid in all actions as well as the special-actions ATTICREAD,READ,NEWFILE,SPLITAPPLY,WRITE and BEGIN<br/>
But beware that for BEGIN some restrictions apply.<br/>
Find details in <a href="examples/truscape/tru/action_examples/outstatements.tru">action_examples/outstatements.tru</a><br/>
</div>
<a name="predefined20variables20in20perl2dstatements20and20output2dstatements2e"></a>
<h2>predefined variables in perl-statements and output-statements.</h2>
<div>
These variables are automatically filled:<br/>
<ul>
<li>$indent
<br/>
contains the indent (the leading whitespace) as found.<br/>
Find details in <a href="examples/truscape/tru/var_examples/indent.tru">var_examples/indent.tru</a><br/>
</li>
<li>$level
<br/>
contains the absolute indent as a number (starting at 1).<br/>
leading tabs count as much as 8 spaces each.<br/>
Find details in <a href="examples/truscape/tru/var_examples/level.tru">var_examples/level.tru</a><br/>
</li>
<li>$rnr
<br/>
holds the relative linenumber, starting at 1.<br/>
it is 1 in special action DOC.<br/>
relative means relative with respect to the previous line with smaller indent.<br/>
</li>
<li>@rnr
<br/>
holds the relative linenumbers so far.<br/>
There is one entry for each level, even for skipped levels, in which case the corresponding value is empty.<br/>
$rnr[0] is always 1 (for DOC).<br/>
</li>
<li>$.
<br/>
holds the line nr of the input-file.<br/>
it is 0 in special action DOC.<br/>
it starts at 1 for each input-file.<br/>
Find details in <a href="examples/truscape/tru/var_examples/rnr.tru">var_examples/rnr.tru</a><br/>
</li>
<li>$rlevel and $rindent
<br/>
only valid for tabaligned structure items.<br/>
<table>
<tr>
  <td>$rindent</td>
  <td>the relative indent (as string) to the required tab-position, derived from the found indent.</td>
</tr>
<tr>
  <td>$rlevel</td>
  <td>the relative indent (as number) to the required tab-position, basically the length of $rindent if it contained only spaces.</td>
</tr>
</table><br/>
They are only valid in the in-action.<br/>
Find details in <a href="examples/truscape/tru/var_examples/rindent_and_rlevel.tru">var_examples/rindent_and_rlevel.tru</a><br/>
</li>
<li>$NrOfChilds
<br/>
Number of (non-empty) items between inaction and outaction.<br/>
independent of produced output.<br/>
meaningless in stream-mode.<br/>
valid in depthaction and outaction.<br/>
Find details in <a href="examples/truscape/tru/var_examples/NrOfChilds.tru">var_examples/NrOfChilds.tru</a><br/>
</li>
<li>$NrOfLinesFollowing
<br/>
Number of lines generated between inaction and outaction.<br/>
meaningless in stream-mode.<br/>
valid in depthaction and outaction.<br/>
Find details in <a href="examples/truscape/tru/var_examples/NrOfLinesFollowing.tru">var_examples/NrOfLinesFollowing.tru</a><br/>
</li>
<li>$state
<br/>
contains the name of the currently processing action.<br/>
for a called Action it has the value of the first arg.<br/>
Find details in <a href="examples/truscape/tru/var_examples/state.tru">var_examples/state.tru</a><br/>
</li>
</ul>
This variable is not automatically filled, it can be filled by a perl-statement:<br/>
<ul>
<li>@ATTIC
<br/>
whenever something is found in the array @ATTIC this is used as input prior to getting the next line from the standard input rsp. input-file.<br/>
the lines are extracted from this array using unshift, so that the order is preserved if it is filled using push.<br/>
hook ATTICREAD is applied to lines obtained from @ATTIC.<br/>
hook READ is not applied to lines in @ATTIC.<br/>
Find details in <a href="examples/truscape/tru/var_examples/ATTIC.tru">var_examples/ATTIC.tru</a><br/>
</li>
</ul>
Find details in <a href="examples/truscape/tru/action_examples/arguments.tru">action_examples/arguments.tru</a><br/>
</div>
<a name="calling20actions"></a>
<h2>calling actions</h2>
<div>
<a name="Actions20can20be20called20in20two20ways3a"></a>
<h3>Actions can be called in two ways:</h3>
<div>
1)<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;-&gt;action	arg1	arg2</kbd></td>
</tr>
</table><br/>
2)<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;--&gt;action	arg1	arg2	{</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
</div>
compare this to "redirecting actions"<br/>
<br/>
the following line<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;-&gt;calledAction	$F[0]	$F[1]</kbd></td>
</tr>
</table><br/>
is just a shorter way to write the following two lines<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;--&gt;calledAction	$F[0]	$F[1]	{</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
Find details in <a href="examples/truscape/tru/action_examples/callingActions.tru">action_examples/callingActions.tru</a><br/>
</div>
<a name="redirecting20actions"></a>
<h2>redirecting actions</h2>
<div>
Actions can be redirected in several ways:<br/>
<table>
<tr>
  <td>specified in the structure</td>
  <td>redirection example 1 and 2</td>
</tr>
<tr>
  <td>called from the action</td>
  <td>redirection example 3 and 4</td>
</tr>
<tr><td></td></tr>
</table><br/>
compare this to "calling actions"<br/>
Find details in <a href="examples/truscape/tru/action_examples/redirectingActions.tru">action_examples/redirectingActions.tru</a><br/>
</div>
<a name="marks"></a>
<h2>marks</h2>
<div>
marks can be used to place output at specified places.<br/>
<br/>
To define a mark use<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;setmark("markname");</kbd></td>
</tr>
</table><br/>
To use a mark use<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;usemark("markname");</kbd></td>
</tr>
</table><br/>
and end the usage with<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;unusemark();</kbd></td>
</tr>
</table><br/>
Another way to use a mark is<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;atmark("markname") {</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;a block of code</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
usemark must pair with unusemark<br/>
usemark and unusemark can spread across in,depth,out actions<br/>
this means also that usemark can be in a different action than unusemark<br/>
<br/>
atmark("markname") { ... }<br/>
<ul>
<li>cannot spread across in,depth,out actions
</li>
<li>must be the only statement in a line , as in
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;atmark("mark_help") {</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;a block of code</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
</li>
<li>not valid is
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;if (cond) { atmark("mark_help") {</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;# not valid, because atmark() is not the only statement in the line</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;....</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;....</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}}</kbd></td>
</tr>
</table><br/>
</li>
<li>also valid is
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;atmark("mark_help")</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;{</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;a block of code</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
</li>
<li>or even using the implicit forming of blocks for outstatements
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;atmark("mark_help")</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&lt;tabs&gt;smth to print</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&lt;tabs&gt;smth more to print</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;</kbd></td>
</tr>
</table><br/>
</li>
<li>The following block
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;atmark("markname") {</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;a block of code</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
</table><br/>
</li>
<li>is equvialent to
<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;usemark("markname")</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&nbsp;&nbsp;a block of code</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;unusemark()</kbd></td>
</tr>
</table><br/>
</li>
</ul>
<a name="the20order20of20setmark20is20relevant2e"></a>
<h3>the order of setmark is relevant.</h3>
<div>
If you have two (or more) setmark in direct succession then the order is preserved.<br/>
There is a limit of 1000 marks that can be in direct succession.<br/>
<br/>
</div>
to unset a mark use<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;undef $tru::Marks{"markname"}</kbd></td>
</tr>
</table><br/>
marks don't work in stream-mode.<br/>
marks can be used before they are defined, in which case the text is buffered until the mark will be set.<br/>
</div>
<a name="mark20hooks"></a>
<h2>mark hooks</h2>
<div>
<a name="in20the20structure2dsection2027hooks2720you20can20define20hooks20for20each20mark"></a>
<h3>in the structure-section 'hooks' you can define hooks for each mark</h3>
<div>
six kinds of hooks exist<br/>
<table>
<tr>
  <td>[</td>
  <td>(pre-)  surrounds each setmark completetly if the mark was used</td>
</tr>
<tr>
  <td>]</td>
  <td>(post-) surrounds each setmark completetly if the mark was used</td>
</tr>
<tr>
  <td>{</td>
  <td>surrounds each usemark (pre-usemark)</td>
</tr>
<tr>
  <td>-</td>
  <td>surrounds each usemark (pre-usemark, depth)</td>
</tr>
<tr>
  <td>}</td>
  <td>surrounds each usemark (post-usemark)</td>
</tr>
<tr>
  <td>n</td>
  <td>used if the mark was never used</td>
</tr>
</table><br/>
hooks and actions share the same name-space.<br/>
So don't give marks the name of an action.<br/>
<br/>
the order is as follows, for every setmark()<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;[</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;{</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;-</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;usemark() or atmark()</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;{</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;-</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;usemark() or atmark()</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;}</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;]</kbd></td>
</tr>
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;</kbd></td>
</tr>
</table><br/>
in  { , - and } $count holds the counter for usemark() rsp. atmark()<br/>
each hook has in $_ the same content that the calling action had when the mark was used *first*<br/>
</div>
Find details in <a href="examples/truscape/tru/action_examples/marks.tru">action_examples/marks.tru</a><br/>
</div>
<a name="pit20CLEAR"></a>
<h2>pit CLEAR</h2>
<div>
usually if you repeat actions the resulting action has the code of all occurences in the given order.<br/>
with the CLEAR flag to the pit you can start with an ampty action.<br/>
This is useful in constructs like<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;html_tru -source | tru -- - specialized_html.tru</kbd></td>
</tr>
</table><br/>
Find details in <a href="examples/truscape/tru/action_examples/CLEAR.tru">action_examples/CLEAR.tru</a><br/>
</div>
</div>
<a name="Limitations"></a>
<h1>Limitations</h1>
<div>
<a name="Besides20the20few20limitations20perl20imposes20there20is203a"></a>
<h2>Besides the few limitations perl imposes there is :</h2>
<div>
The namespace tru:: is reserved for tru.<br/>
</div>
</div>
<a name="Caveats"></a>
<h1>Caveats</h1>
<div>
in the tru-file in the output (i.e tru::parse) part use two backslashes to get one in the output.<br/>
</div>
<a name="Warnings"></a>
<h1>Warnings</h1>
<div>
do *NOT* think that just because an action is mentioned as unused on option -s you can delete it.<br/>
The action may still be called via<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&gt;&gt;action</kbd></td>
</tr>
</table><br/>
Since it is allowed to call an action via a variable, as in<br/>
<br/><table summary="" class="statements">
<tr class="coderow">
  <td class="code"><kbd>&nbsp;&nbsp;&gt;&gt;$action</kbd></td>
</tr>
</table><br/>
these calls can not be foreseen by the statisticer (-s).<br/>
</div>
<div class="tellgenerator">
  <hr/>
  This Page was generated using <a href="html_tru.html">html_tru</a> <a href="tru.txtTR">tru.txtTR</a>.
  Find more on <a href="http://www.strux.net">www.strux.net</a>
</div>
</body>
</html>
