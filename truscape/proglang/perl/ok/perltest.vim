if ! (has("perl"))
  finish
endif
perl <<EOT
package Strull;
#
# Autogenerated from perl_tru using perltest.plTR
# do not edit this file, look for perltest.plTR and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
#  protos
sub usage;
sub main;
sub test($$@);
sub another_function(\@$$@);
sub foo;
$opt_a = 0;
$opt_b = '/tmp/perltest.out';
$opt_d = 0;
$opt_t = 0;
$opt_s = '';
# based on perltest.plTR , version : 4.0
#****************************************
# about this program
#****************************************
# this program does not serve any special purpose xcept for testing perl_tru
# 
# above line is intentionally left empty
#****************************************
require "AutoLoader.pm";
require "AutoSplit.pm";
# based on perltest.plTR , version : 4.0
require "Benchmark.pm";
use Date::Manip qw(ParseDate DateCalc UnixDate);
## Hand written stuff	1
$varwithtextacrossmultiplelines = "pure perl-code can be produced
 as you can see here
  You could not write such a thing as statement, since a ; would
  be appended to each line
   These lines can be on every indent (starting from the tab position after perl code.
     Indent is taken relative to the perl code statement
  Even tabs					will be left	as given
  	including tabs at the beginning
  ";

## Resuming generated code
# vars
$i=0;                                              # Test statement
$a=0;
BEGIN {
  $x1=1;
  $x2=2;
}
END {
  $x3=3;
}

sub usage
{
  print STDERR <<'EOU';
usage : perltest arg
this program only serves as a test-suite
it does *NOT* do anything use- or harmfull
It simply shows the possibilities
 You can have any indent here
  1
       2
      3
     4
	 6
         6
Tables look like this
1	2
11	22
111	222
1111	2222
11111	22222
111111	222222
1111111	2222222

Text may have a quote (' or ") or other special characters as $. or @ARGV
OPTIONS:
  -a	Run with option a
        more description for option a
  -b:<outname>	write output to file outname
	default for <outname> is /tmp/perltest.out
        more description for option b
  -d	Just accept this for later usage. Text may have a quote (' or ") or other special characters as $. or @ARGV
  -t	Run test
  -s:<file>	output file
  -version	show version information
EOU
  exit(1);
}

sub main
{
  if ( $ARGV[0] eq "-version" ) {
    print "Version :\n";
    print "  perltest.plTR	4.0\n";
    print "  perltest.plTR	4.0\n";
    exit 0
  }
  require "AutoLoader.pm";                         # was a problem once
  usage unless @ARGV;
  $b=0;
  $c=0;
  VIM::Msg("Running\n");
  use Getopt::Long;
  usage() if !GetOptions('s=s','t','d','b=s','a'); # Test Option
    # -a : Run with option a
    if ($opt_a) {
      $a=1;                                        # Test case for Option
    }
    # -b : write output to file outname
    if ($opt_b) {
      $b=1;
      ## Hand written stuff	7
      print "you gave me arg b
        thank you very much\n";
      ## Resuming generated code
    }
    # -d : Just accept this for later usage. Text may have a quote (' or ") or other special characters as $. or @ARGV
    # -t : Run test
    if ($opt_t) {
      test(3,4,(5,6));
    }
    # -s : output file
    if ($opt_s) {
      $st="ts";
    }
  VIM::Msg("-a\t$opt_a\n");
  VIM::Msg("-b\t$opt_b\n");
  VIM::Msg("-c\t$opt_c\n");
  VIM::Msg("-d\t$opt_d\n");
  VIM::Msg("-t\t$opt_t\n");
  VIM::Msg("-s\t$opt_s\n");
  if ($a == 1) {
    VIM::Msg("a is one\n");
  } else {
    VIM::Msg("a is not one\n");
  }
  if ($a == 2) {
    VIM::Msg("a is two\n");
  } else {
    VIM::Msg("a is not two\n");
  }
  if ($a == 3) {
    VIM::Msg("a is three\n");
  } elsif ($a == 4) {
    VIM::Msg("a is four\n");
  }
  if (!($a == 0)) {
    VIM::Msg("a is not null\n");
  } else {
    VIM::Msg("a is null\n");
  }
  for ($i=0;$i<70;$i+=10) {
    if ($i && $i<  30) {
      VIM::Msg("$i smaller 30\n");
    } elsif ($i && $i== 40) {
      VIM::Msg("$i equal fourty\n");
      if ($i ==0) {
        VIM::Msg("  i is zero\n");
      } else {
        VIM::Msg("  i is not zero\n");
      }
    } elsif ($i && $i>  40) {
      VIM::Msg("$i greater fourty\n");
    } else {
      VIM::Msg("$i not matched\n");
    }
  }
  if (!($a)) {
    VIM::Msg("Testing negated test\n");
    VIM::Msg("You did not give me a a\n");
  }
  if ($b) {
    # Test if
    loop:
    for ($i=0;$i<5;$i++) {
      $j = $i*$i;
      for ($k=0;$k<=$i;$k++) {
        VIM::Msg(".");
        next loop if $k == 2;
      }
      VIM::Msg(" $i : $j\n");
    }
    while ($i--) {
      VIM::Msg(" $i\n");
    }
    $i=5;
    # a comment here
    while ($i) {
      VIM::Msg("i : $i\n");
    }
    continue {
      $j--;
      $i--;
    }
    AnotherLabel :
    while ($i++<5) {
      VIM::Msg("$i\n");
    }
  } elsif ($a) {
    VIM::Msg("Thank's for the a\n");
    back: {
      for $i (1,2,3) {
        $j += $i;
      }
      $i = 4;
      for (my $i=10;$i<20;$i=$i+1) {
        VIM::Msg("Nr : $i");
      }
      do {
        VIM::Msg("$i");
        $i--;
      } until	!$i;
    } # back:
  } else {
    # Test else
    STDERR "you did not give me a b\n";
  }
  # vars
  local ($i,$j,$k) = (
    "ich",
    "du",
    "er",
  );
  my @l = (
    "wir",
    "ihr",
    "sie",
  );
  %m = (
    one => "eins",
    two => "zwei",
  );
  VIM::Msg("$i:$j:$k\n");
  VIM::Msg("@l\n");
  VIM::Msg("$m{two}\n");
  local(
    $B,                                            # a big b
    $C );                                          # a big c
  $x =
    "one".
    'two';
  print(a);
  print($b);
  # a block for 1
  print (1);
  print (1); # code for the 1 function
  print (1); # we have trailing tab 1
  
  # a block for 2
  print (2);
  print (2); # code for the 2 function
  print (2); # we have trailing tab 2
  
  # a block for 3
  print (3);
  print (3); # code for the 3 function
  print (3); # we have trailing tab 3
  
  # a block for 7
  print (7);
  print (7); # code for the 7 function
  print (7); # we have trailing tab 7
  
}
# comments as usual are possible
### 
#  this function has a nice name
#  @Author me

sub test($$@)
{
  local ($scalar1,$scalar2,@array) = @_;
  VIM::Msg("called test()\n");
  VIM::Msg("scalar1 = $scalar1\n");
  VIM::Msg("scalar2 = $scalar2\n");
  VIM::Msg("array = @array\n");
  $a = "(..)";                                     # ##PURE##
}

sub another_function(\@$$@)
{
  VIM::Msg("this function is never called\n");
  #and here is a comment with	some	tabsepareted	fields
  #a2b;
  #c2d;
  a#b2
  c#d2
  foo(
    1,
    2,
    [
      3,
      4,
      {
        a => "b",
        c => "d"
      },
      ### 
      #  comments possible
      
      sub ($)
      {
        local ($txt) = @_;
        return ":$txt:";
      },
      5
    ]
  );
}

sub foo
{
  print "$_[2][2]{a}\n";
  print $_[2][3]("jubel");
}
if (1) {
  VIM::Msg("code not in a function");
}
EOT
