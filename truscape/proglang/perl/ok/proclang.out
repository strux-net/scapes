#!/usr/bin/perl
#
# Autogenerated from perl_tru using STDIN
# do not edit this file, look for STDIN and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
#  protos
sub usage;
sub main;
sub function 1;
sub function2($$);
$opt_a = 0;
$opt_b = 0;
$opt_c = '';
$opt_d = 30;
$opt_n = 1.2;
$opt_e = '';
$opt_f = '/tmp/schrott';
if (@ARGV == 1 and $ARGV[0] eq '-?') {
  usage();
}
## Hand written stuff	1
freeline 1
freeline 2	with tab
 freeline 3	with tab
     freeline 4

freeline with special character $. 'quote' "double_quote" @ARGV
D	"a line beginning with D"
## Resuming generated code
#  comment
# vars
var 1;
var 2;                                             # comment var 2
D;                                                 # a var with name D
var 3 = (
  init 1,
  init 2,                                          # comment init 2
  D,                                               # "a value of a var with name D"
);
var 4 = (                                          # comment var 4
  init 1,
  init 2,                                          # comment init 2
);
#****************************************
# freeline 1
# freeline 2	with tab
#  freeline 3	with tab
#      freeline 4
#      
# freeline with special character $. 'quote' "double_quote" @ARGV
# D	"a line beginning with D"
#****************************************

sub usage
{
  print STDERR <<'EOU';
usage : shortdesc
freeline 1
freeline 2	with tab
 freeline 3	with tab
     freeline 4

freeline with special character $. 'quote' "double_quote" @ARGV
D	"a line beginning with D"
OPTIONS:
  -a	shortdesc a with special character $. 'quote' "double_quote" @ARGV
  -b	shortdesc b
  -c:<num>	shortdesc c
	no default for <num>
  -d:<num>	shortdesc d
	default for <num> is 30
  -n:<num>	shortdesc n
	default for <num> is 1.2
  -e:<file>	shortdesc e
	no default for <file>
  -f:<file>	shortdesc f
	default for <file> is /tmp/schrott
EOU
  exit(1);
}
#Code outside any function
ThisCodeIsNotInAFunction();
### 
#  an autocomment for main

sub main
{
  use Getopt::Long;
  usage() if !GetOptions('f=s','e=s','n=s','d=s','c=s','b','a'); # comment Option
    # -a : shortdesc a with special character $. 'quote' "double_quote" @ARGV
    # -b : shortdesc b
    if ($opt_b) {
      stmt b;
    }
    # -c : shortdesc c
    # -d : shortdesc d
    # -n : shortdesc n
    # -e : shortdesc e
    if ($opt_e) {
      stmt e;
    }
    # -f : shortdesc f
    if ($opt_f) {
      stmt f;
    }
  #****************************************
  # some comment tests
  #   with indent
  #****************************************
  if (commenttest1) {
    #****************************************
    # main commentline
    #****************************************
    # another comment
    #   with indent
    #****************************************
    if (commenttest2) {
      #****************************************
      # only a main commentline
      #****************************************
      statement;
    } else {
      #****************************************
      # to have more than 3 comments
      #   with indent
      #****************************************
      statement;
    }
  }
}
### 
#  an autocomment for function 1

sub function 1
{
  # vars
  var 1;
  var 2;                                           # comment var 2
  D;                                               # a var with name D
  var 3 = (
    init 1,
    init 2,                                        # comment init 2
    D,                                             # "a value of a var with name D"
  );
  var 4 = (                                        # comment var 4
    init 1,
    init 2,                                        # comment init 2
  );
  #****************************************
  # freeline 1
  # freeline 2	with tab
  #  freeline 3	with tab
  #      freeline 4
  #      
  # freeline with special character $. 'quote' "double_quote" @ARGV
  # D	"a line beginning with D"
  #****************************************
  while (1) {
    stmt;
  }
  while (1) {
    stmt 1;
    stmt 2;
    print "a D in a loop";
  }
  while (1) {
    stmt;
  }
  for (i=0;i<20;i=i+1) {
    print "ja";
  }
  for (i=0;i<10;i++) {
    forloopstatement;
  }
  for (i=0;i<10;i++) {
    forloopstatement;
  }
  while (expr) {
  }
  do {
  } until	expr;
  while (expr) {
    stmt;
  }
  do {
    stmt;
  } until	expr;
  while (expr) {
    stmt;
  }
  do {
    stmt;
  } until	expr;
  while (expr) {
    stmt 1;
    stmt 2;
  }
  do {
    stmt 1;
    stmt 2;
  } until	expr;
  if (expr1) {
    stmt1;
    print "a D in an if (tagged i)";
    more stuff inside D (tagged i);
    for (i=0;i<10;i++) {
      forloopstatement;
    }
  } else {
    stmt2;
  }
  if (expr2) {
    truestmt2;
  }
  if (expr3) {
    truestmt3;
  } else {
    falsestmt3;
  }
  if (expr4) {
    truestmt4;
  } elsif (expr5) {
    truestmt5;
  } elsif (expr6) {
    truestmt6;
  } elsif (expr7) {
    truestmt7;
  } else {
    falsestmt7;
  }
  if (expr8) {
  } elsif (!(expr9)) {
    truestmt9;
  } else {
    falsestmt9;
  }
  if (!(expr10)) {
  }
  if (!(expr11)) {
    truestmt11;
  }
  if (!(expr12)) {
    truestmt12;
  } else {
    falsestmt12;
  }
  if (middlepart) {
  } else {
  }
  if (middlepart) {
  }
  if (-) {
  }
  if (leftpartmiddlepart) {
    statement;
  } else {
    stmnt;
  }
  if (leftpartmiddlepart) {
    statement;
  }
  if (leftpart-) {
    stmnt;
  }
  if (leftpartmiddlepartrightpart) {
    LeftOfStmtstatementRightOfStmt;
  } else {
    falsestmt;
  } elsif (leftpart--rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  if (leftpartmiddlepartrightpart) {
    LeftOfStmtstatementRightOfStmt;
  }
  if (leftpart-rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  if (leftpart--rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  statement;
  statement;                                       # comment statement
  print "magically printed";
  print "magically printed";                       # comment magically printed
  ## Hand written stuff	3
  freeline 1
  freeline 2	with tab
   freeline 3	with tab
       freeline 4
  
  freeline with special character $. 'quote' "double_quote" @ARGV
  D	"a line beginning with D"
  ## Resuming generated code
  s/a/ae/g;
  s/A/Ae/;
  s/b//;
  foo(a) + bar(
  foo(a) + bar(b);
  foo(a) + bar(b);c
  foo(1) + bar(2);
  foo(1.1) + bar(2.2);
  foo(one) + bar(two);
  a1b1
  d
  d1
  d1e
  d1e1
  d1e1f
  
  a2b2
  d
  d2
  d2e
  d2e2
  d2e2f
  
  a3b3
  d
  d3
  d3e
  d3e3
  d3e3f
  
  bar("one");
  baz(1);
  
  bar("two");
  baz(2);
  
  bar("three");
  baz(3);
  
  #  comment
    a statement with a comment as parent;
    if (true) {
      print "yes";
    }
  #  comment
  $perltruS1=i;
  while (1) {
    if ($perltruS1 == 'a') {
      'One';
      last;
    }
    if ($perltruS1 == 'b') {
      'two';
      $perltruS2=j;
      while (1) {
        if ($perltruS2 == 'A') {
          'eins';
          last;
        }
        if ($perltruS2 == 'B') {
          'zwei';
          last;
        }
        'sau viel';
        last;
      }
      last;
    }
    if ($perltruS1 == 'c') {
      'three';
      last;
    }
    'something else';
    last;
  }
  'cut';
  $perltruS3=i;
  while (1) {
    if ($perltruS3 == 'a') {
      'One';
      $perltruS3_c = 1;
    }
    if (($perltruS3 == 'b') || $perltruS3_c == 1) {
      'two';
      $perltruS4=j;
      while (1) {
        if ($perltruS4 == 'A') {
          'eins';
          last;
        }
        if ($perltruS4 == 'B') {
          'zwei';
          last;
        }
        'sau viel';
        last;
      }
      $perltruS3_c = 2;
    }
    if (($perltruS3 == 'c') || $perltruS3_c == 2) {
      'three';
      $perltruS3_c = 3;
    }
    'something else';
    last;
  }
  use Try::Tiny;
  try {
    trystmt;
  } catch {
      execption1stmt;
  } catch {
      execption2stmt;
  } finally {
      finallystmt;
  }
  try {
    trystmt;
  } catch {
    execption1stmt;
  } catch {
    execption2stmt;
  } finally {
    finallystmt;
  }
  ## Hand written stuff	3
goes to the very left
  but indentation survives
  ## Resuming generated code
}

sub function2($$)
{
  local ($a, $b) = @_;
  label1: {
  } # label1:
  label2:
  for (expr;expr;expr) {
  }
  label3:
  for (expr;expr;expr) {
    stmt;
  }
  for (expr;expr;expr) {
  }
  for (expr;expr;expr) {
    stmt;
  }
  label4:
  for (expr) {
    stmt;
  }
  label5:
  while (expr) {
    stmt;
  }
  label6:
  do {
    stmt;
  } until	expr;
  map {
    $i++;
    s/a/b/;
    s/c/d/g;
  } @Array;
}
main();
