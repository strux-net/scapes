"
" Autogenerated from vim_tru using test.vimTR
" do not edit this file, look for test.vimTR and change this
" or you may loose all your changes and probably choose the wrong method.
" goto http://www.strux.net to find more information.
"
" based on test.vimTR , version : 3.1
"usage for testfile
"	This file serves no special purpose
"
"	It does nothing particularly use- or harmful
"	  I promise
"	commands
"		A	comment for coma
"		B	comment for comb
"		LL	start LL
"		C	comment for comc, next (com D) is whitout comment
"		D	
"		E	comment for come, has options
"	v-mappings for buffer /buffername/
"	d:	Helptext 1
"	n-mappings for buffer /buffername/
"	notes for commmands
"	  this is a general help for all commands
"	    with indent and	tab
"
"	    and an empty line
"	notes for more for commands
"	<2-leftmouse>	Helptext 1
"	  documentation for this 2-leftmouse
"	<2-rightmouse>	Helptext 2
"	d:	Helptext 3
"	  documentation for this command
"	   with odd indent and an ' to see if it survives
"	     and some tabs	tab
"	       and more text
"	d.	Helptext 4
"	  documentation for d.
"	  Example :
"	    P return if $f !~ /\d+/  ;my $s;open F,"$f/stat" and do { $s .= (split(/\s+/,<F>))[2]." ";close F };open F,"$f/status" and do { $s .= (split(/\t+|\n/,<F>))[1]."\t";close F };open F,"$f/cmdline" and do { my $x = <F>;$x =~ s/\0/ /g;$s.=$x;close F };$s
"	      the above command is equivalent to the shell-command above.
"	  See also :
"	      <C-L>
"	      u
"	global n-mappings
"	i	installs this version
"	r	rerun everything
"	t	remake
"	..	Back one level
"	global v-mappings
"	i	installs this version
"	bm	
"	bm1	
"	bm3	
"	m 0	
"	m 1	
"	m 2	comment
"	m 3	comment 2
"	m 1	
"	m 2	comment
"	m 1	
"	m 2	comment
"	x	comment
"	<M-t>	
"	a	
"	Map noremap	
"	Map nnoremap	
"	Map vnoremap	
"	Map onoremap	
"	Map noremap!	
"	Map inoremap	
"	Map cnoremap	
"	m 1	
"
"	Configuration variables
"	  The following vars can be set in your .vimrc or in your environment.
"	  Settings in the environment have the highest precedence.
"
"	g:strux_LL_colored : use colored output
"	  (can be superseded with the environment-var $strux_LL_colored)
"	g:strux_LL_shell : the shell for the <f4> commands	(defaults to 'bash -i')
"	  (can be superseded with the environment-var $strux_LL_shell)
"		  This can be used to tell the shell to do additional initializations.
"		  e.G if you specified|g:strux_LL_shell|to be /bin/bash and want it to also
"		  obey your aliases, functions and other settings, you can do
"		    let g:strux_LL_shell_setup='shopt -s expand_aliases;source ~/.profile'
"
"---------------------------------------------
function <sid>Help_v2f6275666665726e616d652f_1()
  echohl WarningMsg
  echo 'Helptext 1 (bound to d:)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f6275666665726e616d652f_636f6d6d6d616e6473()
  echo 'this is a general help for all commands'
  echo '  with indent and	tab'
  echo '  '
  echo '  and an empty line'
  :call <sid>Help_n2f6275666665726e616d652f_6d6f726520666f7220636f6d6d616e6473()
endfunction
function <sid>Help_n2f6275666665726e616d652f_6d6f726520666f7220636f6d6d616e6473()
endfunction
function <sid>Help_n2f6275666665726e616d652f_1()
  echohl WarningMsg
  echo 'Helptext 1 (bound to <2-leftmouse>)'
  echohl None
  echo ''
  echo 'documentation for this 2-leftmouse'
endfunction
function <sid>Help_n2f6275666665726e616d652f_2()
  echohl WarningMsg
  echo 'Helptext 2 (bound to <2-rightmouse>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f6275666665726e616d652f_3()
  echohl WarningMsg
  echo 'Helptext 3 (bound to d:)'
  echohl None
  echo ''
  echo 'documentation for this command'
  echo ' with odd indent and an '' to see if it survives'
  echo '   and some tabs	tab'
  echo '     and more text'
endfunction
function <sid>Help_n2f6275666665726e616d652f_4()
  echohl WarningMsg
  echo 'Helptext 4 (bound to d.)'
  echohl None
  echo ''
  echo 'documentation for d.'
  echo 'Example :'
  echo '  P return if $f !~ /\d+/  ;my $s;open F,"$f/stat" and do { $s .= (split(/\s+/,<F>))[2]." ";close F };open F,"$f/status" and do { $s .= (split(/\t+|\n/,<F>))[1]."\t";close F };open F,"$f/cmdline" and do { my $x = <F>;$x =~ s/\0/ /g;$s.=$x;close F };$s'
  echo '    the above command is equivalent to the shell-command above.'
  echo 'See also :'
  echo '    <C-L>'
  echo '    u'
endfunction
function <sid>Help_n_1()
  echohl WarningMsg
  echo 'installs this version (bound to i)'
  echohl None
  echo ''
endfunction
function <sid>Help_n_2()
  echohl WarningMsg
  echo 'rerun everything (bound to r)'
  echohl None
  echo ''
endfunction
function <sid>Help_n_3()
  echohl WarningMsg
  echo 'remake (bound to t)'
  echohl None
  echo ''
endfunction
function <sid>Help_n_4()
  echohl WarningMsg
  echo 'Back one level (bound to ..)'
  echohl None
  echo ''
endfunction
function <sid>Help_v_1()
  echohl WarningMsg
  echo 'installs this version (bound to i)'
  echohl None
  echo ''
endfunction
" the interface
" VInterfaceOFF for /buffername/
function!VInterfaceOFF_2f6275666665726e616d652f()
  if exists("b:VInterface_2f6275666665726e616d652f_MapsDone")
    vunmenu &Do.&specified<tab>d:
    unlet b:VInterface_2f6275666665726e616d652f_MapsDone
  endif
endf
function!<sid>Help_v2f6275666665726e616d652f()
  echo '1	d:	Helptext 1'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_v2f6275666665726e616d652f_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" VInterfaceON for /buffername/
function!VInterfaceON_2f6275666665726e616d652f()
  if !exists("b:VInterface_2f6275666665726e616d652f_MapsDone")
    vnoremap <buffer> <F1> :<C-U>call <sid>Help_v2f6275666665726e616d652f()<CR>gv
    vnoremenu &Do.&specified<tab>d: :echo "v-c"
    vnoremap <buffer> <silent> d: :echo "v-c"
    augroup g2f6275666665726e616d652f
      au! BufLeave <buffer>
      au BufLeave <buffer> call VInterfaceOFF_2f6275666665726e616d652f()
    augroup END
    let b:VInterface_2f6275666665726e616d652f_MapsDone=1
    if !exists("b:_2f6275666665726e616d652f_HintGiven")
      unsilent echo 'special mappings from test.vimTR available. Press <F1> for a list'
    endif
    let b:_2f6275666665726e616d652f_HintGiven=1
  endif
endf
" Hooking the VInterfaces for /buffername/
au BufEnter /buffername/ call VInterfaceON_2f6275666665726e616d652f()
" the interface
" InterfaceOFF for /buffername/
function!InterfaceOFF_2f6275666665726e616d652f()
  if exists("b:Interface_2f6275666665726e616d652f_MapsDone")
    nunmenu &Do.&specified<tab>d:
    nunmenu &Do.&Repeat\ Last<tab>d\.
    unlet b:Interface_2f6275666665726e616d652f_MapsDone
  endif
endf
function!<sid>Help_n2f6275666665726e616d652f()
  echo '1	<2-leftmouse>	Helptext 1'
  echo '2	<2-rightmouse>	Helptext 2'
  echo '3	d:	Helptext 3'
  echo '4	d.	Helptext 4'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f6275666665726e616d652f_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /buffername/
function!InterfaceON_2f6275666665726e616d652f()
  if !exists("b:Interface_2f6275666665726e616d652f_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f6275666665726e616d652f()<CR>
    nnoremenu &Do.&specified<tab>d: :echo "c"
    nnoremenu &Do.&Repeat\ Last<tab>d\. :echo "d"
    nnoremap <buffer> <silent> <2-leftmouse> :echo "a"
    nnoremap <buffer> <silent> <2-rightmouse> :echo "b"
    nnoremap <buffer> d: :call <sid>Help_n2f6275666665726e616d652f_3()<cr>:call <sid>Help_n2f6275666665726e616d652f_636f6d6d6d616e6473()<cr>:echo "c"
    nnoremap <buffer> <silent> d. :echo "d"
    augroup g2f6275666665726e616d652f
      au BufLeave <buffer> call InterfaceOFF_2f6275666665726e616d652f()
    augroup END
    let b:Interface_2f6275666665726e616d652f_MapsDone=1
    if !exists("b:_2f6275666665726e616d652f_HintGiven")
      unsilent echo 'special mappings from test.vimTR available. Press <F1> for a list'
    endif
    let b:_2f6275666665726e616d652f_HintGiven=1
  endif
endf
" Hooking the Interfaces for /buffername/
au BufEnter /buffername/ call InterfaceON_2f6275666665726e616d652f()
" the interface
    nnoremenu Plugin.File.&install<tab>i :ls
    nnoremenu Plugin.File.rerun<tab>r :ls<CR>
    nnoremenu Plugin.File.comp&ile\ and\ run<tab>t :echo<CR>
    nnoremenu Plugin.View.B&ack<tab>\.\. :echo "back"<CR>
    nnoremap <silent> i :ls
    nnoremap <silent> r :ls<CR>
    nnoremap <silent> t :echo<CR>
    nnoremap <silent> .. :echo "back"<CR>
" the interface
    vnoremenu Plugin.File.&install<tab>i :ls
    vnoremap <silent> i :ls
  "comment
au BufEnter test.vim echo "got it"
au BufEnter test.vim $
au BufEnter another.file echo "got this too"
if exists("#OptionSet")
  au OptionSet tabstop echo "tabstop changed"
endif
" b -> not very funny and pretty useless
" mapping for b unfolded
"   d$	delete till end of line
"   jj	two lines down
"   d0	delete till start of line
if !hasmapto("d$jjd0")
  map b d$jjd0
endif
" <M-t> -> 
" mapping for <M-t> unfolded
"   :<C-U>exe "perl tabify(".line("'<").",".line("'>").")"<CR>
if !hasmapto(":<C-U>exe \"perl tabify(\".line(\"'<\").\",\".line(\"'>\").\")\"<CR>")
  map <M-t> :<C-U>exe "perl tabify(".line("'<").",".line("'>").")"<CR>
endif
" a -> not very funny and pretty useless
" mapping for a unfolded
"   d$	delete till end of line
"   jj	two lines down
"   d0	delete till start of line
vmap a d$jjd0
map <buffer> bm 1
map <buffer> bm1 2
map <buffer> bm3 3
map m 0 echo("0")
map m 1 echo("1")
" m 2       -> comment
map m 2 echo("2")
"comment 1
" m 3       -> comment 2
map m 3 echo("3")
vmap m 1 echo("1")
" m 2       -> comment
vmap m 2 echo("2")
if !hasmapto("echo(\"1\")",'v')
  vmap m 1 echo("1")
endif
if !hasmapto("echo(\"2\")",'v')
  " m 2       -> comment
  vmap m 2 echo("2")
endif
if !hasmapto("echo(\"4\")")
  " x       -> comment
  map x echo("4")
endif
if !hasmapto(":<C-U>exe \"perl tabify(\".line(\"'<\").\",\".line(\"'>\").\")\"<CR>")
  map <M-t> :<C-U>exe "perl tabify(".line("'<").",".line("'>").")"<CR>
endif
ab st foo
iab ts <C-R>=strftime("%d.%m.%Y %T")
if !hasmapto("eisundstaub",'n')
  nnoremap <silent> a eisundstaub
endif
noremap Map noremap echo("noremap")
nnoremap Map nnoremap echo("nnoremap")
vnoremap Map vnoremap echo("vnoremap")
onoremap Map onoremap echo("onoremap")
noremap! Map noremap! echo(" noremap!")
inoremap Map inoremap echo("inoremap")
cnoremap Map cnoremap echo("cnoremap")
function!Counter(limit) 
  :put='Limit = '.a:limit
  " Local inside function (global outside)
  let var=1
  " Local to the current buffer.
  let b:var=1
  " Local to the current window.
  let w:var=1
  " Global.
  let g:var=1
  " Local to a function.
  let l:var=1
  " Local to a |:source|'ed Vim script.
  let s:var=1
  " Function argument (only inside a function).
  let a:var=1
  " Global, predefined by Vim.
  let v:var=1
  " for (k=1;k<=a:limit;k=k+1)
  let k=1
  while 1
    if !(k<=a:limit)
      break
    endif
    " Comments work
    :put='  more Line for '.a:limit.' = '.k
    " for (i=1;i<=k;i=i+1)
    let i=1
    while 1
      if !(i<=k)
        break
      endif
      :put='  '.i
      let i=i+1
    endwhile
    let k=k+1
  endwhile
endfunc
function!Fac(n) 
  " vars
  let a=1
  let b="be"
  let w = [
    \ one
    \ two
  ]
  if a:n==0
    return 1
  endif
  return a:n*Fac(a:n-1)
endfunc
"-- 
"  a function with a nice name
"  @author me
function!Test1() 
  " Comments work
  let i=0
  map <buffer>
  set
  ab
  au
  au BufWritePre
  while i<10
    " Comments work
    :put='Line '.i
    let i=i+1
  endwhile
  perl <<EOT
  #  protos
  sub main;
  
  sub main
  {
    $h=`hostname`;
    VIM::Msg("Host is $h");
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("Anser yes or no : ","$last_answer")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      $x = $answer;
    }
    #****************************************
    # this is a comment inside a perl-block
    # perl
    #   $a=1
    #****************************************
    disp {
      bufname => "/LL/",
      Array => \@POSSIBILITIES,
      in_function => sub {$curbuf->Append(0,$f)},
      item_function => \&poss,
      linenr => 3,
    };
  }
  main();
EOT
  while 1
    let i=i-1
    " Comments work
    :put='another Line '.i
    if i==0
      break
    endif
  endwhile
  call Counter(3)
  call Counter(4)
  :put='fac(5) = '.Fac(5)
  " for (i=1;;i=i+1)
  let i=1
  while 1
    let i=i+1
  endwhile
  let vimtruS1=i
  while 1
    if vimtruS1 ==# 1
      echo 'eins'
      break
    endif
    if vimtruS1 ==# 2
      zwei(twee)
      break
    endif
    echo 'something else'
    break
  endwhile
endfunc
"-- 
"  the main entry
"    and some lines	with tabs in the comment
" use colored output
if exists("$strux_LL_colored")
  let g:strux_LL_colored=$strux_LL_colored
endif
if !exists("g:strux_LL_colored")
  let g:strux_LL_colored=0
else
  echo 'Colored enabled'
endif
" the shell for the <f4> commands
if exists("$strux_LL_shell")
  let g:strux_LL_shell=$strux_LL_shell
endif
if !exists("g:strux_LL_shell")
  let g:strux_LL_shell='bash -i'
else
  echo 'shell changed to g:strux_LL_shell'
endif
"comment for coma
com A a
"comment for comb
com B b
"start LL
com! -n=? -complete=file LL perl LLorRedisp('<args>')
" a comment for C and D
"comment for comc, next (com D) is whitout comment
com! C c
com! D d
"comment for come, has options
com! -nargs 1 E c
highlight StatusLine term=bold,reverse cterm=bold ctermfg=green ctermbg=blue gui=bold guifg=green guibg=blue
highlight StatusLine term=bold,reverse cterm=bold ctermfg=green ctermbg=blue gui=bold guifg=green guibg=blue
%d
call Test1()
wq
map m 1 m 1
"comment
set splitbelow
" with comment
setlocal sw=3
set aw
set noai
"comment
set sr
" only for demo
" unfolded first
" :ls	show the buffers
" j0		goto next line
" "xy$	yank the line to register y :: NOTE this line begins with " and is passed correctly
normal! :lsj0"xy$
for var in keys(t:)
  echo 'let t:'. var . '=' . string(t:{var}). ''
endfor
" wrong  : s/a/b/
" wrong  : s/c/
s/a/b/
s/c//
perl <<EOT
#  protos
sub foo;

sub foo
{
  $curbuf->Append($item++,"name\t$fullname4internal");
}
EOT
