/*
* Autogenerated from c_tru using STDIN
* do not edit this file, look for STDIN and change this
* or you may loose all your changes and probably choose the wrong method.
* goto http://www.strux.net to find more information.
*/
#if	HAVE_CONFIG_H
#include <config.h>
#endif
/* protos */
void usage();
global code();
int main(int argc,char **argv);
function 1();
enum(enum1);
int opt_a = 0;
int opt_b = 0;
const char *opt_c = "";
int opt_d = 30;
float opt_n = 1.2;
const char *opt_e = "";
const char *opt_f = "/tmp/schrott";
/* Hand written stuff	1 */
freeline 1
freeline 2	with tab
 freeline 3	with tab
     freeline 4

freeline with special character $. 'quote' "double_quote" @ARGV
D	"a line beginning with D"
/* Resuming generated code */
//  comment
/* vars */
var 1;
/** comment var 2 */
var 2;
/** a var with name D */
D;
var 3 = {
  init 1,
  init 2,                                         /* comment init 2 */
  D,                                              /* "a value of a var with name D" */
};
/** comment var 4 */
var 4 = {
  init 1,
  init 2,                                         /* comment init 2 */
};
/*****************************************
* freeline 1
* freeline 2	with tab
*  freeline 3	with tab
*      freeline 4
*      
* freeline with special character $. 'quote' "double_quote" @ARGV
* D	"a line beginning with D"
*****************************************/
/**
 * emit a usage to stderr and exit with code 1
 */
void usage()
{
  fputs("usage : shortdesc\n",stderr);
  fputs("freeline 1\n",stderr);
  fputs("freeline 2	with tab\n",stderr);
  fputs(" freeline 3	with tab\n",stderr);
  fputs("     freeline 4\n",stderr);
  fputs("\n",stderr);
  fputs("freeline with special character $. 'quote' \"double_quote\" @ARGV\n",stderr);
  fputs("D	\"a line beginning with D\"\n",stderr);
  fputs("OPTIONS:\n",stderr);
  fputs("	-a	shortdesc a with special character $. 'quote' \"double_quote\" @ARGV\n",stderr);
  fputs("	-b	shortdesc b\n",stderr);
  fputs("	-c=num	shortdesc c\n",stderr);
  fputs("		no default for <num>\n",stderr);
  fputs("	-d=num	shortdesc d\n",stderr);
  fputs("		default for num is 30\n",stderr);
  fputs("	-n=num	shortdesc n\n",stderr);
  fputs("		default for num is 1.2\n",stderr);
  fputs("	-e=file	shortdesc e\n",stderr);
  fputs("		no default for <file>\n",stderr);
  fputs("	-f=file	shortdesc f\n",stderr);
  fputs("		default for file is /tmp/schrott\n",stderr);
  exit(1);
}

global code()
{
  ThisCodeIsNotInAFunction();
}
/**
*  an autocomment for main
*/

int main(int argc,char **argv)
{
  if (argc == 2 && argv[1][0] == '-' && argv[1][1] == '?' && argv[1][2] == '\0') {
    usage();
  }
  char optchar;
#include <getopt.h>
  while ((optchar=getopt(argc,argv,"f:e:n:d:c:ba")) != EOF) {/* comment Option */
    /* -a : shortdesc a with special character $. 'quote' "double_quote" @ARGV */
    if (optchar == 'a') {
      opt_a++;
    }
    /* -b : shortdesc b */
    if (optchar == 'b') {
      opt_b++;
      stmt b;
    }
    /* -c : shortdesc c */
    if (optchar == 'c') {
      if (*optarg == '=') optarg++;
      opt_c = optarg;
    }
    /* -d : shortdesc d */
    if (optchar == 'd') {
      if (*optarg == '=') optarg++;
      opt_d = atoi(optarg);
    }
    /* -n : shortdesc n */
    if (optchar == 'n') {
      if (*optarg == '=') optarg++;
      opt_n = atof(optarg);
    }
    /* -e : shortdesc e */
    if (optchar == 'e') {
      if (*optarg == '=') optarg++;
      opt_e = optarg;
      stmt e;
    }
    /* -f : shortdesc f */
    if (optchar == 'f') {
      if (*optarg == '=') optarg++;
      opt_f = optarg;
      stmt f;
    }
    if (optchar == '?') usage();
  }
  /*****************************************
  * some comment tests
  *   with indent
  *****************************************/
  if (commenttest1) {
    /*****************************************
    * main commentline
    ***************************************
    * another comment
    *   with indent
    *****************************************/
    if (commenttest2) {
      /*****************************************
      * only a main commentline
      *****************************************/
      statement;
    } else {
      /*****************************************
      * to have more than 3 comments
      *   with indent
      *****************************************/
      statement;
    }
  }
}
/**
*  an autocomment for function 1
*/

function 1()
{
  /* vars */
  var 1;
  /** comment var 2 */
  var 2;
  /** a var with name D */
  D;
  var 3 = {
    init 1,
    init 2,                                       /* comment init 2 */
    D,                                            /* "a value of a var with name D" */
  };
  /** comment var 4 */
  var 4 = {
    init 1,
    init 2,                                       /* comment init 2 */
  };
  /*****************************************
  * freeline 1
  * freeline 2	with tab
  *  freeline 3	with tab
  *      freeline 4
  *      
  * freeline with special character $. 'quote' "double_quote" @ARGV
  * D	"a line beginning with D"
  *****************************************/
  while (1) {
    stmt;
  }
  while (1) {
    stmt 1;
    stmt 2;
    printf("a D in a loop");
  }
  while (1) {
    stmt;
  }
  for (i=0;i<20;i=i+1) {
    printf("ja");
  }
  for (i=0;i<10;i++) {
    forloopstatement;
  }
  for (i=0;i<10;i++) {
    forloopstatement;
  }
  while (expr) {
  }
  do {
  } while (!(expr));
  while (expr) {
    stmt;
  }
  do {
    stmt;
  } while (!(expr));
  while (expr) {
    stmt;
  }
  do {
    stmt;
  } while (!(expr));
  while (expr) {
    stmt 1;
    stmt 2;
  }
  do {
    stmt 1;
    stmt 2;
  } while (!(expr));
  if (expr1) {
    stmt1;
    printf("a D in an if (tagged i)");
    more stuff inside D (tagged i);
    for (i=0;i<10;i++) {
      forloopstatement;
    }
  } else {
    stmt2;
  }
  if (expr2) {
    truestmt2;
  }
  if (expr3) {
    truestmt3;
  } else {
    falsestmt3;
  }
  if (expr4) {
    truestmt4;
  } else if (expr5) {
    truestmt5;
  } else if (expr6) {
    truestmt6;
  } else if (expr7) {
    truestmt7;
  } else {
    falsestmt7;
  }
  if (expr8) {
  } else if (!(expr9)) {
    truestmt9;
  } else {
    falsestmt9;
  }
  if (!(expr10)) {
  }
  if (!(expr11)) {
    truestmt11;
  }
  if (!(expr12)) {
    truestmt12;
  } else {
    falsestmt12;
  }
  if (middlepart) {
  } else {
  }
  if (middlepart) {
  }
  if (-) {
  }
  if (leftpartmiddlepart) {
    statement;
  } else {
    stmnt;
  }
  if (leftpartmiddlepart) {
    statement;
  }
  if (leftpart-) {
    stmnt;
  }
  if (leftpartmiddlepartrightpart) {
    LeftOfStmtstatementRightOfStmt;
  } else {
    falsestmt;
  } else if (leftpart--rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  if (leftpartmiddlepartrightpart) {
    LeftOfStmtstatementRightOfStmt;
  }
  if (leftpart-rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  if (leftpart--rightpart) {
    LeftOfStmtfalsestmtRightOfStmt;
  }
  statement;
  statement;                                       // comment statement
  printf("magically printed");
  printf("magically printed");                     // comment magically printed
  /* Hand written stuff	3 */
  freeline 1
  freeline 2	with tab
   freeline 3	with tab
       freeline 4
  
  freeline with special character $. 'quote' "double_quote" @ARGV
  D	"a line beginning with D"
  /* Resuming generated code */
  s/a/ae/g;
  s/A/Ae/;
  s/b//;
  foo(a) + bar(
  foo(a) + bar(b);
  foo(a) + bar(b);c
  foo(1) + bar(2);
  foo(1.1) + bar(2.2);
  foo(one) + bar(two);
  a1b1
  d
  d1
  d1e
  d1e1
  d1e1f
  
  a2b2
  d
  d2
  d2e
  d2e2
  d2e2f
  
  a3b3
  d
  d3
  d3e
  d3e3
  d3e3f
  
  bar("one");
  baz(1);
  
  bar("two");
  baz(2);
  
  bar("three");
  baz(3);
  
  //  comment
    a statement with a comment as parent;
    if (true) {
      printf("yes");
    }
  //  comment
  switch (i) {
    case 'a' :
    {
      'One';
      break;
    }
    case 'b' :
    {
      'two';
      switch (j) {
        case 'A' :
        {
          'eins';
          break;
        }
        case 'B' :
        {
          'zwei';
          break;
        }
        default :
        {
          'sau viel';
          break;
        }
      }
      break;
    }
    case 'c' :
    {
      'three';
      break;
    }
    default :
    {
      'something else';
      break;
    }
  }
  'cut';
  switch (i) {
    case 'a' :
    {
      'One';
    }
    case 'b' :
    {
      'two';
      switch (j) {
        case 'A' :
        {
          'eins';
          break;
        }
        case 'B' :
        {
          'zwei';
          break;
        }
        default :
        {
          'sau viel';
          break;
        }
      }
    }
    case 'c' :
    {
      'three';
    }
    default :
    {
      'something else';
    }
  }
  try {
    trystmt;
  } catch (execption1) {
    execption1stmt;
  } catch (execption2) {
    execption2stmt;
  } finally {
    finallystmt;
  }
  try {
    trystmt;
  } catch (execption1) {
    execption1stmt;
  } catch (execption2) {
    execption2stmt;
  } finally {
    finallystmt;
  }
  /* Hand written stuff	3 */
goes to the very left
  but indentation survives
  /* Resuming generated code */
}
// comment
#define	  A
#define	  B	definition for B
/** comment for C */
#define	  C	definition for C
#define	D	definition1 for D\
definition2 for D\
definition3 for D		with tab\
definition4 for D (and an empty line follows-which should survive)\
\
  

enum(enum1)
{
  eins;
  zwei;                                            // comment for zwei
  drei;
}
#include "include1"
#include "include2"
#include <include3>
#include <include4>
void function2(int a, char b);

void function2(int a, char b)
{
  // comment
}
int base::function1()
{
#compiler directive
}
int base::function2(int a, int b)
{
}
int base::function2(int a, int b) : basecall(a)
{
  switch (expr) {                                 /* comment for switch */
    default :                                     /* comment for default */
    {
      statement for default;
      break;
    }
    case a :
    case b :
    {
      statement for b;
      break;
    }
    case c :                                      /* comment for c */
    {
      statement for c;
      break;
    }
  }
}
