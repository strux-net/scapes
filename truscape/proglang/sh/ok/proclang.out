#!/bin/bash
#
# Autogenerated from sh_tru using STDIN
# do not edit this file, look for STDIN and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
opt_a=0
opt_b=0
opt_c=''
opt_d=30
opt_n=1.2
opt_e=''
opt_f='/tmp/schrott'
## Hand written stuff	1
freeline 1
freeline 2	with tab
 freeline 3	with tab
     freeline 4

freeline with special character $. 'quote' "double_quote" @ARGV
D	"a line beginning with D"
## Resuming generated code
#  comment
# vars
var 1;
var 2;                                             # comment var 2
D;                                                 # a var with name D
var 3=(
  init 1
  init 2                                           # comment init 2
  D                                                # "a value of a var with name D"
)
var 4=(                                            # comment var 4
  init 1
  init 2                                           # comment init 2
)
#****************************************
# freeline 1
# freeline 2	with tab
#  freeline 3	with tab
#      freeline 4
#      
# freeline with special character $. 'quote' "double_quote" @ARGV
# D	"a line beginning with D"
#****************************************

usage()
{
  cat <<'EOU' >&2
usage : shortdesc
freeline 1
freeline 2	with tab
 freeline 3	with tab
     freeline 4

freeline with special character $. 'quote' "double_quote" @ARGV
D	"a line beginning with D"
OPTIONS:
  -a	shortdesc a with special character $. 'quote' "double_quote" @ARGV
  -b	shortdesc b
  -c:<num>	shortdesc c
	no default for <num>
  -d:<num>	shortdesc d
	default for <num> is 30
  -n:<num>	shortdesc n
	default for <num> is 1.2
  -e:<file>	shortdesc e
	no default for <file>
  -f:<file>	shortdesc f
	default for <file> is /tmp/schrott
EOU
  exit 1
}
#Code outside any function
ThisCodeIsNotInAFunction()
### 
#  an autocomment for main
main()
{
  if [ $# -eq 1 -a "$1" = '-?' ] ; then
    usage
  fi
  while getopts 'f: e: n: d: c: b a' opt ; do      # comment Option
    # Checking the options
    # -a : shortdesc a with special character $. 'quote' "double_quote" @ARGV
    if [ "$opt" = 'a' ] ; then
      (( opt_a++ ))
    fi
    # -b : shortdesc b
    if [ "$opt" = 'b' ] ; then
      (( opt_b++ ))
      stmt b
    fi
    # -c : shortdesc c
    if [ "$opt" = 'c' ] ; then
      opt_c="${OPTARG#*=}"
    fi
    # -d : shortdesc d
    if [ "$opt" = 'd' ] ; then
      opt_d="${OPTARG#*=}"
    fi
    # -n : shortdesc n
    if [ "$opt" = 'n' ] ; then
      opt_n="${OPTARG#*=}"
    fi
    # -e : shortdesc e
    if [ "$opt" = 'e' ] ; then
      opt_e="${OPTARG#*=}"
      stmt e
    fi
    # -f : shortdesc f
    if [ "$opt" = 'f' ] ; then
      opt_f="${OPTARG#*=}"
      stmt f
    fi
    [ "$opt" = "?" ] && usage
  done # Checking the options
  shift $((OPTIND-1))
  [ "$1" = "--" ] && shift
  #****************************************
  # some comment tests
  #   with indent
  #****************************************
  if commenttest1 ; then
    #****************************************
    # main commentline
    #****************************************
    # another comment
    #   with indent
    #****************************************
    if commenttest2 ; then
      #****************************************
      # only a main commentline
      #****************************************
      statement
    else
      #****************************************
      # to have more than 3 comments
      #   with indent
      #****************************************
      statement
    fi
  fi
}
### 
#  an autocomment for function 1
function 1()
{
  # vars
  var 1;
  var 2;                                           # comment var 2
  D;                                               # a var with name D
  var 3=(
    init 1
    init 2                                         # comment init 2
    D                                              # "a value of a var with name D"
  )
  var 4=(                                          # comment var 4
    init 1
    init 2                                         # comment init 2
  )
  #****************************************
  # freeline 1
  # freeline 2	with tab
  #  freeline 3	with tab
  #      freeline 4
  #      
  # freeline with special character $. 'quote' "double_quote" @ARGV
  # D	"a line beginning with D"
  #****************************************
  while : ; do
    stmt
  done
  while : ; do
    stmt 1
    stmt 2
    echo "a D in a loop"
  done
  while : ; do
    stmt
  done
  for (( i=0;i<20;i=i+1 )) ; do
    echo "ja"
  done
  for (( i=0;i<10;i++ )) ; do
    forloopstatement
  done
  for (( i=0;i<10;i++ )) ; do
    forloopstatement
  done
  while expr ; do
  done
  until expr;do
  done
  while expr ; do
    stmt
  done
  until expr;do
    stmt
  done
  while expr ; do
    stmt
  done
  until expr;do
    stmt
  done
  while expr ; do
    stmt 1
    stmt 2
  done
  until expr;do
    stmt 1
    stmt 2
  done
  if expr1 ; then
    stmt1
    echo "a D in an if (tagged i)"
    more stuff inside D (tagged i)
    for (( i=0;i<10;i++ )) ; do
      forloopstatement
    done
  else
    stmt2
  fi
  if expr2 ; then
    truestmt2
  fi
  if expr3 ; then
    truestmt3
  else
    falsestmt3
  fi
  if expr4 ; then
    truestmt4
  elif expr5 ; then
    truestmt5
  elif expr6 ; then
    truestmt6
  elif expr7 ; then
    truestmt7
  else
    falsestmt7
  fi
  if expr8 ; then
  elif ! expr9 ; then
    truestmt9
  else
    falsestmt9
  fi
  if ! expr10 ; then
  fi
  if ! expr11 ; then
    truestmt11
  fi
  if ! expr12 ; then
    truestmt12
  else
    falsestmt12
  fi
  if middlepart ; then
  else
  fi
  if middlepart ; then
  fi
  if - ; then
  fi
  if leftpartmiddlepart ; then
    statement
  else
    stmnt
  fi
  if leftpartmiddlepart ; then
    statement
  fi
  if leftpart- ; then
    stmnt
  fi
  if leftpartmiddlepartrightpart ; then
    LeftOfStmtstatementRightOfStmt
  else
    falsestmt
  elif leftpart--rightpart ; then
    LeftOfStmtfalsestmtRightOfStmt
  fi
  if leftpartmiddlepartrightpart ; then
    LeftOfStmtstatementRightOfStmt
  fi
  if leftpart-rightpart ; then
    LeftOfStmtfalsestmtRightOfStmt
  fi
  if leftpart--rightpart ; then
    LeftOfStmtfalsestmtRightOfStmt
  fi
  statement
  statement                                        # comment statement
  echo "magically printed"
  echo "magically printed"                         # comment magically printed
  ## Hand written stuff	3
  freeline 1
  freeline 2	with tab
   freeline 3	with tab
       freeline 4
  
  freeline with special character $. 'quote' "double_quote" @ARGV
  D	"a line beginning with D"
  ## Resuming generated code
  s/a/ae/g;
  s/A/Ae/;
  s/b//;
  foo(a) + bar(
  foo(a) + bar(b);
  foo(a) + bar(b);c
  foo(1) + bar(2);
  foo(1.1) + bar(2.2);
  foo(one) + bar(two);
  a1b1
  d
  d1
  d1e
  d1e1
  d1e1f
  
  a2b2
  d
  d2
  d2e
  d2e2
  d2e2f
  
  a3b3
  d
  d3
  d3e
  d3e3
  d3e3f
  
  bar("one");
  baz(1);
  
  bar("two");
  baz(2);
  
  bar("three");
  baz(3);
  
  #  comment
    a statement with a comment as parent
    if true ; then
      echo "yes"
    fi
  #  comment
  shtruS1=i
  while : ; do
    if [ "$shtruS1" == 'a' ]; then
      'One'
      break
    fi
    if [ "$shtruS1" == 'b' ]; then
      'two'
      shtruS2=j
      while : ; do
        if [ "$shtruS2" == 'A' ]; then
          'eins'
          break
        fi
        if [ "$shtruS2" == 'B' ]; then
          'zwei'
          break
        fi
        'sau viel'
        break
      done
      break
    fi
    if [ "$shtruS1" == 'c' ]; then
      'three'
      break
    fi
    'something else'
    break
  done
  'cut'
  shtruS3=i
  while : ; do
    if [ "$shtruS3" == 'a' ]; then
      'One'
      shtruS3_c=1
    fi
    if [ "$shtruS3" == 'b' -o "$shtruS3_c" == "1" ]; then
      'two'
      shtruS4=j
      while : ; do
        if [ "$shtruS4" == 'A' ]; then
          'eins'
          break
        fi
        if [ "$shtruS4" == 'B' ]; then
          'zwei'
          break
        fi
        'sau viel'
        break
      done
      shtruS3_c=2
    fi
    if [ "$shtruS3" == 'c' -o "$shtruS3_c" == "2" ]; then
      'three'
      shtruS3_c=3
    fi
    'something else'
    break
  done
  try                                              # trystmt
    execption1                                     # execption1stmt
    execption2                                     # execption2stmt
    finally                                        # finallystmt
  try
      trystmt
    execption1
      execption1stmt
    execption2
      execption2stmt
    finally
      finallystmt
  ## Hand written stuff	3
goes to the very left
  but indentation survives
  ## Resuming generated code
}
function2()
{
  local a=$1
  local b=$2
}
main "$@"
