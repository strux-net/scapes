#!/usr/bin/perl
#
# Autogenerated from perl_tru using xtractStructure.plTR
# do not edit this file, look for xtractStructure.plTR and change this
# or you may loose all your changes and probably choose the wrong method.
# goto http://www.strux.net to find more information.
#
#  protos
sub main;
sub resolveLinks($);
sub uriWarnings;
sub specialAction($);
sub MakeValidURI($$);
sub emitHit($);
sub emit($);
sub doemit($$);
sub colorize($);
sub xtractStructureTest;
sub completeStructure;
sub structureFor($);
sub readStructure($);
sub fillHashAndArrays;
sub printStructure;
sub printHash;
# based on xtractStructure.plTR , version : 4.0
#****************************************
# @Structure	Array containing `$truer -vstructure -groupExpand`
# @FileNames	Array (same size as @Structure) with corresponding filenames
# @Indent	Array (same size as @Structure) with corresponding indents    (as a number basically counting the leading spaces)
# @Pattern	Array (same size as @Structure) with corresponding patterns   (no leading or trailing spaces)
# @Indicator	Array (same size as @Structure) with corresponding indicators (inclusive action)
# @Regexp	Array (same size as @Structure) with corresponding regexp     (no leading or trailing spaces)
# @Action	Array (same size as @Structure) with corresponding action
# %Hits		Hash{action} of Array with index-numbers into @Structure
# %Uri		Hash{'link'|'anchor'}{action} for warnings
#****************************************

sub main
{
  if ( $ARGV[0] eq "-version" ) {
    print "Version :\n";
    print "  xtractStructure.plTR	4.0\n";
    exit 0
  }
  #xtractStructureTest()
  1;
}

sub resolveLinks($)
{
  local ($_) = @_;
  s/\|([^\s](.+?[^\s])?)\|/sprintf '<A href="#A_'.MakeValidURI('link',$1).qq(">$1<\/a>)/ge;
  return $_;
}

sub uriWarnings
{
  for my $key (sort keys %{$Uri{'link'}}) {
    if ($key ne '[]' and !defined $Uri{'anchor'}{$key}) {
      print STDERR "warning link '$key' does not resolve\n";
    }
  }
  for my $key (sort keys %{$Uri{'see'}}) {
    if (!(defined $Uri{'anchor'}{$key})) {
      print STDERR "warning see for link '$key' does not resolve\n";
    }
  }
  for my $key (sort keys %{$Uri{'anchor'}}) {
    $val = ${$Uri{'anchor'}}{$key};
    if (!defined $Uri{'link'}{$key} and !specialAction($key)) {
      print STDERR "warning anchor '$key' is not used in structure\n";
    }
    if ($val != 1) {
      print STDERR "warning anchor '$key' defined $val times\n";
    }
  }
}

sub specialAction($)
{
  local ($name) = @_;
  for ("DOC", "READ", "WRITE", "BEGIN", "OPTIONS", "USAGE", "UNMATCHED") {
    if ($name eq $_) {
      return 1;
    }
  }
  return 0;
}
### 
#  @$context the context of usage (either 'link' or 'anchor')
#  make a valid uri for the given txt and return it

sub MakeValidURI($$)
{
  local ($context,$_) = @_;
  $Uri{$context}{$_}++;                            # for warnings
  s/\&nbsp;//g;
  s/([^a-zA-Z0-9_])/sprintf "%2x",ord($1)/ge;
  return $_;
}

sub emitHit($)
{
  local ($i) = @_;
  doemit($i,"hit");
}

sub emit($)
{
  local ($i) = @_;
  if ($Action[$i] eq $rootItem) {
    emitHit($i);
  } else {
    doemit($i,"structure");
  }
}

sub doemit($$)
{
  local ($i,$class) = @_;
  $Emitted[$i] = 1;
  $string = $Structure[$i];
  if (!($string =~ /^structure$/)) {
    my $pattern   = $Pattern[$i];
    my $indicator = $Indicator[$i] || "=";
    my $regexp    = $Regexp[$i];
    $pattern =~ s/&/&amp;/g;
    $pattern =~ s/</&lt;/g;
    $pattern =~ s/>/&gt;/g;
    $indicator =~ s/&/&amp;/g;
    $indicator =~ s/</&lt;/g;
    $indicator =~ s/>/&gt;/g;
    $regexp =~ s/&/&amp;/g;
    $regexp =~ s/</&lt;/g;
    $regexp =~ s/>/&gt;/g;
    if ($class ne "hit") {
      if ($pattern eq "[]") {
        $pattern = qq(<A href="howtoread/posIndicator.html">[]</a>);
      } else {
        if (!($pattern =~ s/^\[([^\t]+)\]/qq([<A href="#A_).MakeValidURI('link',$Action[$i]).qq(">$1]<\/a>)/e)) {
          $pattern =~ s/^([^\t]+)/qq(<A href="#A_)     .MakeValidURI('link',$Action[$i]).qq(">$1<\/a>)/e;
        }
      }
    }
    $pattern = colorize($pattern);
    $indicator = colorize($indicator);
    $regexp = colorize($regexp);
    my $indent    = qq(<a class="tabSep" title = "Indent (not counting leading tab) : @{[ $Indent[$i] - 8 ]}">).($Indent[$i]?q(       |):"")." "x($Indent[$i]-8)."</a>";
    tru::write("<tr class=\"$class\"><td>$indent$pattern</td><td>$indicator</td><td>$regexp</td></tr>");
  } else {
    tru::write(qq(<tr><td><a class="structureInd" title="$FileNames[$i]">$string</a></td><td></td><td></td></tr>));
  }
}

sub colorize($)
{
  local ($string) = @_;
  while (1) {
    last unless $string=~s:(\t+)([^\t]+):q(<ping>).("\cC" x length($1))."$2</ping>":e;
    last unless $string=~s:(\t+)([^\t]+):q(<pong>).("\cC" x length($1))."$2</pong>":e;
  }
  $string =~ s:\cC:<a title="here is a Tab">\t</a>:g;
  return $string;
}

sub xtractStructureTest
{
  readStructure("java_tru");
  fillHashAndArrays;
  for (keys(%Hits)) {
    structureFor($_);
  }
  return;
  printHash;
  printStructure;
}

sub completeStructure
{
  for (my $i=0;$i<@Structure;$i=$i+1) {
    emit($i);
  }
}

sub structureFor($)
{
  local ($item) = @_;
  $rootItem = $item;
  @Emitted = [];
  for $i (@{$Hits{$item}}) {
    if ($Emitted[$i]) {
      next;
    }
    my $thislevel = $Indent[$i];
    @Pre = ();
    for ($j=$i-1;$j>=0;$j--) {
      if ($Indent[$j] < $thislevel) {
        push @Pre,$j;
        if (!($thislevel = $Indent[$j])) {
          last;
        }
      }
    }
    for ($j=$#Pre;$j>=0;$j--) {
      emit($Pre[$j]);
    }
    emitHit($i);
    $thislevel = $Indent[$i];
    for ($j=$i+1;$j<@Structure;$j=$j+1) {
      if ($Indent[$j] <= $thislevel) {
        last;
      }
      emit($j);
    }
  }
}

sub readStructure($)
{
  local ($truer) = @_;
  my $filename;
  @StructureWithFilenames =`$truer -vstructure -groupExpand`;
  chomp @StructureWithFilenames ;
  for (@StructureWithFilenames) {
    if (/^#file\t([^\t]+)/) {
      ($filename = $1) =~ s/^$ENV{'HOME'}/~/o;
    } else {
      push @Structure,$_;
      push @FileNames,$filename;
    }
  }
}

sub fillHashAndArrays
{
  for (my $i=0;$i<@Structure;$i=$i+1) {
    $_=$Structure[$i];
    chomp;
    next if /^\s*$/;                               # empty lines are ignored in structure
    next if /^structure$/;
    while (s/^(\t*)\t/$1        /) {
    }
    ($level) = /(^ +)/;
    $level = length($level);                       # level = indent (leading tabs count 8 spaces)
    $Indent[$i] = $level;
    s/^ +//;                                       # we now have level and don't need the indent
    local $indicator;
    local $explicit     = "";
    local $notcontained = "";
    ($pattern,$indicator,$regexp) = split /\t+([=>][^\t]*)\t*/,$_,3;
    $Pattern[$i]   = $pattern;
    $Indicator[$i] = $indicator;
    $Regexp[$i]    = $regexp;
    if (!($indicator)) {
      $indicator="=";
    }
    @names = split /\t+/,$pattern;
    if ($indicator =~ s/ +([^(]+)//) {
      $action = $1;
    } else {
      $action = $names[0];
    }
    $action =~ s/^\[(.+)\]$/$1/;
    push @{ $Hits{$action} },$i;
    $Action[$i]     = $action;
  }
}

sub printStructure
{
  for (my $i=0;$i<@Structure;$i=$i+1) {
    print "$i\t$Indent[$i]\t$Structure[$i]";
  }
}

sub printHash
{
  for (keys(%Hits)) {
    print "$_\t@{$Hits{$_}}\n";
  }
}
main();
