VERSION	3.1
USAGE	m_tru mTR > makefile.
	produces a makefile based on the content of mTR

	see examples in *scape/mTR
actions
  DOC
    >
	# Autogenerated makefile
	# by :
	#   m_tru mTR >makefile
	#
      # m_copy and m_diff only handle files w/o spaces in them, quoting them would disable ~-expansion
	m_diff=bash -c 'if ! diff -a -q \$\$1 ok/\$\$1 >/dev/null ; then echo -e "BAD\\t\$\$1\\tok/\$\$1" ; else echo -e "GOOD\\t\$\$1" ; fi ; ' m_diff
	m_copy=bash -c 'if ! diff -a -q \$\$1 \$\$2    >/dev/null ; then echo copying \$\$1 \$\$2; cp -p \$\$1 \$\$2 ; fi ; ' m_copy
	ALL:\\
      setmark("mark_ALL");

       |
	install install_ALL:\\
      setmark("mark_install_ALL");

       |
	test test_ALL:\\
      setmark("mark_test_ALL");
       |
	logged_build:
		-\@\${MAKE} --no-print-directory ALL test_ALL 2>&1 | perl -pe 's,\$\$ENV{HOME}/,~/,g' >m.log # substitute /home/username with ~  (to avoid test-fails for trivial reasons)
		\@\${m_diff} m.log
	confirmed_install: confirm install
	confirm:
		\@bash -c 'read -p "really install ? (^C) if not"'
  goal	source
    >
      setmark("mark_install");
	test_$goal: $goal
      atmark("mark_test_ALL")
	  test_$goal\\
      setmark("mark_test");
	.PHONY: $goal
	$goal:
		\@echo  building $goal
      if ($source ne "") {
        >>	build	$source
      }
      atmark("mark_ALL")
	  $goal\\
      atmark("mark_install_ALL")
	  install_$goal\\
  test		testfile
    >
      usemark("mark_test");
      if ($testfile) {
        ($Out=$testfile) =~ s/TR$// or $Out.=".out";
        $Out =~ s|.*/||;
        >>statement	perl $goal $testfile	$Out
      }
    <
      unusemark("mark_test");
  .vimTR		source
    >
      >>statement	vim_tru $source	$goal
  .shTR		source
    >
      >>statement	sh_tru $source	$goal
      >>statement	chmod +x $goal
  .jsTR		source
    >
      >>statement	js_tru $source	$goal
  .htmlTR		source
    >
      >>statement	html_tru $source	$goal
  .htmlTC		source
    >
      >>statement	tagcloser_tru $source	$goal
  .javaTR		source
    >
      >>statement	java_tru $source	$goal
  .plTR		source
    >
      >>statement	perl_tru $source	$goal
      >>statement	chmod +x $goal
  .tru		source
    >
      $statistics_out = "statistics.out".$statistics_out_count;
      $statistics_out_count++;
      >>statement	tru -s $statistics_out $source	$goal
      >>statement	m_diff $statistics_out
      >>statement	chmod +x $goal
  install
    >
      usemark("mark_install");
    <
      unusemark("mark_install");
  installrule
    >
      s/\$/\$\$/g;
      s/^m_copy /\@\${m_copy} /;
		$_
  comment
    A comment.
      it is silently ignored
  statement	outfile
    Any statement.
      all $ are replaced by $$ (to make them transparent in the makefile)
    two statements are treated specially :

      1)
	m_diff whatever

	->

	@\${m_diff} whatever
	\@\${m_copy} whatever ok/  # in the appropriate section

	it results in a install-rule for whatever
	m_diff is transformed to @${m_diff}

      2)
	m_copy whatever ok/

	->

	@\${m_copy} whatever ok/

    >
      $_=$statement;
      s/\$/\$\$/g;
      if (s/^m_diff +(.*)/\@\${m_diff} $1/) {
        atmark("mark_install") {
		\@\${m_copy} $1 ok/$1
        }
      }
      s/^m_copy /\@\${m_copy} /;
      if ($outfile) {
		$_ >$outfile
		\@\${m_diff} $outfile
        atmark("mark_install") {
		\@\${m_copy} $outfile ok/$outfile
        }
      } else {
		$_
      }
  build	source
    >
        if ($source) {
          $source =~ /.+(\.javaTR|\.tru|\.plTR|\.shTR|\.vimTR|\.kaptnTR|\.jsTR|\.htmlT[RC])$/;
          >>	$1	$source
        }
  file
    >
		\@\${m_copy} $file $context/$file
  2ok	file
    >
      $context="ok";
      >>file	$file
  2bin	file
    >
      $context="~/bin";
      >>2binHelper
  2struxbin	file
    >
      $context="~/strux/bin";
      >>2binHelper
  2binHelper
    -
      unless ($NrOfLinesFollowing) {
        $file = $goal unless $file;
        >>file	$file
      }
  vimdefault	flags
    default helpfiles for a .vimTR
      produces
        docs/README.txt			simple parsing basename.vim	flags contains : txt
        docs/README.html		using  htm_tru docs/README.txt	flags contains : html
        docs/basename-commands.txt	using  vimInterface2Help_tru	flags contains : commands

      rebuilds the help-tags.

      It relies on :
	a single vimTR file is used
	  this file is named like the goal (eg. foo.vimTR -> foo.vim)
	the title is specified
    >
      ($basename=$goal)=~s/\.vim$//;
      if ($flags =~ /txt/) {
        >>statement	{ echo "$goal\\n  $Title\\n    usage"; < $goal perl -na -e 'if (\$seq = (/^"usage for / .. /"--/) and \$seq !~ /E0/ and \$seq>1) { s/.//;s/^\\s+\$/\\n/;print }' ; }	docs/README.txt
      }
      >>htmldefault
      if ($flags =~ /commands/) {
        >>statement	Title="*$basename.txt*   $Title" vimInterface2Help_tru $basename.vimTR	docs/$basename-commands.txt
      }
      atmark("mark_install") {
		vim -u NONE -c 'helptags ~/.vim/doc' -c q
      }

  trudefault	flags
    default helpfiles for a .tru
      produces
        docs/README.txt		simple parsing basename.vim	flags contains : txt
        docs/README.html	using  htm_tru docs/README.txt	flags contains : html

      It relies on :
	the title is specified
    >
      if ($flags =~ /txt/) {
        >>statement	{ echo "$goal\\n  $Title\\n    usage"; ./$goal -? 2>&1 | i -it 1 ; }	docs/README.txt
      }
      >>htmldefault
  shdefault	flags
    default helpfiles for a .shTR
      produces
        docs/README.txt		simple parsing basename.vim	flags contains : txt
        docs/README.html	using  htm_tru docs/README.txt	flags contains : html

      It relies on :
	the title is specified
    >
      if ($flags =~ /txt/) {
        >>statement	{ echo "$goal\\n  $Title\\n    usage"; ./$goal -? 2>&1 | i -it 1 ; }	docs/README.txt
      }
      >>htmldefault
  htmldefault
    >
      if ($flags =~ /html/) {
        >>statement	{ sed "s/^    usage\$/    code/" docs/README.txt ; echo "style\\n  Title\\t$Title" ; } | html_tru	docs/README.html
      }
  title		Title
    sets the env-var $Title to $Title
    >
	export Title=$Title
hooks
  mark_install
    [
	install_$goal:
		\@echo  installing $goal
  mark_test
    n
		\@: # an empty action. To avoid nothing to be done for test_whatever
    [
		\@echo  testing $goal
structure
	EMPTY				>*		.{0}
	comment		*		=2		#.*
	title		[Title]		=		title
	goal		[source]
	  build		[source]	=		build
	    statement	[outfile]	=		/^[^#]/		.*
	  test		[testfile]	=		test
	    statement	[outfile]	=		/^[^#]/		.*
	  doc				=		doc
	    vimdefault	[flags]		=		vimdefault
	    trudefault	[flags]		=		trudefault
	    shdefault	[flags]		=		shdefault
	    statement	[outfile]	=		/^[^#]/		.*
	  install			=		install
	    2struxbin	[file]		=		2struxbin
	      file
	    2bin	[file]		=		2bin
	      file
	    2ok		file		=		2ok
	    installrule
	  helpers			=		helpers
	    ignored	*		=*
