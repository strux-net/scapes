"
" Autogenerated from vim_tru using LL.vimTR
" do not edit this file, look for LL.vimTR and change this
" or you may loose all your changes and probably choose the wrong method.
" goto http://www.strux.net to find more information.
"
" based on LL.vimTR , version : 3.4e
"****************************************
" README
"****************************************
" # installing
"   this plugin requires some helpers as well as help- and conf-files.
"   as it is part of the [strux-tools](http://www.strux.net/toolsindex.html) it's best you install them.
"****************************************
"usage for LL - a powerful file-browser
"	commands
"		LL	start LL for current or given dir/file
"		L	convert current buffer to LL
"		LLF	LL for files returned be find
"		LLG	LL for files containing a given regexp
"		LLO	LL for files returned by a shellcmd
"		LLasIf	reapply auto-dirsetting according to a given pattern. The default pattern is used if no pattern is given.
"		LLShell	start a Shell connected to LL
"		LT	show LL for cd in terminal
"	n-mappings for buffer /strux/LL
"	notes for new filename
"	     prompts for a new name for the file or dir under the cursor.
"	     The usual filename-completion works on the input-line.
"	     The new file name is preset with the current-name for easy editing.
"	     Type ctrl-u to clear the line and type a completely new path/name
"
"	     A check is performed whether the new file already exists.
"	       In this case you are asked for confirmation.
"	       Reply with y or Y if you really want the action.
"	     Cancel the action with Escape or Ctrl-C
"	<2-leftmouse>	Edit the file
"	  Double-click is the same as <CR>
"	<CR>	Edit the file
"	  Edit the file under the cursor in the same vim.
"	  Come back to the directory-view with :LL
"	  If the cursor is on the header-line toggle it between normal/descriptive
"	  Also see |g:strux_LL_editcmd|.
"	fr	Rename the file under the cursor
"	  Renaming is tried in two steps.
"	    First it is tried with the build-in rename().
"	    If this fails (e.G if the rename is cross-device), a call to mv is issued.
"	fc	Copy the file under the cursor
"	  A check is performed whether the source is a directory
"	    In this case you are asked for confirmation to recurse.
"	    Reply with y or Y if you really want a recursive copy
"	fd	Delete the file under the cursor
"	  prompts for confirmation
"	    Reply with y or Y if you really want the action.
"	  Checks whether the file is a directory and whether it is not empty
"	    In this case you are again asked for confirmation.
"	    Reply with y or Y if you really want a recursive delete
"	  Cancel the action with Escape or Ctrl-C
"	f+	Put the filename into the clipboard
"	f*	Put the filename into primary
"	f"	Put the filename into vim's unnamed register (")
"	fp+	Put the filename with path into the clipboard
"	fp*	Put the filename with path into primary
"	fp"	Put the filename with path into vim's unnamed register (")
"	notes for shell command
"	  At the prompt enter a shell-command.
"	  the full-filename is appended to the command (as "$f") if the command does not already contain $
"	  The command is NOT subject to vim's treating of some chars as % and #
"
"	  See |g:strux_LL_shell| for configuring how the command is started.
"
"	  The following vars are set for the command:
"	      $f	filename with path		/path/to/file/name.ext
"	      $p	path				/path/to/file
"	      $F	filename as given		name.ext
"	      $r	filename without extension	name
"	      $e	extension			ext
"	  Cancel the action with Escape or Ctrl-C
"	dv	View
"	  View the file according to the mailcap file
"	de	Edit
"	  Edit the file according to the mailcap file
"	dc	Compose
"	  Compose (create) the file according to the mailcap file
"	dp	Print
"	  Print the file according to the mailcap file
"	d<F4>	Execute a command
"	d1<F4>	Execute a command in an xterm
"	d2<F4>	Execute a command in an background xterm
"	d<S-F4>	Execute a command and read output into a new buffer
"	d.	Repeat last command
"	  Repeats the last command, this time with the file that is now selected.
"	  Whether the output is displayed or ignored is remembered from the last command.
"	  An error-message is issued if there is no last command.
"	cc	Open the command window
"	  Opens the command-vindow (holds the file ~/frequentCommands)
"	  The current working directory for the commands executed in this window is what LL just shows.
"
"	  You can invoke it with <count>cc (as in 3cc) to make the window <count> lines high.
"
"	  Special mappings are available in this window.
"	    press <F1> in this window to get help on these mappings
"	<F4>	Execute this command
"	  This command is basically the same as
"	    ,cc	open the command window
"	    <F4>	execute the command where the cursor is on
"	    LL	reenter the LL-window
"	5<F4>	Execute this command (old style)
"	  This command is basically the same as
"	    ,cc	open the command window
"	    <F4>	execute the command where the cursor is on
"	    LL	reenter the LL-window
"	1<F4>	Execute this command in an xterm
"	  This command is basically the same as
"	    ,cc	open the command window
"	    1<F4>	execute the command where the cursor is on in an xterm
"	    LL	reenter the LL-window
"	2<F4>	Execute this command in an background xterm
"	  This command is basically the same as
"	    ,cc	open the command window
"	    2<F4>	execute the command where the cursor is on in an background xterm
"	    LL	reenter the LL-window
"	<S-F4>	Execute this command.Read Output into a &new buffer
"	  This command is basically the same as
"	    ,cc	open the command window
"	    <S-F4>	execute the command where the cursor is and read output into a new buffer
"	    LL	reenter the LL-window
"	dd	Execute acmd for current file
"	  execute acmd for current file
"	d?	Open acmd-menu for current file
"	  show all possible acmd commands for current file
"	  Special mappings are available in this window.
"	    press <F1> in this window to get help on these mappings
"	dr	Reread the acmd-database
"	  reread the acmd database
"	sn	Sort by Name
"	  Sort the entries alphabetically by name, obeying case
"	  Example :
"	    A.c < a.c
"	sI	Sort by Name (case ignored)
"	  Sort the entries alphabetically by name, ignoring case
"	  Example :
"	    a.c < B.c
"	sN	Sort by Name (numerically)
"	  Sort the entries numerically by name
"	  Example :
"	    2.c  < 10.c
"	    a2.c < a10.c
"	se	Sort by Extension
"	  Sort the entries alphabetically by extension
"	  Example :
"	    a.c < a.y
"	sL	Sort by Length of Basename
"	  Sort by the length of the name
"	  Example :
"	    ab < aaa
"	sd	Sort by Dev
"	  Sort by device number
"	si	Sort by Ino
"	  Sort by inode number
"	sM	Sort by Mode
"	  Sort by mode, numerically
"	sl	Sort by Nlink
"	  Sort by number of links
"	su	Sort by Uid
"	  Sort by UID (User id), numerically
"	sg	Sort by Gid
"	  Sort by GID (Group id), numerically
"	sr	Sort by Rdev
"	  Sort by Rdev, numerically
"	ss	Sort by Size
"	  Sort by Filesize
"	sa	Sort by Atime
"	  Sort by Atime
"	sm	Sort by Mtime
"	  Sort by Mtime
"	sc	Sort by Ctime
"	  Sort by Ctime
"	sB	Sort by Blksize
"	  Sort by Blocksize
"	sb	Sort by Blocks
"	  Sort by nr. of blocks
"	sx	Sort by X-Info
"	  Sort by result of xPerFileCommand
"	S>	Sort order is descending
"	  Sort in descending order.
"	S<	Sort order is ascending
"	  Sort in ascending order.
"	S/	Separate dirs
"	  Directories are put at the beginning of the list, regardless of sorting
"	S#	Don't Separate dirs
"	  Directories and normal files are intermixed, due to sorting
"	Sx	Separate tagged
"	  Tagged files are put at the beginning of the list, regardless of sorting
"	SX	Don't Separate tagged
"	  Tagged files and untagged files are intermixed, due to sorting
"	Sf	Fix the settings for this dir
"	  The current sort-settings are fixed for this directory.
"	  The fix can be released by applying a new sort-order in this directory.
"	i	Inspect the file
"	  Open the inspect window and show a lot of useful information about the file under the cursor.
"	  The inspect window has the name /strux/INSPECT and additional commands are available there.
"	o	Open the file in a split
"	  Edit the file under the cursor in a new window
"	O	Open the file in a new tab
"	  Edit the file under the cursor in a new tab
"	p	Preview the file
"	  Edit the file under the cursor in the preview window
"	xx	Tag the file
"	  Tag (mark) the file under the cursor.
"	xX	Untag the file
"	  Untag (unmark) the file under the cursor.
"	xa	Tag all
"	  Tag (mark) all files
"	xA	Untag all
"	  Untag (unmark) all files
"	xT	Toggle tags
"	  Toggle all tags.
"	      Untagged files become tagged, and
"	      Tagged files become untagged
"	xt	Toggle this
"	  Toggle the tag for this file
"	xp	Tag by Pattern
"	  Prompt for a regexp and tags all files matching this regexp.
"	  The regexp has to be a perl-like regexp, not one you know from ls.
"
"	  E.g to tag all c-files that start with the letter a, use:
"	  ^a.*\.c$
"	xP	Untag by Pattern
"	  Prompt for a regexp and untags all files matching this regexp.
"	  The same rules as for xp apply here
"	xf	Tag by file
"	  Prompts for the filename of a namesfile. This file should contain the names of files, each in its own line.
"	  Other than xp and xP, these names are not regexpes but literal names.
"	  It may be the result of:
"	  grep -l something *
"	  All files, that occur in the namesfile are tagged.
"
"	  See also :
"	      xF
"	xF	Untag by file
"	  Prompts for the filename of a namesfile. This file should contain the names of files, each in its own line.
"	  Other than xp and xP, these names are not regexpes but literal names.
"	  It may be the result of:
"	  grep -l something *
"	  All files, that occur in the namesfile are untagged.
"
"	  See also :
"	      xf
"	xg	Tag by grep
"	  Prompts for grep-cmd and tags all files matched.
"
"	  Example :
"	    key *.c *.h
"	      tags all your c and h-files that contain the string key
"	    -i key *.c *.h
"	      make above search case-insensitive
"
"	  Don't be confused by messages like
"	  grep: xyz: is a directory.
"	  Just press <C-L> to get rid of them.
"	  Also see |g:strux_LL_grep|.
"	xG	Untag by grep
"	  Prompts for grep-cmd and untags all files matched.
"	  For details see xg above
"	x<F4>	Execute a command to tagged files
"	  Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment
"	x1<F4>	Execute a command to tagged files in an xterm
"	  Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment
"	x2<F4>	Execute a command to tagged files in an background xterm
"	  Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment
"	x<S-F4>	Execute a command to tagged files and read output into a new buffer
"	  Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment
"	<c-x><c-x>	In the shell issue a cd and focus the shell
"	<c-x>c	LL for the dir in the shell
"	<c-x>s	open a shell
"	<BS>	Go to the previously visited dir
"	<tab>	Go to the next visited dir
"	..	Go to parent dir
"	  Enter parent directory of the currently viewed directory
"	./	Go to root dir
"	  Enter the root-directory /
"	.~	Go to home dir
"	  Enter the home-directory ($HOME)
"	.:	Go to any dir
"	  Prompts for a directory and enters this directory
"	  filename-completen works here
"	ff	Follow the link under the cursor
"	  Example : you have the view at dir /usr/bin
"	    the file rcp is in fact a link to /etc/alternatives/rcp
"	    LL show this as "rcp -> /etc/alternatives/rcp"
"	    if you press ff with the cursor on this line the view is changed to /etc/alternatives
"	    and the cursor is positioned on rcp
"	    here you may see "rcp -> /usr/bin/scp"
"	    pressing ff here brings you to /usr/bin with the cursor on the line for scp
"	  Same for a file that has a / in its name
"	    e.G. if you do "find . whatever | L"
"	  This also follows .git - files to the gitdir
"	<C-R>	Refresh the current view
"	  Refresh the current view.
"	  stat - information are updated and the !-flags are reset
"	  The sorting of the listing is repeated.
"	  The timestamp in the header-line is adjusted.
"	  See also :
"	      u
"	      U
"	u	Update the current view
"	  Update the current view.
"	  stat - information of files allready in the listing are not updated.
"	  Such changes are flagged in the ! - column (see cpg rsp. cpl below)
"	  The timestamp of the header-line as well as 
"	  the sorting of the listing remains unchanged.
"	  Possible flags are:
"	      n	file is new since last refresh
"	      c	file has changed since last refresh
"	      d	file is deleted since last refresh
"	      <blank>	file is unmodified since last refresh
"	  See also :
"	      U
"	      <C-R>
"	U	Update the current view (keep deleted)
"	  Refresh the current view.
"	  stat - information are updated and the !-flags are reset
"	  This command works much like <C-R> except that
"	  deleted files stay in the listing (marked with d)
"	  The sorting of the listing is repeated.
"	  The timestamp in the header-line is adjusted.
"	  See also :
"	      u
"	      <C-R>
"	.?	View the list of visited dirs
"	  Display a list of all visited directories in a separate window.
"	  This window has the name /strux/VISITED and additional commands are available there.
"	    press <F1> in this window to get help on these mappings
"	.!	View the back/forward stack
"	  Display the stack used for <BS> and <TAB>
"	  This window has the name /strux/DIRSTACK and additional commands are available there.
"	    press <F1> in this window to get help on these mappings
"	notes for per entry command
"	  If the first two characters are "P " then the rest is passed to (build-in) perl.
"	    The filename is not automatically appended in this case.
"	    The perl-code is executed in the namespace XPE (for x-per-entry).
"	  Else the command is executed as a shell command.
"	    The complete path to the file is appended (properly quoted) to the command.
"	    both stderr and stdout are displayed.
"	  The following vars are set for the command:
"	      $F	filename (as shown by LL)			morepath/file.ext
"	      $d	base-directory (as shown in the header-line)	/path/to/
"	      $f	filename with path				/path/to/morepath/file.ext
"	      $p	path to file					/path/to/morepath
"	notes for per file command
"	  The command is applied to each file if the "Parse String" (see cpg rsp. cpl) contains %x.
"	  The command output is put at the position indicated by %x.
"	  It is not applied to directories. See cxdl rsp. cxdg for this.
"	cxfg	Configure the Global Per File Command
"	  It is not applied to directories. See cxdg for this.
"	  The local Per File command (as set with cxfl) can override the global Per File command.
"	  Example :
"	    file -b
"	    grep -s something
"	    head -q -n 1
"	    wc
"
"	    cvs log  -N -rHEAD $F|perl -ne '/date://.../^==/ and print'|perl -ne '$.==2 and print' #
"	    cvs status $F 2>/dev/null|perl -ne 'if ($.==2) {s//.*Status: //;print;}' #
"	      In the above examples $F is used in the command. LL still appends the full pathname to the command.
"	      Therefore the final # is present to turn this into a comment.
"	    P open F,$F and do { chomp(my $s=<F>);close F;return $s}
"	      the above example is equivalent to "head -q -n 1" but much faster, since no external program needs to be startet.
"
"	  If you set it to empty then the default entry (file -b) will be used.
"	  You can set the default entry in your .vimrc with
"	    let g:strux_LL_perFileCommand='new command' (see |g:strux_LL_perFileCommand|)
"	  See also :
"	    cxdg
"	    cxfl
"	    cxdl
"	cxfl	Configure the Local Per File Command
"	  It is not applied to directories. See cxdl for this.
"	  It overrides a global Per File command (as set with cxfg).
"	  Example :
"	    cat 2>/dev/null
"	      the above exapmple is usefull e.G in /proc/sys or /proc/ide
"	    whatis -s1 "$F" | sed -e 's/.*- //' #
"	      the above exapmple is usefull e.G in /bin or /usr/bin
"	    P open F,$F and do { chomp(my $s=<F>);close F;return $s}
"	      the above command is equivalent to "cat 2>/dev/null".
"
"	  If you set it to empty then the gloal entry will be used.
"	  See also :
"	    cxdg
"	    cxfg
"	    cxdl
"	    dirsettings
"	notes for per dir command
"	  The command is applied to each directory if the "Parse String" (see cpg rsp. cpl) contains %x.
"	  Its output is put at the position indicated by %x.
"	  It is not applied to normal files. See cxfl rsp. cxfg for this.
"	cxdg	Configure the Global Per Dir Command
"	  The local Per Dir command (as set with cxdl) can override the global Per Dir command.
"	  Example :
"	    du -sh "$F" | awk '{ print $1 }' # 
"	    ls -1 "$F"| wc -l #
"	      In the above examples $F is used in the command. LL still appends the full pathname to the command.
"	      Therefore the final # is present to turn this into a comment.
"
"	    P my $s;opendir DH,$F and do { $s=@{[readdir DH]} ; close DH }; return $s
"	      the above example is equivalent to "ls -1 "$F"| wc -l #"  but much faster, since no external program needs to be startet.
"
"	  If you set it to empty then the default entry (# for no command) will be used.
"	  You can set the default entry in your .vimrc with
"	    let g:strux_LL_perDirCommand='new command' (see |g:strux_LL_perDirCommand|)
"	  See also :
"	    cxfg
"	    cxfl
"	    cxdl
"	cxdl	Configure the Local Per Dir Command
"	  It overrides a global Per Dir command (as set with cxfg).
"	  Example :
"	    [ -e $F/status  ] && { read pid name status rest < $F/stat;echo -en "$status\t" ; perl -ne 's//.*\t//;chop;print "$_\t";exit' $F/status ; tr '\0' ' ' <$F/cmdline ; } #
"	      the above exapmple is usefull e.G in /proc/sys or /proc/ide
"	    P return if $F !~ /\d+/  ;my $s;open F,"$F/stat" and do { $s .= (split(/\s+/,<F>))[2]." ";close F };open F,"$F/status" and do { $s .= (split(/\t+|\n/,<F>))[1]."\t";close F };open F,"$F/cmdline" and do { my $x = <F>;$x =~ s/\0/ /g;$s.=$x;close F };$s
"	      the above command is equivalent to the shell-command above.
"
"	  If you set it to empty then the gloal entry will be used.
"	  See also :
"	    cxdg
"	    cxfg
"	    cxdl
"	    dirsettings
"	notes for Parse String
"	  The format-string defines how to display the dir-entries.
"	  It consists of printf style '%' items interspersed with normal text.
"	  The formats:
"	      %	A single "%" - Character
"	      T	A single tab
"	      t	denotes tagged lines
"	      n	filename
"	      /	filename, with "/" appended, if file is a directory, symlinks are indicated by ->
"	      i	inode number
"	      F	mode flags as octal number
"	      f	mode flags in drwxrwxrwx - notation
"	      u	user id (numerically)
"	      U	user id (text)
"	      g	group id (numerically)
"	      G	group id (text)
"	      s	file size
"	      a	atime (in readable form)
"	      c	ctime (in readable form)
"	      m	mtime (in readable form)
"	      d	device number
"	      l	number of links
"	      r	rdev
"	      b	blocksize
"	      S	number of blocks
"	      A	atime (numerically)
"	      C	ctime (numerically)
"	      M	mtime (numerically)
"	      !	modification flags
"	      x	result of per file command, as defined by cxfl or cxfg
"	  Any sequence of tabs will be shortened/prolonged to make all tab-seperated columns aligned.
"	cpg	Configure the global Parse String
"	  Set the parsestring
"	  If you enter an empty format-string, it is reset to the default.
"	  The format-string defaults to : %t%f %!^I%l^I%U^I%G^I%m^I%s^I%/
"	  This can be overwritten by setting |g:strux_LL_parsestring|
"	  See also :
"	      cpl
"	cpl	Configure the local Parse String
"	  Set the parse-string for this directory
"	  If you enter an empty format-string, it is reset to the global parse string (as set with cpg).
"	  See also :
"	      cpg
"	      dirsettings
"	cpr	Reread the LL-autocommands
"	  Rereads the file ~/LL.dirsettings which holds the NewView Autocommands
"	cpc	Clear the dirsettings for the current dir
"	  clears the dirsettings for the displayed directory
"	dt	Show technical info for this dir
"	  this is intended for debugging reasons
"	v-mappings for buffer /strux/LL
"	xx	Tag selected files
"	  Tag (mark) the selected files
"	xX	Untag selected files
"	  Untag (unmark) the selected files
"	xt	Toggle selected files
"	  Toggle the tag for the selected files
"	n-mappings for buffer frequentCommands
"	<F4>	Execute this command (old style)
"	  Execute the line under the cursor in your shell
"	  The command is executed as typed
"	  It is NOT subject to vim's treating of some chars as % and #
"	  The following vars are set for the command:
"	      $f	filename with path		/path/to/file/name.ext
"	      $p	path				/path/to/file
"	      $F	filename as given		name.ext
"	      $r	filename without extension	name
"	      $e	extension			ext
"	  See |g:strux_LL_shell| for configuring this command.
"	5<F4>	Execute this command
"	  Execute the line under the cursor in your shell
"	  The command is executed as typed
"	  It is NOT subject to vim's treating of some chars as % and #
"	  The following vars are set for the command:
"	      $f	filename with path		/path/to/file/name.ext
"	      $p	path				/path/to/file
"	      $F	filename as given		name.ext
"	      $r	filename without extension	name
"	      $e	extension			ext
"	  See |g:strux_LL_shell| for configuring this command.
"	1<F4>	Execute this command in an xterm
"	  same as <F4>, but the command is executed in an xterm.
"	  This is usefull if you use gvim (as opposed to (term-)vim), where interactive programs don't work too well.
"	  See |g:strux_LL_xterm| for configuring the xterm.
"	2<F4>	Execute this command in an background xterm
"	  same as <F4>, but the command is executed in an xterm, which again is put into background.
"	  You can continune using vim, even if the command is not yet finished.
"	  This is usefull if
"	      you use gvim (as opposed to (term-)vim), where interactive programs don't work too well.
"	      you want to execute a longrunning program in the background (even in (term-)vim)
"	  See |g:strux_LL_xterm| for configuring the xterm.
"	<S-F4>	Execute this command and read output into a new buffer
"	  same as <S-F4>, but the output is read into a new buffer
"	1<S-F4>	Execute this command and read output
"	  same as <F4>, but the output is read into the frequentCommands buffer.
"	  The read output is also visually selected.
"	    This is useful to have things like > (shift in) work out of the box
"	    Press <ESC> to get rid of the visual selection
"	<F3>	LL file under cursor, remain in command-window
"	  This command may fail, if the name under the cursor contains spaces
"	1<F3>	LL file under cursor
"	  This command may fail, if the name under the cursor contains spaces
"	2<F3>	LL file under cursor (whole line), remain in command-window
"	  Take the whole line as filename, but skip leading whitespaces
"	  This is especially useful if the path/filename contains spaces
"	  or other strange characters.
"	3<F3>	LL file under cursor (whole line)
"	  Take the whole line as filename, but skip leading whitespaces
"	  This is especially useful if the path/filename contains spaces
"	  or other strange characters.
"	n-mappings for buffer /strux/INSPECT
"	<2-leftmouse>	Inspect harder
"	<CR>	Inspect harder
"	  On some lines in the inspect-window, you can get more information with this command
"	  Notably on the following fields:
"	      name		If the file is a symbolic link show the complete link-chain
"	      dev		show the disk-free info for the filesystem this file belongs to
"	      magic		show more hits of "file", if available
"	      process-line	start pst and position the cursor on the appropriate entry
"	        see |pstree| for details of this view
"	n-mappings for buffer /strux/ACMD
"	i	Show the command
"	  show the associated command
"	<CR>	Do the command
"	  execute the selected command
"	n-mappings for buffer /strux/DIRSTACK
"	<2-leftmouse>	Select the dir
"	  Jump to selected dir
"	<CR>	Select the dir
"	  Jump to selected dir
"	s	Show the dir
"	  Show to selected dir, but stay in the Dirstack-View
"	n-mappings for buffer /strux/VISITED
"	<2-leftmouse>	Select the dir
"	  Jump to selected dir
"	<CR>	Select the dir
"	  Jump to selected dir
"	s	Show the dir
"	  Show to selected dir, but stay in the Visited-View
"	dd	Forget this dir
"	  The view under the cursor is put into oblivion.
"	  It may still be present in the DIRSTACK (for Back (Backspace) and Forward (Tab).
"	  If the corresponding view is open right now, it will be remembered until the dir is left.
"	v-mappings for buffer /strux/VISITED
"	dd	Forget selected views
"	  The selected views are put into oblivion.
"	  Some of them may still be present in the DIRSTACK (for Back (Backspace) and Forward (Tab)).
"	  If one of the corresponding view is open right now, it will be remembered until the dir is left.
"
"	Configuration variables
"	  The following vars can be set in your .vimrc or in your environment.
"	  Settings in the environment have the highest precedence.
"
"	g:strux_LL_shell : the shell to be used	(defaults to "bash -l")
"	  (can be superseded with the environment-var $strux_LL_shell)
"		  The value of this var is used for:
"		      <F4>  and its variants in view frequentCommands.
"		      <F4>  and its variants in view LL.
"		      d<F4> and its variants in view LL.
"		      x<F4> and its variants in view LL.
"		      dd and d? and d.       in view LL.
"	g:strux_LL_xterm : the xterm to be used	(defaults to "xterm -e")
"	  (can be superseded with the environment-var $strux_LL_xterm)
"		  The value of this var is used for
"		      1<F4>     2<F4>        in frequentCommands.
"		      1<F4>     2<F4>        in view LL.
"		      d1<F4>    d2<F4>       in view LL.
"		      x1<F4>    x2<F4>       in view LL.
"		      d.                     in view LL.
"	g:strux_LL_parsestring : configure how the output of LL looks like.	(defaults to "%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/")
"	  (can be superseded with the environment-var $strux_LL_parsestring)
"		  The formats:
"		      %			A single "%" - Character
"		      T			A single tab
"		      t			denotes tagged lines
"		      n			filename
"		      /			filename, with "/" appended, if file is a directory
"		      i			inode number
"		      F			mode flags as octal number
"		      f			mode flags in drwxrwxrwx - notation
"		      u			user id (numerically)
"		      U			user id (text)
"		      g			group id (numerically)
"		      G			group id (text)
"		      s			file size
"		      a			atime (in readable form)
"		      c			ctime (in readable form)
"		      m			mtime (in readable form)
"		      d			device number
"		      l			number of links
"		      r			rdev
"		      b			blocksize
"		      S			number of blocks
"		      A			atime (numerically)
"		      C			ctime (numerically)
"		      M			mtime (numerically)
"		      !			modification flags
"		      x			result of per file command, as defined by cx
"		  Note to Windows-Users:
"		    %l %U %G give not really useful information on windows-systems
"		    you may wish to set it to "%t%f %!%T%m%T%s%T%/"
"	g:strux_LL_perFileCommand : per file command	(defaults to "file -b")
"	  (can be superseded with the environment-var $strux_LL_perFileCommand)
"		  The value of this var is used as the command to be executed for each
"		  file (not directory) if parsestring contains %x
"	g:strux_LL_perDirCommand : per directory command	(defaults to "#")
"	  (can be superseded with the environment-var $strux_LL_perDirCommand)
"		  The value of this var is used as the command to be executed for each
"		  directory if parsestring contains %x
"	g:strux_LL_perFileOrDirText : description for per file/dir command	(defaults to "magic")
"	  (can be superseded with the environment-var $strux_LL_perFileOrDirText)
"		  The value of this var is used as the string to be output for the
"		  descriptive header.
"	g:strux_LL_dirsettings : locations for LL.dirsettings	(defaults to "~/LL.dirsettings,~/strux/etc/LL.dirsettings")
"	  (can be superseded with the environment-var $strux_LL_dirsettings)
"		  The value of this var defines the locations for the dirsettings-file.
"		  This is a comma-separeted list of files.
"		  All files are read in the given order.
"		  For details about this file see |LL-dirsettings|
"	g:strux_LL_header : configure the header	(defaults to "%d%T%g%T%t%T%n Entries%T%s")
"	  (can be superseded with the environment-var $strux_LL_header)
"		  The value of this var is used to configure how the header line lookes like
"		  The formats:
"		      %			A single "%" - Character
"		      T			A single tab
"		      d			the directory
"		      t			the time, where the information was gathered
"		      n			the number of entries
"		      s			the sorting method
"		      g			the git status, text is "[branch]" or empty
"	g:strux_LL_grep : command for xg	(defaults to "grep -l")
"	  (can be superseded with the environment-var $strux_LL_grep)
"		  The value of this var defines the start of the command for xg.
"		  on unix, "grep -l" is a good choice
"		  It may be overwritten by the user, but the behaviour of grep is used
"		  to determine whether the command succeeded.
"	  
"		  from the grep manpage (at least on my system)
"		    DIAGNOSTICS
"		      Normally, exit status is 0 if matches were found, and 1 if
"		      no matches were found.  (The -v option inverts  the  sense
"		      of  the exit status.)  Exit status is 2 if there were syn
"		      tax errors in the pattern, inaccessible input  files,  or
"		      other system errors.
"	  
"		  Note: even if the command may not return 0, some files may get tagged.
"		    Eg. if you use xg with "re *" as reply to "Grepcmd : ", in which case
"		    all files are searched, but some of them may be directories, which force
"		    grep to return something not equal to zero.
"	g:strux_LL_editcmd : command for <CR>	(defaults to "edit")
"	  (can be superseded with the environment-var $strux_LL_editcmd)
"		  The value of this var defines how a file is to be opened when pressing <CR>
"		  on a filename or double clicking it.
"		  Directories are always entered in the LL-view.
"		  The default "edit" means : edit the file in the same window in which the directory is shown.
"		  You may wish to set it to one of >
"		    split
"		    vsplit
"		    rightbelow split
"		    leftabove split
"		    rightbelow vsplit
"		    leftabove vsplit
"	  
"		  < Many users might find the combination with |:only| useful. As in: >
"		      only|rightbelow vnew|wincmd p|30wincmd \||wincmd p|edit
"		  < Together with a parsestring consisting of only "%/" this gives a nice
"		    little hot-dir listing. (See |LL-cpg|)
"	  
"		    For more information see |:split|,|:vsplit|,|:rightbelow|,|:leftabove| and |:only|
"	g:strux_LL_dateFormat : strftime - format for printing dates	(defaults to "%Y-%m-%d %H:%M:%S")
"	  (can be superseded with the environment-var $strux_LL_dateFormat)
"		  The value of this var defines the format for printing timestamps.
"		  See the manual page of the C function strftime() for the format.
"		  Some settings to try: >
"		    %y-%m-%d %H:%M:%S
"		    %d.%m.%y %H:%M:%S
"		    %d.%m.%Y %H:%M:%S
"		  <
"
"---------------------------------------------
function <sid>Help_n2f73747275782f4c4c_6e65772066696c656e616d65()
echo '   prompts for a new name for the file or dir under the cursor.'
echo '   The usual filename-completion works on the input-line.'
echo '   The new file name is preset with the current-name for easy editing.'
echo '   Type ctrl-u to clear the line and type a completely new path/name'
echo '   '
echo '   A check is performed whether the new file already exists.'
echo '     In this case you are asked for confirmation.'
echo '     Reply with y or Y if you really want the action.'
echo '   Cancel the action with Escape or Ctrl-C'
endfunction
function <sid>Help_n2f73747275782f4c4c_1()
  echohl WarningMsg
  echo 'Edit the file (bound to <2-leftmouse>)'
  echohl None
  echo ''
  echo 'Double-click is the same as <CR>'
endfunction
function <sid>Help_n2f73747275782f4c4c_2()
  echohl WarningMsg
  echo 'Edit the file (bound to <CR>)'
  echohl None
  echo ''
  echo 'Edit the file under the cursor in the same vim.'
  echo 'Come back to the directory-view with :LL'
  echo 'If the cursor is on the header-line toggle it between normal/descriptive'
  echo 'Also see |g:strux_LL_editcmd|.'
endfunction
function <sid>Help_n2f73747275782f4c4c_3()
  echohl WarningMsg
  echo 'Rename the file under the cursor (bound to fr)'
  echohl None
  echo ''
  echo 'Renaming is tried in two steps.'
  echo '  First it is tried with the build-in rename().'
  echo '  If this fails (e.G if the rename is cross-device), a call to mv is issued.'
endfunction
function <sid>Help_n2f73747275782f4c4c_4()
  echohl WarningMsg
  echo 'Copy the file under the cursor (bound to fc)'
  echohl None
  echo ''
  echo 'A check is performed whether the source is a directory'
  echo '  In this case you are asked for confirmation to recurse.'
  echo '  Reply with y or Y if you really want a recursive copy'
endfunction
function <sid>Help_n2f73747275782f4c4c_5()
  echohl WarningMsg
  echo 'Delete the file under the cursor (bound to fd)'
  echohl None
  echo ''
  echo 'prompts for confirmation'
  echo '  Reply with y or Y if you really want the action.'
  echo 'Checks whether the file is a directory and whether it is not empty'
  echo '  In this case you are again asked for confirmation.'
  echo '  Reply with y or Y if you really want a recursive delete'
  echo 'Cancel the action with Escape or Ctrl-C'
endfunction
function <sid>Help_n2f73747275782f4c4c_6()
  echohl WarningMsg
  echo 'Put the filename into the clipboard (bound to f+)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_7()
  echohl WarningMsg
  echo 'Put the filename into primary (bound to f*)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_8()
  echohl WarningMsg
  echo 'Put the filename into vim''s unnamed register (") (bound to f")'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_9()
  echohl WarningMsg
  echo 'Put the filename with path into the clipboard (bound to fp+)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_10()
  echohl WarningMsg
  echo 'Put the filename with path into primary (bound to fp*)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_11()
  echohl WarningMsg
  echo 'Put the filename with path into vim''s unnamed register (") (bound to fp")'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()
  echo 'At the prompt enter a shell-command.'
  echo 'the full-filename is appended to the command (as "$f") if the command does not already contain $'
  echo 'The command is NOT subject to vim''s treating of some chars as % and #'
  echo ''
  echo 'See |g:strux_LL_shell| for configuring how the command is started.'
  echo ''
  echo 'The following vars are set for the command:'
  echo '    $f	filename with path		/path/to/file/name.ext'
  echo '    $p	path				/path/to/file'
  echo '    $F	filename as given		name.ext'
  echo '    $r	filename without extension	name'
  echo '    $e	extension			ext'
  echo 'Cancel the action with Escape or Ctrl-C'
endfunction
function <sid>Help_n2f73747275782f4c4c_12()
  echohl WarningMsg
  echo 'View (bound to dv)'
  echohl None
  echo ''
  echo 'View the file according to the mailcap file'
endfunction
function <sid>Help_n2f73747275782f4c4c_13()
  echohl WarningMsg
  echo 'Edit (bound to de)'
  echohl None
  echo ''
  echo 'Edit the file according to the mailcap file'
endfunction
function <sid>Help_n2f73747275782f4c4c_14()
  echohl WarningMsg
  echo 'Compose (bound to dc)'
  echohl None
  echo ''
  echo 'Compose (create) the file according to the mailcap file'
endfunction
function <sid>Help_n2f73747275782f4c4c_15()
  echohl WarningMsg
  echo 'Print (bound to dp)'
  echohl None
  echo ''
  echo 'Print the file according to the mailcap file'
endfunction
function <sid>Help_n2f73747275782f4c4c_16()
  echohl WarningMsg
  echo 'Execute a command (bound to d<F4>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_17()
  echohl WarningMsg
  echo 'Execute a command in an xterm (bound to d1<F4>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_18()
  echohl WarningMsg
  echo 'Execute a command in an background xterm (bound to d2<F4>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_19()
  echohl WarningMsg
  echo 'Execute a command and read output into a new buffer (bound to d<S-F4>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_20()
  echohl WarningMsg
  echo 'Repeat last command (bound to d.)'
  echohl None
  echo ''
  echo 'Repeats the last command, this time with the file that is now selected.'
  echo 'Whether the output is displayed or ignored is remembered from the last command.'
  echo 'An error-message is issued if there is no last command.'
endfunction
function <sid>Help_n2f73747275782f4c4c_21()
  echohl WarningMsg
  echo 'Open the command window (bound to cc)'
  echohl None
  echo ''
  echo 'Opens the command-vindow (holds the file ~/frequentCommands)'
  echo 'The current working directory for the commands executed in this window is what LL just shows.'
  echo ''
  echo 'You can invoke it with <count>cc (as in 3cc) to make the window <count> lines high.'
  echo ''
  echo 'Special mappings are available in this window.'
  echo '  press <F1> in this window to get help on these mappings'
endfunction
function <sid>Help_n2f73747275782f4c4c_22()
  echohl WarningMsg
  echo 'Execute this command (bound to <F4>)'
  echohl None
  echo ''
  echo 'This command is basically the same as'
  echo '  ,cc	open the command window'
  echo '  <F4>	execute the command where the cursor is on'
  echo '  LL	reenter the LL-window'
endfunction
function <sid>Help_n2f73747275782f4c4c_23()
  echohl WarningMsg
  echo 'Execute this command (old style) (bound to 5<F4>)'
  echohl None
  echo ''
  echo 'This command is basically the same as'
  echo '  ,cc	open the command window'
  echo '  <F4>	execute the command where the cursor is on'
  echo '  LL	reenter the LL-window'
endfunction
function <sid>Help_n2f73747275782f4c4c_24()
  echohl WarningMsg
  echo 'Execute this command in an xterm (bound to 1<F4>)'
  echohl None
  echo ''
  echo 'This command is basically the same as'
  echo '  ,cc	open the command window'
  echo '  1<F4>	execute the command where the cursor is on in an xterm'
  echo '  LL	reenter the LL-window'
endfunction
function <sid>Help_n2f73747275782f4c4c_25()
  echohl WarningMsg
  echo 'Execute this command in an background xterm (bound to 2<F4>)'
  echohl None
  echo ''
  echo 'This command is basically the same as'
  echo '  ,cc	open the command window'
  echo '  2<F4>	execute the command where the cursor is on in an background xterm'
  echo '  LL	reenter the LL-window'
endfunction
function <sid>Help_n2f73747275782f4c4c_26()
  echohl WarningMsg
  echo 'Execute this command.Read Output into a &new buffer (bound to <S-F4>)'
  echohl None
  echo ''
  echo 'This command is basically the same as'
  echo '  ,cc	open the command window'
  echo '  <S-F4>	execute the command where the cursor is and read output into a new buffer'
  echo '  LL	reenter the LL-window'
endfunction
function <sid>Help_n2f73747275782f4c4c_27()
  echohl WarningMsg
  echo 'Execute acmd for current file (bound to dd)'
  echohl None
  echo ''
  echo 'execute acmd for current file'
endfunction
function <sid>Help_n2f73747275782f4c4c_28()
  echohl WarningMsg
  echo 'Open acmd-menu for current file (bound to d?)'
  echohl None
  echo ''
  echo 'show all possible acmd commands for current file'
  echo 'Special mappings are available in this window.'
  echo '  press <F1> in this window to get help on these mappings'
endfunction
function <sid>Help_n2f73747275782f4c4c_29()
  echohl WarningMsg
  echo 'Reread the acmd-database (bound to dr)'
  echohl None
  echo ''
  echo 'reread the acmd database'
endfunction
function <sid>Help_n2f73747275782f4c4c_30()
  echohl WarningMsg
  echo 'Sort by Name (bound to sn)'
  echohl None
  echo ''
  echo 'Sort the entries alphabetically by name, obeying case'
  echo 'Example :'
  echo '  A.c < a.c'
endfunction
function <sid>Help_n2f73747275782f4c4c_31()
  echohl WarningMsg
  echo 'Sort by Name (case ignored) (bound to sI)'
  echohl None
  echo ''
  echo 'Sort the entries alphabetically by name, ignoring case'
  echo 'Example :'
  echo '  a.c < B.c'
endfunction
function <sid>Help_n2f73747275782f4c4c_32()
  echohl WarningMsg
  echo 'Sort by Name (numerically) (bound to sN)'
  echohl None
  echo ''
  echo 'Sort the entries numerically by name'
  echo 'Example :'
  echo '  2.c  < 10.c'
  echo '  a2.c < a10.c'
endfunction
function <sid>Help_n2f73747275782f4c4c_33()
  echohl WarningMsg
  echo 'Sort by Extension (bound to se)'
  echohl None
  echo ''
  echo 'Sort the entries alphabetically by extension'
  echo 'Example :'
  echo '  a.c < a.y'
endfunction
function <sid>Help_n2f73747275782f4c4c_34()
  echohl WarningMsg
  echo 'Sort by Length of Basename (bound to sL)'
  echohl None
  echo ''
  echo 'Sort by the length of the name'
  echo 'Example :'
  echo '  ab < aaa'
endfunction
function <sid>Help_n2f73747275782f4c4c_35()
  echohl WarningMsg
  echo 'Sort by Dev (bound to sd)'
  echohl None
  echo ''
  echo 'Sort by device number'
endfunction
function <sid>Help_n2f73747275782f4c4c_36()
  echohl WarningMsg
  echo 'Sort by Ino (bound to si)'
  echohl None
  echo ''
  echo 'Sort by inode number'
endfunction
function <sid>Help_n2f73747275782f4c4c_37()
  echohl WarningMsg
  echo 'Sort by Mode (bound to sM)'
  echohl None
  echo ''
  echo 'Sort by mode, numerically'
endfunction
function <sid>Help_n2f73747275782f4c4c_38()
  echohl WarningMsg
  echo 'Sort by Nlink (bound to sl)'
  echohl None
  echo ''
  echo 'Sort by number of links'
endfunction
function <sid>Help_n2f73747275782f4c4c_39()
  echohl WarningMsg
  echo 'Sort by Uid (bound to su)'
  echohl None
  echo ''
  echo 'Sort by UID (User id), numerically'
endfunction
function <sid>Help_n2f73747275782f4c4c_40()
  echohl WarningMsg
  echo 'Sort by Gid (bound to sg)'
  echohl None
  echo ''
  echo 'Sort by GID (Group id), numerically'
endfunction
function <sid>Help_n2f73747275782f4c4c_41()
  echohl WarningMsg
  echo 'Sort by Rdev (bound to sr)'
  echohl None
  echo ''
  echo 'Sort by Rdev, numerically'
endfunction
function <sid>Help_n2f73747275782f4c4c_42()
  echohl WarningMsg
  echo 'Sort by Size (bound to ss)'
  echohl None
  echo ''
  echo 'Sort by Filesize'
endfunction
function <sid>Help_n2f73747275782f4c4c_43()
  echohl WarningMsg
  echo 'Sort by Atime (bound to sa)'
  echohl None
  echo ''
  echo 'Sort by Atime'
endfunction
function <sid>Help_n2f73747275782f4c4c_44()
  echohl WarningMsg
  echo 'Sort by Mtime (bound to sm)'
  echohl None
  echo ''
  echo 'Sort by Mtime'
endfunction
function <sid>Help_n2f73747275782f4c4c_45()
  echohl WarningMsg
  echo 'Sort by Ctime (bound to sc)'
  echohl None
  echo ''
  echo 'Sort by Ctime'
endfunction
function <sid>Help_n2f73747275782f4c4c_46()
  echohl WarningMsg
  echo 'Sort by Blksize (bound to sB)'
  echohl None
  echo ''
  echo 'Sort by Blocksize'
endfunction
function <sid>Help_n2f73747275782f4c4c_47()
  echohl WarningMsg
  echo 'Sort by Blocks (bound to sb)'
  echohl None
  echo ''
  echo 'Sort by nr. of blocks'
endfunction
function <sid>Help_n2f73747275782f4c4c_48()
  echohl WarningMsg
  echo 'Sort by X-Info (bound to sx)'
  echohl None
  echo ''
  echo 'Sort by result of xPerFileCommand'
endfunction
function <sid>Help_n2f73747275782f4c4c_49()
  echohl WarningMsg
  echo 'Sort order is descending (bound to S>)'
  echohl None
  echo ''
  echo 'Sort in descending order.'
endfunction
function <sid>Help_n2f73747275782f4c4c_50()
  echohl WarningMsg
  echo 'Sort order is ascending (bound to S<)'
  echohl None
  echo ''
  echo 'Sort in ascending order.'
endfunction
function <sid>Help_n2f73747275782f4c4c_51()
  echohl WarningMsg
  echo 'Separate dirs (bound to S/)'
  echohl None
  echo ''
  echo 'Directories are put at the beginning of the list, regardless of sorting'
endfunction
function <sid>Help_n2f73747275782f4c4c_52()
  echohl WarningMsg
  echo 'Don''t Separate dirs (bound to S#)'
  echohl None
  echo ''
  echo 'Directories and normal files are intermixed, due to sorting'
endfunction
function <sid>Help_n2f73747275782f4c4c_53()
  echohl WarningMsg
  echo 'Separate tagged (bound to Sx)'
  echohl None
  echo ''
  echo 'Tagged files are put at the beginning of the list, regardless of sorting'
endfunction
function <sid>Help_n2f73747275782f4c4c_54()
  echohl WarningMsg
  echo 'Don''t Separate tagged (bound to SX)'
  echohl None
  echo ''
  echo 'Tagged files and untagged files are intermixed, due to sorting'
endfunction
function <sid>Help_n2f73747275782f4c4c_55()
  echohl WarningMsg
  echo 'Fix the settings for this dir (bound to Sf)'
  echohl None
  echo ''
  echo 'The current sort-settings are fixed for this directory.'
  echo 'The fix can be released by applying a new sort-order in this directory.'
endfunction
function <sid>Help_n2f73747275782f4c4c_56()
  echohl WarningMsg
  echo 'Inspect the file (bound to i)'
  echohl None
  echo ''
  echo 'Open the inspect window and show a lot of useful information about the file under the cursor.'
  echo 'The inspect window has the name /strux/INSPECT and additional commands are available there.'
endfunction
function <sid>Help_n2f73747275782f4c4c_57()
  echohl WarningMsg
  echo 'Open the file in a split (bound to o)'
  echohl None
  echo ''
  echo 'Edit the file under the cursor in a new window'
endfunction
function <sid>Help_n2f73747275782f4c4c_58()
  echohl WarningMsg
  echo 'Open the file in a new tab (bound to O)'
  echohl None
  echo ''
  echo 'Edit the file under the cursor in a new tab'
endfunction
function <sid>Help_n2f73747275782f4c4c_59()
  echohl WarningMsg
  echo 'Preview the file (bound to p)'
  echohl None
  echo ''
  echo 'Edit the file under the cursor in the preview window'
endfunction
function <sid>Help_n2f73747275782f4c4c_60()
  echohl WarningMsg
  echo 'Tag the file (bound to xx)'
  echohl None
  echo ''
  echo 'Tag (mark) the file under the cursor.'
endfunction
function <sid>Help_n2f73747275782f4c4c_61()
  echohl WarningMsg
  echo 'Untag the file (bound to xX)'
  echohl None
  echo ''
  echo 'Untag (unmark) the file under the cursor.'
endfunction
function <sid>Help_n2f73747275782f4c4c_62()
  echohl WarningMsg
  echo 'Tag all (bound to xa)'
  echohl None
  echo ''
  echo 'Tag (mark) all files'
endfunction
function <sid>Help_n2f73747275782f4c4c_63()
  echohl WarningMsg
  echo 'Untag all (bound to xA)'
  echohl None
  echo ''
  echo 'Untag (unmark) all files'
endfunction
function <sid>Help_n2f73747275782f4c4c_64()
  echohl WarningMsg
  echo 'Toggle tags (bound to xT)'
  echohl None
  echo ''
  echo 'Toggle all tags.'
  echo '    Untagged files become tagged, and'
  echo '    Tagged files become untagged'
endfunction
function <sid>Help_n2f73747275782f4c4c_65()
  echohl WarningMsg
  echo 'Toggle this (bound to xt)'
  echohl None
  echo ''
  echo 'Toggle the tag for this file'
endfunction
function <sid>Help_n2f73747275782f4c4c_66()
  echohl WarningMsg
  echo 'Tag by Pattern (bound to xp)'
  echohl None
  echo ''
  echo 'Prompt for a regexp and tags all files matching this regexp.'
  echo 'The regexp has to be a perl-like regexp, not one you know from ls.'
  echo ''
  echo 'E.g to tag all c-files that start with the letter a, use:'
  echo '^a.*\.c$'
endfunction
function <sid>Help_n2f73747275782f4c4c_67()
  echohl WarningMsg
  echo 'Untag by Pattern (bound to xP)'
  echohl None
  echo ''
  echo 'Prompt for a regexp and untags all files matching this regexp.'
  echo 'The same rules as for xp apply here'
endfunction
function <sid>Help_n2f73747275782f4c4c_68()
  echohl WarningMsg
  echo 'Tag by file (bound to xf)'
  echohl None
  echo ''
  echo 'Prompts for the filename of a namesfile. This file should contain the names of files, each in its own line.'
  echo 'Other than xp and xP, these names are not regexpes but literal names.'
  echo 'It may be the result of:'
  echo 'grep -l something *'
  echo 'All files, that occur in the namesfile are tagged.'
  echo ''
  echo 'See also :'
  echo '    xF'
endfunction
function <sid>Help_n2f73747275782f4c4c_69()
  echohl WarningMsg
  echo 'Untag by file (bound to xF)'
  echohl None
  echo ''
  echo 'Prompts for the filename of a namesfile. This file should contain the names of files, each in its own line.'
  echo 'Other than xp and xP, these names are not regexpes but literal names.'
  echo 'It may be the result of:'
  echo 'grep -l something *'
  echo 'All files, that occur in the namesfile are untagged.'
  echo ''
  echo 'See also :'
  echo '    xf'
endfunction
function <sid>Help_n2f73747275782f4c4c_70()
  echohl WarningMsg
  echo 'Tag by grep (bound to xg)'
  echohl None
  echo ''
  echo 'Prompts for grep-cmd and tags all files matched.'
  echo ''
  echo 'Example :'
  echo '  key *.c *.h'
  echo '    tags all your c and h-files that contain the string key'
  echo '  -i key *.c *.h'
  echo '    make above search case-insensitive'
  echo '    '
  echo 'Don''t be confused by messages like'
  echo 'grep: xyz: is a directory.'
  echo 'Just press <C-L> to get rid of them.'
  echo 'Also see |g:strux_LL_grep|.'
endfunction
function <sid>Help_n2f73747275782f4c4c_71()
  echohl WarningMsg
  echo 'Untag by grep (bound to xG)'
  echohl None
  echo ''
  echo 'Prompts for grep-cmd and untags all files matched.'
  echo 'For details see xg above'
endfunction
function <sid>Help_n2f73747275782f4c4c_72()
  echohl WarningMsg
  echo 'Execute a command to tagged files (bound to x<F4>)'
  echohl None
  echo ''
  echo 'Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment'
endfunction
function <sid>Help_n2f73747275782f4c4c_73()
  echohl WarningMsg
  echo 'Execute a command to tagged files in an xterm (bound to x1<F4>)'
  echohl None
  echo ''
  echo 'Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment'
endfunction
function <sid>Help_n2f73747275782f4c4c_74()
  echohl WarningMsg
  echo 'Execute a command to tagged files in an background xterm (bound to x2<F4>)'
  echohl None
  echo ''
  echo 'Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment'
endfunction
function <sid>Help_n2f73747275782f4c4c_75()
  echohl WarningMsg
  echo 'Execute a command to tagged files and read output into a new buffer (bound to x<S-F4>)'
  echohl None
  echo ''
  echo 'Prompts for a shell-command and issues this command with the full filename appended. Use # as last character to turn this into a comment'
endfunction
function <sid>Help_n2f73747275782f4c4c_76()
  echohl WarningMsg
  echo 'In the shell issue a cd and focus the shell (bound to <c-x><c-x>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_77()
  echohl WarningMsg
  echo 'LL for the dir in the shell (bound to <c-x>c)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_78()
  echohl WarningMsg
  echo 'open a shell (bound to <c-x>s)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_79()
  echohl WarningMsg
  echo 'Go to the previously visited dir (bound to <BS>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_80()
  echohl WarningMsg
  echo 'Go to the next visited dir (bound to <tab>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f4c4c_81()
  echohl WarningMsg
  echo 'Go to parent dir (bound to ..)'
  echohl None
  echo ''
  echo 'Enter parent directory of the currently viewed directory'
endfunction
function <sid>Help_n2f73747275782f4c4c_82()
  echohl WarningMsg
  echo 'Go to root dir (bound to ./)'
  echohl None
  echo ''
  echo 'Enter the root-directory /'
endfunction
function <sid>Help_n2f73747275782f4c4c_83()
  echohl WarningMsg
  echo 'Go to home dir (bound to .~)'
  echohl None
  echo ''
  echo 'Enter the home-directory ($HOME)'
endfunction
function <sid>Help_n2f73747275782f4c4c_84()
  echohl WarningMsg
  echo 'Go to any dir (bound to .:)'
  echohl None
  echo ''
  echo 'Prompts for a directory and enters this directory'
  echo 'filename-completen works here'
endfunction
function <sid>Help_n2f73747275782f4c4c_85()
  echohl WarningMsg
  echo 'Follow the link under the cursor (bound to ff)'
  echohl None
  echo ''
  echo 'Example : you have the view at dir /usr/bin'
  echo '  the file rcp is in fact a link to /etc/alternatives/rcp'
  echo '  LL show this as "rcp -> /etc/alternatives/rcp"'
  echo '  if you press ff with the cursor on this line the view is changed to /etc/alternatives'
  echo '  and the cursor is positioned on rcp'
  echo '  here you may see "rcp -> /usr/bin/scp"'
  echo '  pressing ff here brings you to /usr/bin with the cursor on the line for scp'
  echo 'Same for a file that has a / in its name'
  echo '  e.G. if you do "find . whatever | L"'
  echo 'This also follows .git - files to the gitdir'
endfunction
function <sid>Help_n2f73747275782f4c4c_86()
  echohl WarningMsg
  echo 'Refresh the current view (bound to <C-R>)'
  echohl None
  echo ''
  echo 'Refresh the current view.'
  echo 'stat - information are updated and the !-flags are reset'
  echo 'The sorting of the listing is repeated.'
  echo 'The timestamp in the header-line is adjusted.'
  echo 'See also :'
  echo '    u'
  echo '    U'
endfunction
function <sid>Help_n2f73747275782f4c4c_87()
  echohl WarningMsg
  echo 'Update the current view (bound to u)'
  echohl None
  echo ''
  echo 'Update the current view.'
  echo 'stat - information of files allready in the listing are not updated.'
  echo 'Such changes are flagged in the ! - column (see cpg rsp. cpl below)'
  echo 'The timestamp of the header-line as well as '
  echo 'the sorting of the listing remains unchanged.'
  echo 'Possible flags are:'
  echo '    n	file is new since last refresh'
  echo '    c	file has changed since last refresh'
  echo '    d	file is deleted since last refresh'
  echo '    <blank>	file is unmodified since last refresh'
  echo 'See also :'
  echo '    U'
  echo '    <C-R>'
endfunction
function <sid>Help_n2f73747275782f4c4c_88()
  echohl WarningMsg
  echo 'Update the current view (keep deleted) (bound to U)'
  echohl None
  echo ''
  echo 'Refresh the current view.'
  echo 'stat - information are updated and the !-flags are reset'
  echo 'This command works much like <C-R> except that'
  echo 'deleted files stay in the listing (marked with d)'
  echo 'The sorting of the listing is repeated.'
  echo 'The timestamp in the header-line is adjusted.'
  echo 'See also :'
  echo '    u'
  echo '    <C-R>'
endfunction
function <sid>Help_n2f73747275782f4c4c_89()
  echohl WarningMsg
  echo 'View the list of visited dirs (bound to .?)'
  echohl None
  echo ''
  echo 'Display a list of all visited directories in a separate window.'
  echo 'This window has the name /strux/VISITED and additional commands are available there.'
  echo '  press <F1> in this window to get help on these mappings'
endfunction
function <sid>Help_n2f73747275782f4c4c_90()
  echohl WarningMsg
  echo 'View the back/forward stack (bound to .!)'
  echohl None
  echo ''
  echo 'Display the stack used for <BS> and <TAB>'
  echo 'This window has the name /strux/DIRSTACK and additional commands are available there.'
  echo '  press <F1> in this window to get help on these mappings'
endfunction
function <sid>Help_n2f73747275782f4c4c_70657220656e74727920636f6d6d616e64()
  echo 'If the first two characters are "P " then the rest is passed to (build-in) perl.'
  echo '  The filename is not automatically appended in this case.'
  echo '  The perl-code is executed in the namespace XPE (for x-per-entry).'
  echo 'Else the command is executed as a shell command.'
  echo '  The complete path to the file is appended (properly quoted) to the command.'
  echo '  both stderr and stdout are displayed.'
  echo 'The following vars are set for the command:'
  echo '    $F	filename (as shown by LL)			morepath/file.ext'
  echo '    $d	base-directory (as shown in the header-line)	/path/to/'
  echo '    $f	filename with path				/path/to/morepath/file.ext'
  echo '    $p	path to file					/path/to/morepath'
endfunction
function <sid>Help_n2f73747275782f4c4c_7065722066696c6520636f6d6d616e64()
  echo 'The command is applied to each file if the "Parse String" (see cpg rsp. cpl) contains %x.'
  echo 'The command output is put at the position indicated by %x.'
  echo 'It is not applied to directories. See cxdl rsp. cxdg for this.'
  :call <sid>Help_n2f73747275782f4c4c_70657220656e74727920636f6d6d616e64()
endfunction
function <sid>Help_n2f73747275782f4c4c_91()
  echohl WarningMsg
  echo 'Configure the Global Per File Command (bound to cxfg)'
  echohl None
  echo ''
  echo 'It is not applied to directories. See cxdg for this.'
  echo 'The local Per File command (as set with cxfl) can override the global Per File command.'
  echo 'Example :'
  echo '  file -b'
  echo '  grep -s something'
  echo '  head -q -n 1'
  echo '  wc'
  echo '  '
  echo '  cvs log  -N -rHEAD $F|perl -ne ''/date://.../^==/ and print''|perl -ne ''$.==2 and print'' #'
  echo '  cvs status $F 2>/dev/null|perl -ne ''if ($.==2) {s//.*Status: //;print;}'' #'
  echo '    In the above examples $F is used in the command. LL still appends the full pathname to the command.'
  echo '    Therefore the final # is present to turn this into a comment.'
  echo '  P open F,$F and do { chomp(my $s=<F>);close F;return $s}'
  echo '    the above example is equivalent to "head -q -n 1" but much faster, since no external program needs to be startet.'
  echo '    '
  echo 'If you set it to empty then the default entry (file -b) will be used.'
  echo 'You can set the default entry in your .vimrc with'
  echo '  let g:strux_LL_perFileCommand=''new command'' (see |g:strux_LL_perFileCommand|)'
  echo 'See also :'
  echo '  cxdg'
  echo '  cxfl'
  echo '  cxdl'
endfunction
function <sid>Help_n2f73747275782f4c4c_92()
  echohl WarningMsg
  echo 'Configure the Local Per File Command (bound to cxfl)'
  echohl None
  echo ''
  echo 'It is not applied to directories. See cxdl for this.'
  echo 'It overrides a global Per File command (as set with cxfg).'
  echo 'Example :'
  echo '  cat 2>/dev/null'
  echo '    the above exapmple is usefull e.G in /proc/sys or /proc/ide'
  echo '  whatis -s1 "$F" | sed -e ''s/.*- //'' #'
  echo '    the above exapmple is usefull e.G in /bin or /usr/bin'
  echo '  P open F,$F and do { chomp(my $s=<F>);close F;return $s}'
  echo '    the above command is equivalent to "cat 2>/dev/null".'
  echo '    '
  echo 'If you set it to empty then the gloal entry will be used.'
  echo 'See also :'
  echo '  cxdg'
  echo '  cxfg'
  echo '  cxdl'
  echo '  dirsettings'
endfunction
function <sid>Help_n2f73747275782f4c4c_7065722064697220636f6d6d616e64()
  echo 'The command is applied to each directory if the "Parse String" (see cpg rsp. cpl) contains %x.'
  echo 'Its output is put at the position indicated by %x.'
  echo 'It is not applied to normal files. See cxfl rsp. cxfg for this.'
  :call <sid>Help_n2f73747275782f4c4c_70657220656e74727920636f6d6d616e64()
endfunction
function <sid>Help_n2f73747275782f4c4c_93()
  echohl WarningMsg
  echo 'Configure the Global Per Dir Command (bound to cxdg)'
  echohl None
  echo ''
  echo 'The local Per Dir command (as set with cxdl) can override the global Per Dir command.'
  echo 'Example :'
  echo '  du -sh "$F" | awk ''{ print $1 }'' # '
  echo '  ls -1 "$F"| wc -l #'
  echo '    In the above examples $F is used in the command. LL still appends the full pathname to the command.'
  echo '    Therefore the final # is present to turn this into a comment.'
  echo '    '
  echo '  P my $s;opendir DH,$F and do { $s=@{[readdir DH]} ; close DH }; return $s'
  echo '    the above example is equivalent to "ls -1 "$F"| wc -l #"  but much faster, since no external program needs to be startet.'
  echo '    '
  echo 'If you set it to empty then the default entry (# for no command) will be used.'
  echo 'You can set the default entry in your .vimrc with'
  echo '  let g:strux_LL_perDirCommand=''new command'' (see |g:strux_LL_perDirCommand|)'
  echo 'See also :'
  echo '  cxfg'
  echo '  cxfl'
  echo '  cxdl'
endfunction
function <sid>Help_n2f73747275782f4c4c_94()
  echohl WarningMsg
  echo 'Configure the Local Per Dir Command (bound to cxdl)'
  echohl None
  echo ''
  echo 'It overrides a global Per Dir command (as set with cxfg).'
  echo 'Example :'
  echo '  [ -e $F/status  ] && { read pid name status rest < $F/stat;echo -en "$status\t" ; perl -ne ''s//.*\t//;chop;print "$_\t";exit'' $F/status ; tr ''\0'' '' '' <$F/cmdline ; } #'
  echo '    the above exapmple is usefull e.G in /proc/sys or /proc/ide'
  echo '  P return if $F !~ /\d+/  ;my $s;open F,"$F/stat" and do { $s .= (split(/\s+/,<F>))[2]." ";close F };open F,"$F/status" and do { $s .= (split(/\t+|\n/,<F>))[1]."\t";close F };open F,"$F/cmdline" and do { my $x = <F>;$x =~ s/\0/ /g;$s.=$x;close F };$s'
  echo '    the above command is equivalent to the shell-command above.'
  echo '    '
  echo 'If you set it to empty then the gloal entry will be used.'
  echo 'See also :'
  echo '  cxdg'
  echo '  cxfg'
  echo '  cxdl'
  echo '  dirsettings'
endfunction
function <sid>Help_n2f73747275782f4c4c_506172736520537472696e67()
  echo 'The format-string defines how to display the dir-entries.'
  echo 'It consists of printf style ''%'' items interspersed with normal text.'
  echo 'The formats:'
  echo '    %	A single "%" - Character'
  echo '    T	A single tab'
  echo '    t	denotes tagged lines'
  echo '    n	filename'
  echo '    /	filename, with "/" appended, if file is a directory, symlinks are indicated by ->'
  echo '    i	inode number'
  echo '    F	mode flags as octal number'
  echo '    f	mode flags in drwxrwxrwx - notation'
  echo '    u	user id (numerically)'
  echo '    U	user id (text)'
  echo '    g	group id (numerically)'
  echo '    G	group id (text)'
  echo '    s	file size'
  echo '    a	atime (in readable form)'
  echo '    c	ctime (in readable form)'
  echo '    m	mtime (in readable form)'
  echo '    d	device number'
  echo '    l	number of links'
  echo '    r	rdev'
  echo '    b	blocksize'
  echo '    S	number of blocks'
  echo '    A	atime (numerically)'
  echo '    C	ctime (numerically)'
  echo '    M	mtime (numerically)'
  echo '    !	modification flags'
  echo '    x	result of per file command, as defined by cxfl or cxfg'
  echo 'Any sequence of tabs will be shortened/prolonged to make all tab-seperated columns aligned.'
endfunction
function <sid>Help_n2f73747275782f4c4c_95()
  echohl WarningMsg
  echo 'Configure the global Parse String (bound to cpg)'
  echohl None
  echo ''
  echo 'Set the parsestring'
  echo 'If you enter an empty format-string, it is reset to the default.'
  echo 'The format-string defaults to : %t%f %!^I%l^I%U^I%G^I%m^I%s^I%/'
  echo 'This can be overwritten by setting |g:strux_LL_parsestring|'
  echo 'See also :'
  echo '    cpl'
endfunction
function <sid>Help_n2f73747275782f4c4c_96()
  echohl WarningMsg
  echo 'Configure the local Parse String (bound to cpl)'
  echohl None
  echo ''
  echo 'Set the parse-string for this directory'
  echo 'If you enter an empty format-string, it is reset to the global parse string (as set with cpg).'
  echo 'See also :'
  echo '    cpg'
  echo '    dirsettings'
endfunction
function <sid>Help_n2f73747275782f4c4c_97()
  echohl WarningMsg
  echo 'Reread the LL-autocommands (bound to cpr)'
  echohl None
  echo ''
  echo 'Rereads the file ~/LL.dirsettings which holds the NewView Autocommands'
endfunction
function <sid>Help_n2f73747275782f4c4c_98()
  echohl WarningMsg
  echo 'Clear the dirsettings for the current dir (bound to cpc)'
  echohl None
  echo ''
  echo 'clears the dirsettings for the displayed directory'
endfunction
function <sid>Help_n2f73747275782f4c4c_99()
  echohl WarningMsg
  echo 'Show technical info for this dir (bound to dt)'
  echohl None
  echo ''
  echo 'this is intended for debugging reasons'
endfunction
function <sid>Help_v2f73747275782f4c4c_1()
  echohl WarningMsg
  echo 'Tag selected files (bound to xx)'
  echohl None
  echo ''
  echo 'Tag (mark) the selected files'
endfunction
function <sid>Help_v2f73747275782f4c4c_2()
  echohl WarningMsg
  echo 'Untag selected files (bound to xX)'
  echohl None
  echo ''
  echo 'Untag (unmark) the selected files'
endfunction
function <sid>Help_v2f73747275782f4c4c_3()
  echohl WarningMsg
  echo 'Toggle selected files (bound to xt)'
  echohl None
  echo ''
  echo 'Toggle the tag for the selected files'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_1()
  echohl WarningMsg
  echo 'Execute this command (old style) (bound to <F4>)'
  echohl None
  echo ''
  echo 'Execute the line under the cursor in your shell'
  echo 'The command is executed as typed'
  echo 'It is NOT subject to vim''s treating of some chars as % and #'
  echo 'The following vars are set for the command:'
  echo '    $f	filename with path		/path/to/file/name.ext'
  echo '    $p	path				/path/to/file'
  echo '    $F	filename as given		name.ext'
  echo '    $r	filename without extension	name'
  echo '    $e	extension			ext'
  echo 'See |g:strux_LL_shell| for configuring this command.'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_2()
  echohl WarningMsg
  echo 'Execute this command (bound to 5<F4>)'
  echohl None
  echo ''
  echo 'Execute the line under the cursor in your shell'
  echo 'The command is executed as typed'
  echo 'It is NOT subject to vim''s treating of some chars as % and #'
  echo 'The following vars are set for the command:'
  echo '    $f	filename with path		/path/to/file/name.ext'
  echo '    $p	path				/path/to/file'
  echo '    $F	filename as given		name.ext'
  echo '    $r	filename without extension	name'
  echo '    $e	extension			ext'
  echo 'See |g:strux_LL_shell| for configuring this command.'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_3()
  echohl WarningMsg
  echo 'Execute this command in an xterm (bound to 1<F4>)'
  echohl None
  echo ''
  echo 'same as <F4>, but the command is executed in an xterm.'
  echo 'This is usefull if you use gvim (as opposed to (term-)vim), where interactive programs don''t work too well.'
  echo 'See |g:strux_LL_xterm| for configuring the xterm.'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_4()
  echohl WarningMsg
  echo 'Execute this command in an background xterm (bound to 2<F4>)'
  echohl None
  echo ''
  echo 'same as <F4>, but the command is executed in an xterm, which again is put into background.'
  echo 'You can continune using vim, even if the command is not yet finished.'
  echo 'This is usefull if'
  echo '    you use gvim (as opposed to (term-)vim), where interactive programs don''t work too well.'
  echo '    you want to execute a longrunning program in the background (even in (term-)vim)'
  echo 'See |g:strux_LL_xterm| for configuring the xterm.'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_5()
  echohl WarningMsg
  echo 'Execute this command and read output into a new buffer (bound to <S-F4>)'
  echohl None
  echo ''
  echo 'same as <S-F4>, but the output is read into a new buffer'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_6()
  echohl WarningMsg
  echo 'Execute this command and read output (bound to 1<S-F4>)'
  echohl None
  echo ''
  echo 'same as <F4>, but the output is read into the frequentCommands buffer.'
  echo 'The read output is also visually selected.'
  echo '  This is useful to have things like > (shift in) work out of the box'
  echo '  Press <ESC> to get rid of the visual selection'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_7()
  echohl WarningMsg
  echo 'LL file under cursor, remain in command-window (bound to <F3>)'
  echohl None
  echo ''
  echo 'This command may fail, if the name under the cursor contains spaces'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_8()
  echohl WarningMsg
  echo 'LL file under cursor (bound to 1<F3>)'
  echohl None
  echo ''
  echo 'This command may fail, if the name under the cursor contains spaces'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_9()
  echohl WarningMsg
  echo 'LL file under cursor (whole line), remain in command-window (bound to 2<F3>)'
  echohl None
  echo ''
  echo 'Take the whole line as filename, but skip leading whitespaces'
  echo 'This is especially useful if the path/filename contains spaces'
  echo 'or other strange characters.'
endfunction
function <sid>Help_n6672657175656e74436f6d6d616e6473_10()
  echohl WarningMsg
  echo 'LL file under cursor (whole line) (bound to 3<F3>)'
  echohl None
  echo ''
  echo 'Take the whole line as filename, but skip leading whitespaces'
  echo 'This is especially useful if the path/filename contains spaces'
  echo 'or other strange characters.'
endfunction
function <sid>Help_n2f73747275782f494e5350454354_1()
  echohl WarningMsg
  echo 'Inspect harder (bound to <2-leftmouse>)'
  echohl None
  echo ''
endfunction
function <sid>Help_n2f73747275782f494e5350454354_2()
  echohl WarningMsg
  echo 'Inspect harder (bound to <CR>)'
  echohl None
  echo ''
  echo 'On some lines in the inspect-window, you can get more information with this command'
  echo 'Notably on the following fields:'
  echo '    name		If the file is a symbolic link show the complete link-chain'
  echo '    dev		show the disk-free info for the filesystem this file belongs to'
  echo '    magic		show more hits of "file", if available'
  echo '    process-line	start pst and position the cursor on the appropriate entry'
  echo '      see |pstree| for details of this view'
endfunction
function <sid>Help_n2f73747275782f41434d44_1()
  echohl WarningMsg
  echo 'Show the command (bound to i)'
  echohl None
  echo ''
  echo 'show the associated command'
endfunction
function <sid>Help_n2f73747275782f41434d44_2()
  echohl WarningMsg
  echo 'Do the command (bound to <CR>)'
  echohl None
  echo ''
  echo 'execute the selected command'
endfunction
function <sid>Help_n2f73747275782f444952535441434b_1()
  echohl WarningMsg
  echo 'Select the dir (bound to <2-leftmouse>)'
  echohl None
  echo ''
  echo 'Jump to selected dir'
endfunction
function <sid>Help_n2f73747275782f444952535441434b_2()
  echohl WarningMsg
  echo 'Select the dir (bound to <CR>)'
  echohl None
  echo ''
  echo 'Jump to selected dir'
endfunction
function <sid>Help_n2f73747275782f444952535441434b_3()
  echohl WarningMsg
  echo 'Show the dir (bound to s)'
  echohl None
  echo ''
  echo 'Show to selected dir, but stay in the Dirstack-View'
endfunction
function <sid>Help_n2f73747275782f56495349544544_1()
  echohl WarningMsg
  echo 'Select the dir (bound to <2-leftmouse>)'
  echohl None
  echo ''
  echo 'Jump to selected dir'
endfunction
function <sid>Help_n2f73747275782f56495349544544_2()
  echohl WarningMsg
  echo 'Select the dir (bound to <CR>)'
  echohl None
  echo ''
  echo 'Jump to selected dir'
endfunction
function <sid>Help_n2f73747275782f56495349544544_3()
  echohl WarningMsg
  echo 'Show the dir (bound to s)'
  echohl None
  echo ''
  echo 'Show to selected dir, but stay in the Visited-View'
endfunction
function <sid>Help_n2f73747275782f56495349544544_4()
  echohl WarningMsg
  echo 'Forget this dir (bound to dd)'
  echohl None
  echo ''
  echo 'The view under the cursor is put into oblivion.'
  echo 'It may still be present in the DIRSTACK (for Back (Backspace) and Forward (Tab).'
  echo 'If the corresponding view is open right now, it will be remembered until the dir is left.'
endfunction
function <sid>Help_v2f73747275782f56495349544544_1()
  echohl WarningMsg
  echo 'Forget selected views (bound to dd)'
  echohl None
  echo ''
  echo 'The selected views are put into oblivion.'
  echo 'Some of them may still be present in the DIRSTACK (for Back (Backspace) and Forward (Tab)).'
  echo 'If one of the corresponding view is open right now, it will be remembered until the dir is left.'
endfunction
au BufLeave /strux/LL cd . "vim needs to know we're possibly somewhere else. This does the trick.
au BufEnter /strux/LL perl my $fullname4vim=getFullname4vim($$LL::currentH{dir},"");VIM::DoCommand(qq( exe 'try | silent cd '. fnameescape("$fullname4vim") . ' | catch | echohl ErrorMsg | echo "cannot enter directory, you see the last content" | echohl None | endtry'))
if exists("#OptionSet")
  au OptionSet tabstop if bufname("%") == "/strux/LL" | perl UpdateView 1 | endif
endif
"start LL for current or given dir/file
com! -n=? -complete=file       LL perl LLorRedisp('<args>')
"convert current buffer to LL
com! -n=0                      L perl L()
"LL for files returned be find
com! -n=?                      LLF perl LLF('<args>')
"LL for files containing a given regexp
com! -n=?                      LLG perl LLG('<args>')
"LL for files returned by a shellcmd
com! -n=* -complete=shellcmd   LLO perl LLO(q(<args>))
"reapply auto-dirsetting according to a given pattern. The default pattern is used if no pattern is given.
com! -n=?                      LLasIf call ReapplyDirsettings("<args>")
"start a Shell connected to LL
com! -n=0                      LLShell call LLShell(<q-mods>)
"show LL for cd in terminal
com! -n=0                      LT call LLlikeTerm()
" the shell to be used
if exists("$strux_LL_shell")
  let g:strux_LL_shell=$strux_LL_shell
endif
if !exists("g:strux_LL_shell")
  let g:strux_LL_shell="bash -l"
endif
" the xterm to be used
if exists("$strux_LL_xterm")
  let g:strux_LL_xterm=$strux_LL_xterm
endif
if !exists("g:strux_LL_xterm")
  let g:strux_LL_xterm="xterm -e"
endif
" configure how the output of LL looks like.
if exists("$strux_LL_parsestring")
  let g:strux_LL_parsestring=$strux_LL_parsestring
endif
if !exists("g:strux_LL_parsestring")
  let g:strux_LL_parsestring="%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/"
endif
" per file command
if exists("$strux_LL_perFileCommand")
  let g:strux_LL_perFileCommand=$strux_LL_perFileCommand
endif
if !exists("g:strux_LL_perFileCommand")
  let g:strux_LL_perFileCommand="file -b"
endif
" per directory command
if exists("$strux_LL_perDirCommand")
  let g:strux_LL_perDirCommand=$strux_LL_perDirCommand
endif
if !exists("g:strux_LL_perDirCommand")
  let g:strux_LL_perDirCommand="#"
endif
" description for per file/dir command
if exists("$strux_LL_perFileOrDirText")
  let g:strux_LL_perFileOrDirText=$strux_LL_perFileOrDirText
endif
if !exists("g:strux_LL_perFileOrDirText")
  let g:strux_LL_perFileOrDirText="magic"
endif
" locations for LL.dirsettings
if exists("$strux_LL_dirsettings")
  let g:strux_LL_dirsettings=$strux_LL_dirsettings
endif
if !exists("g:strux_LL_dirsettings")
  let g:strux_LL_dirsettings="~/LL.dirsettings,~/strux/etc/LL.dirsettings"
endif
" configure the header
if exists("$strux_LL_header")
  let g:strux_LL_header=$strux_LL_header
endif
if !exists("g:strux_LL_header")
  let g:strux_LL_header="%d%T%g%T%t%T%n Entries%T%s"
endif
" command for xg
if exists("$strux_LL_grep")
  let g:strux_LL_grep=$strux_LL_grep
endif
if !exists("g:strux_LL_grep")
  let g:strux_LL_grep="grep -l"
endif
" command for <CR>
if exists("$strux_LL_editcmd")
  let g:strux_LL_editcmd=$strux_LL_editcmd
endif
if !exists("g:strux_LL_editcmd")
  let g:strux_LL_editcmd="edit"
endif
" strftime - format for printing dates
if exists("$strux_LL_dateFormat")
  let g:strux_LL_dateFormat=$strux_LL_dateFormat
endif
if !exists("g:strux_LL_dateFormat")
  let g:strux_LL_dateFormat="%Y-%m-%d %H:%M:%S"
endif
if exists("loaded_LL")
  finish
else
  let loaded_LL=1
endif
runtime plugin/disp.vim
let s:cpo_save = &cpo
" cmd Buffer not yet loaded
let s:cmdBuf = -1
set cpo&vim
"****************************************
" I'd rather checked the platform from whithin perl, but to no luck
" I tried with
"   if ($ENV{OSTYPE} =~/win/i) {
"     $S_IFDIR=0040000;
"     sub isdir { @_[0] & $S_IFDIR };
"     sub isreg { !isdir @_ };
"     sub s_getpwuid { @_[0] };
"     sub s_getgrgid { @_[0] };
"   } elsif ($ENV{OSTYPE} =~/linux/) {
"     require "linux/stat.ph";
"     sub isdir { S_ISDIR(@_)};
"     sub isreg { S_ISREG(@_)};
"     sub s_getpwuid { getpwuid @_[0] };
"     sub s_getgrgid { getgrgid @_[0] };
"   }
" in main
" 
" I don't know, why this didn't do the job. So I put this stuff here for now.
"****************************************
perl use Fcntl S_ISDIR,S_IFMT,S_ISLNK,S_ISREG,S_ISSOCK,S_ISLNK,S_ISCHR,S_ISBLK,S_ISFIFO
if has ("gui_win32") || has ("gui_win32s")
  " this is true for LINUX and WINNT, I need a better way to get this value
  perl $S_IFDIR=0040000
  perl sub S_ISBLK { 0 }
  perl sub S_ISLNK { 0 }
  perl sub S_ISSOCK { 0 }
  perl sub isdir { @_[0] & $S_IFDIR }
  perl sub isreg { !isdir @_ }
  perl sub s_getpwuid { @_[0] }
  perl sub s_getgrgid { @_[0] }
else
  "perl require "linux/stat.ph"
  perl sub isdir { S_ISDIR(@_)}
  perl sub isreg { S_ISREG(@_)}
  perl sub s_getpwuid { getpwuid @_[0] }
  perl sub s_getgrgid { getgrgid @_[0] }
  perl $S_ISUID = 04000
  perl $S_ISGID = 02000
  perl $S_ISVTX = 01000
endif
" dirty trick to supress the initial "special mappings available" message
au BufEnter /strux/LL let b:_2f73747275782f4c4c_HintGiven=1
" no buffer yet created for terminal
let s:termBufNr=-1
function!LLlikeTerm() 
  if !(bufname(s:termBufNr) != '')
    LLShell
  endif
  exe "LL ".resolve("/proc/".g:strux_shellpid."/cwd")
endfunc
function!LLShell(mods) 
  if bufname(s:termBufNr) != ''
    let switchbuf=&switchbuf
    set switchbuf=useopen
    exe a:mods . ' sb '       . s:termBufNr
    let &switchbuf=switchbuf
  else
    exe a:mods . ' terminal ' . g:strux_LL_shell
    let s:termBufNr = bufnr("$")
    let vimpid=getpid()
    call Shell("echo $$ >|/tmp/".vimpid)
    call Shell("clear")
    while 1
      try
          let g:strux_shellpid = readfile("/tmp/".vimpid)[0]
          break
        catch /^Vim\%((\a\+)\)\=:E/
          " give the shell a chance to create the file
          sleep 100m
          echo 'retrying to access the term'
      endtry
    endwhile
    perl openPty()
    normal! 
  endif
endfunc
function!ReapplyDirsettings(pattern) 
  perl ClearNewViewAutocommands('silent')
  exe "perl ExexNewViewAutocommandPre ($$disp::H{dir}, '".a:pattern."')"
  exe "perl ExexNewViewAutocommandPost($$disp::H{dir}, '".a:pattern."')"
  " Update the current view (keep deleted)
  perl RefreshView(0) 
endfunc
function!ActivateCmdBuffer() 
  if bufexists(s:cmdBuf)
    let switchbuf=&switchbuf
    set switchbuf=useopen
    exe "sb ".s:cmdBuf
    let &switchbuf=switchbuf
    " buffer was already open
    let ret = 1
  else
    silent sp ~/frequentCommands
    let s:cmdBuf=bufnr("%")
    " in case vim was started with -R.
    setlocal modifiable
    " buffer is newly created
    let ret = 0
  endif
  if v:count
    exe v:count.'wincmd _'
  endif
  return ret
endfunc
function!RepeatLastShellCommand(mode) 
  " quick and dirty way to pass the vim-var mode to the perl-parameter for mode
  exe 'perl $LL::tmpMode="'.a:mode.'"'
  " write the script (uses tn)
  perl WriteTmpScript($LL::lastShellCommand,$$LL::currentH{Array}[$$LL::currentH{posInfo} =~ m/'lnum'.*?(\d+)/,$1-2][0],' "$f"',$LL::tmpMode)
  " start the script
  call ExecuteScript(a:mode)
endfunc
"-- 
"  systemcall currentline
"  the window for frequentCommands must be active
function!ExecuteCurrentLine(mode) 
  " quick and dirty way to pass the vim-var mode to the perl-parameter for mode
  exe 'perl $LL::tmpMode="'.a:mode.'"'
  " write the script (uses tn)
  perl WriteTmpScript($curbuf->Get(($curwin->Cursor())[0]),$$LL::currentH{Array}[$$LL::currentH{posInfo} =~ m/'lnum'.*?(\d+)/,$1-2][0],'',$LL::tmpMode)
  " start the script
  call ExecuteScript(a:mode)
endfunc
function!ExecuteScript(mode) 
  perl CloseTmpScript()
  if a:mode == 't'
    perl echoLastCmd()
    "****************************************
    " setfperm is only needed when not sourceing the script
    "****************************************
    " call setfperm(g:strux_LL_scriptname,"r-x------")
    "****************************************
    call Shell("\<esc>cc\<c-u> source ".g:strux_LL_scriptname )
  elseif a:mode == 'n'
    exe ":!" . g:strux_LL_shell ." ".g:strux_LL_scriptname
  elseif a:mode == 'x'
    exe ":!".g:strux_LL_xterm." " . g:strux_LL_shell ." ".g:strux_LL_scriptname
  elseif a:mode == 'r'
    exe "silent r!" . g:strux_LL_shell." ".g:strux_LL_scriptname
    normal! V'[
  elseif a:mode == 'xb'
    exe ":silent !".g:strux_LL_xterm." " . g:strux_LL_shell ." ".g:strux_LL_scriptname."&"
    exe "normal \<c-l>"
  elseif a:mode == 'rb'
    new
    exe "silent r!" . g:strux_LL_shell." ".g:strux_LL_scriptname
    silent 1d
    set nomodified
  else
    echoerr 'Internal error (wrong mode) in LL.vim'
  endif
endfunc
function!ShowProcess() 
  let save_x=@x
  " following normal-line unfolded
  " 0		start of line
  " ww		start of 2nd word (pid)
  " "xye	yank the pid to register x
  normal! 0ww"xye
  if ActivateDispBuffer('/strux/pstree')
    " pstree is already open, refresh first
    normal r
  endif
  " following normal-line unfolded
  " /		search
  " \<		start of word
  " x		pid
  " \>		end of word
  " /		end search
  " 		yes vim, really do the search
  " :		to get rid of "search hit BOTTOM, continuing at TOP" or the searchstring in the commandline
  normal! /\<x\>/:
  let @x=save_x
endfunc
function!DoCmd(mode) 
  if ActivateCmdBuffer()
    call ExecuteCurrentLine(a:mode)
    LL
  else
    echohl WarningMsg
    echo '<F4> needs frequentCommands to be visible. First select or enter the cmd to be executed!'
    echohl None
  endif
endfunc
function!Shell(cmd) 
  if !(bufname(s:termBufNr) != '')
    LLShell
  endif
  call term_sendkeys(s:termBufNr,' '.a:cmd.'')
endfunc
let &cpo = s:cpo_save
unlet s:cpo_save
" the interface
" InterfaceOFF for /strux/LL
function!InterfaceOFF_2f73747275782f4c4c()
  if exists("b:Interface_2f73747275782f4c4c_MapsDone")
    nunmenu &Entry.&Edit<tab>\<CR>
    nunmenu &File.&rename<tab>fr
    nunmenu &File.&copy<tab>fc
    nunmenu &File.&delete<tab>fd
    nunmenu &File.&Clipboard.name\ to\ &clipboard<tab>f+
    nunmenu &File.Clipboard.name\ to\ &primary<tab>f*
    nunmenu &File.Clipboard.name\ to\ &unnamed\ register<tab>f"
    nunmenu &File.Clipboard.name\ with\ path\ to\ c&lipboard<tab>fp+
    nunmenu &File.Clipboard.name\ with\ path\ to\ p&rimary<tab>fp*
    nunmenu &File.Clipboard.name\ with\ path\ to\ u&nnamed\ register<tab>fp"
    nunmenu &Do.&view<tab>dv
    nunmenu &Do.&edit<tab>de
    nunmenu &Do.&compose<tab>dc
    nunmenu &Do.&print<tab>dp
    nunmenu &Do.E&xecute\ a\ command<tab>d\<F4>
    nunmenu &Do.Execute\ a\ command\ in\ x&term<tab>d1\<F4>
    nunmenu &Do.Execute\ a\ command\ in\ &background\ xterm<tab>d2\<F4>
    nunmenu &Do.Execute\ a\ command\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>d\<S-F4>
    nunmenu &Do.&Repeat\ Last\ command<tab>d\.
    nunmenu &Do.A&ccording\ to\ cmd-view.&open\ cmd<tab>cc
    nunmenu &Do.A&ccording\ to\ cmd-view.&Execute<tab>\<F4>
    nunmenu &Do.A&ccording\ to\ cmd-view.Execute\ Ol&d<tab>5\<F4>
    nunmenu &Do.A&ccording\ to\ cmd-view.Execute\ in\ x&term<tab>1\<F4>
    nunmenu &Do.A&ccording\ to\ cmd-view.Execute\ in\ &background\ xterm<tab>2\<F4>
    nunmenu &Do.A&ccording\ to\ cmd-view.Read\ Output\ into\ a\ &new\ buffer<tab>\<S-F4>
    nunmenu &Do.&acmd.E&xecute\ default\ command<tab>dd
    nunmenu &Do.&acmd.&menu<tab>d?
    nunmenu &Do.&acmd.R&eread\ acmd-database<tab>dr
    nunmenu S&ort.&Name<tab>sn
    nunmenu S&ort.N&ame\ (case\ ignored)<tab>sI
    nunmenu S&ort.Na&me\ (numerically)<tab>sN
    nunmenu S&ort.&Extension<tab>se
    nunmenu S&ort.Lengt&h<tab>sL
    nunmenu S&ort.De&v<tab>sd
    nunmenu S&ort.In&o<tab>si
    nunmenu S&ort.Mo&de<tab>sM
    nunmenu S&ort.Nlin&k<tab>sl
    nunmenu S&ort.&Uid<tab>su
    nunmenu S&ort.&Gid<tab>sg
    nunmenu S&ort.&Rdev<tab>sr
    nunmenu S&ort.&Size<tab>ss
    nunmenu S&ort.A&time<tab>sa
    nunmenu S&ort.Mt&ime<tab>sm
    nunmenu S&ort.&Ctime<tab>sc
    nunmenu S&ort.&Blksize<tab>sB
    nunmenu S&ort.B&locks<tab>sb
    nunmenu S&ort.&X-info<tab>sx
    nunmenu S&ort.Direction\ and\ grou&ping.Descend\ (do&wn)<tab>S>
    nunmenu S&ort.Direction\ and\ grou&ping.Ascend\ (u&p)<tab>S\<
    nunmenu S&ort.Direction\ and\ grouping.&separate\ Dirs<tab>S/
    nunmenu S&ort.Direction\ and\ grouping.&don't\ separate\ Dirs<tab>S#
    nunmenu S&ort.Direction\ and\ grouping.separate\ &tagged<tab>Sx
    nunmenu S&ort.Direction\ and\ grouping.d&on't\ separate\ tagged<tab>SX
    nunmenu S&ort.Direction\ and\ grouping.&fix\ the\ settings\ for\ this\ dir<tab>Sf
    nunmenu &Entry.&Inspect<tab>i
    nunmenu &Entry.Split\ &Open<tab>o
    nunmenu &Entry.&Tabnew\ Open<tab>O
    nunmenu &Entry.&Preview<tab>p
    nunmenu &Tags.&Tag<tab>xx
    nunmenu &Tags.&Untag<tab>xX
    nunmenu &Tags.Tag\ &all<tab>xa
    nunmenu &Tags.Untag\ a&ll<tab>xA
    nunmenu &Tags.to&ggle\ tags<tab>xT
    nunmenu &Tags.toggle\ t&his<tab>xt
    nunmenu &Tags.Tag\ by\ &Pattern<tab>xp
    nunmenu &Tags.Untag\ b&y\ Pattern<tab>xP
    nunmenu &Tags.Tag\ by\ &file<tab>xf
    nunmenu &Tags.Untag\ by\ file-&content<tab>xF
    nunmenu &Tags.Tag\ by\ g&rep<tab>xg
    nunmenu &Tags.Untag\ by\ gr&ep<tab>xG
    nunmenu &Tags.E&xecute\ a\ command<tab>x\<F4>
    nunmenu &Tags.Execute\ a\ command\ in\ xter&m<tab>x1\<F4>
    nunmenu &Tags.Execute\ a\ command\ in\ &background\ xterm<tab>x2\<F4>
    nunmenu &Tags.Execute\ a\ command\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>x\<S-F4>
    nunmenu &Xterm.Apply\ pwd\ in\ the\ &shell<tab>\<c-x>\<c-x>
    nunmenu &Xterm.&LL\ for\ dir\ in\ shell<tab>\<c-x>c
    nunmenu &Xterm.start\ &a\ shell<tab>\<c-x>s
    nunmenu &Navigate.&Back\ (Previous\ visited\ dir)<tab>\<BS>
    nunmenu &Navigate.&Forward<tab>\<tab>
    nunmenu &Navigate.&Parent\ Directory<tab>\.\.
    nunmenu &Navigate.&Root\ Directory<tab>\./
    nunmenu &Navigate.&Home\ Directory<tab>\.~
    nunmenu &Navigate.&specified\ Directory<tab>\.:
    nunmenu &Navigate.f&ollow\ the\ link<tab>ff
    nunmenu &View.R&efresh<tab>\<C-R>
    nunmenu &View.&Update<tab>u
    nunmenu &View.Upda&te\ clean<tab>U
    nunmenu &View.&Visited<tab>\.?
    nunmenu &View.&DirStack<tab>\.!
    nunmenu &Configure.global\ Per\ File\ &Command<tab>cxfg
    nunmenu &Configure.local\ Per\ File\ C&ommand<tab>cxfl
    nunmenu &Configure.global\ Per\ &Dir\ Command<tab>cxdg
    nunmenu &Configure.local\ Per\ Dir\ Co&mmand<tab>cxdl
    nunmenu &Configure.global\ &Parse\ String<tab>cpg
    nunmenu &Configure.local\ P&arse\ String<tab>cpl
    nunmenu &Configure.reread\ d&irsettings<tab>cpr
    nunmenu &Configure.clear\ dirs&ettings<tab>cpc
    nunmenu &View.technical\ &Info<tab>dt
    unlet b:Interface_2f73747275782f4c4c_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f4c4c()
  echo '1	<2-leftmouse>	Edit the file'
  echo '2	<CR>	Edit the file'
  echo '3	fr	Rename the file under the cursor'
  echo '4	fc	Copy the file under the cursor'
  echo '5	fd	Delete the file under the cursor'
  echo '6	f+	Put the filename into the clipboard'
  echo '7	f*	Put the filename into primary'
  echo '8	f"	Put the filename into vim''s unnamed register (")'
  echo '9	fp+	Put the filename with path into the clipboard'
  echo '10	fp*	Put the filename with path into primary'
  echo '11	fp"	Put the filename with path into vim''s unnamed register (")'
  echo '12	dv	View'
  echo '13	de	Edit'
  echo '14	dc	Compose'
  echo '15	dp	Print'
  echo '16	d<F4>	Execute a command'
  echo '17	d1<F4>	Execute a command in an xterm'
  echo '18	d2<F4>	Execute a command in an background xterm'
  echo '19	d<S-F4>	Execute a command and read output into a new buffer'
  echo '20	d.	Repeat last command'
  echo '21	cc	Open the command window'
  echo '22	<F4>	Execute this command'
  echo '23	5<F4>	Execute this command (old style)'
  echo '24	1<F4>	Execute this command in an xterm'
  echo '25	2<F4>	Execute this command in an background xterm'
  echo '26	<S-F4>	Execute this command.Read Output into a &new buffer'
  echo '27	dd	Execute acmd for current file'
  echo '28	d?	Open acmd-menu for current file'
  echo '29	dr	Reread the acmd-database'
  echo '30	sn	Sort by Name'
  echo '31	sI	Sort by Name (case ignored)'
  echo '32	sN	Sort by Name (numerically)'
  echo '33	se	Sort by Extension'
  echo '34	sL	Sort by Length of Basename'
  echo '35	sd	Sort by Dev'
  echo '36	si	Sort by Ino'
  echo '37	sM	Sort by Mode'
  echo '38	sl	Sort by Nlink'
  echo '39	su	Sort by Uid'
  echo '40	sg	Sort by Gid'
  echo '41	sr	Sort by Rdev'
  echo '42	ss	Sort by Size'
  echo '43	sa	Sort by Atime'
  echo '44	sm	Sort by Mtime'
  echo '45	sc	Sort by Ctime'
  echo '46	sB	Sort by Blksize'
  echo '47	sb	Sort by Blocks'
  echo '48	sx	Sort by X-Info'
  echo '49	S>	Sort order is descending'
  echo '50	S<	Sort order is ascending'
  echo '51	S/	Separate dirs'
  echo '52	S#	Don''t Separate dirs'
  echo '53	Sx	Separate tagged'
  echo '54	SX	Don''t Separate tagged'
  echo '55	Sf	Fix the settings for this dir'
  echo '56	i	Inspect the file'
  echo '57	o	Open the file in a split'
  echo '58	O	Open the file in a new tab'
  echo '59	p	Preview the file'
  echo '60	xx	Tag the file'
  echo '61	xX	Untag the file'
  echo '62	xa	Tag all'
  echo '63	xA	Untag all'
  echo '64	xT	Toggle tags'
  echo '65	xt	Toggle this'
  echo '66	xp	Tag by Pattern'
  echo '67	xP	Untag by Pattern'
  echo '68	xf	Tag by file'
  echo '69	xF	Untag by file'
  echo '70	xg	Tag by grep'
  echo '71	xG	Untag by grep'
  echo '72	x<F4>	Execute a command to tagged files'
  echo '73	x1<F4>	Execute a command to tagged files in an xterm'
  echo '74	x2<F4>	Execute a command to tagged files in an background xterm'
  echo '75	x<S-F4>	Execute a command to tagged files and read output into a new buffer'
  echo '76	<c-x><c-x>	In the shell issue a cd and focus the shell'
  echo '77	<c-x>c	LL for the dir in the shell'
  echo '78	<c-x>s	open a shell'
  echo '79	<BS>	Go to the previously visited dir'
  echo '80	<tab>	Go to the next visited dir'
  echo '81	..	Go to parent dir'
  echo '82	./	Go to root dir'
  echo '83	.~	Go to home dir'
  echo '84	.:	Go to any dir'
  echo '85	ff	Follow the link under the cursor'
  echo '86	<C-R>	Refresh the current view'
  echo '87	u	Update the current view'
  echo '88	U	Update the current view (keep deleted)'
  echo '89	.?	View the list of visited dirs'
  echo '90	.!	View the back/forward stack'
  echo '91	cxfg	Configure the Global Per File Command'
  echo '92	cxfl	Configure the Local Per File Command'
  echo '93	cxdg	Configure the Global Per Dir Command'
  echo '94	cxdl	Configure the Local Per Dir Command'
  echo '95	cpg	Configure the global Parse String'
  echo '96	cpl	Configure the local Parse String'
  echo '97	cpr	Reread the LL-autocommands'
  echo '98	cpc	Clear the dirsettings for the current dir'
  echo '99	dt	Show technical info for this dir'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f4c4c_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/LL
function!InterfaceON_2f73747275782f4c4c()
  if !exists("b:Interface_2f73747275782f4c4c_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f4c4c()<CR>
    nnoremenu &Entry.&Edit<tab>\<CR> :perl OpenFile $LL::editcmd<CR>
    nnoremenu &File.&rename<tab>fr :perl renameOrCopyFile "rename"<CR>
    nnoremenu &File.&copy<tab>fc :perl renameOrCopyFile "copy"<CR>
    nnoremenu &File.&delete<tab>fd :perl deleteFile<CR>
    nnoremenu &File.&Clipboard.name\ to\ &clipboard<tab>f+ :perl fileToClipboard('+','f')<CR>
    nnoremenu &File.Clipboard.name\ to\ &primary<tab>f* :perl fileToClipboard('*','f')<CR>
    nnoremenu &File.Clipboard.name\ to\ &unnamed\ register<tab>f" :perl fileToClipboard('"','f')<CR>
    nnoremenu &File.Clipboard.name\ with\ path\ to\ c&lipboard<tab>fp+ :perl fileToClipboard('+','p')<CR>
    nnoremenu &File.Clipboard.name\ with\ path\ to\ p&rimary<tab>fp* :perl fileToClipboard('*','p')<CR>
    nnoremenu &File.Clipboard.name\ with\ path\ to\ u&nnamed\ register<tab>fp" :perl fileToClipboard('"','p')<CR>
    nnoremenu &Do.&view<tab>dv :perl MailCapCmd('view')<CR>
    nnoremenu &Do.&edit<tab>de :perl MailCapCmd('edit')<CR>
    nnoremenu &Do.&compose<tab>dc :perl MailCapCmd('compose')<CR>
    nnoremenu &Do.&print<tab>dp :perl MailCapCmd('print')<CR>
    nnoremenu &Do.E&xecute\ a\ command<tab>d\<F4> :perl DoSpecified(0,'t')<cr>
    nnoremenu &Do.Execute\ a\ command\ in\ x&term<tab>d1\<F4> :perl DoSpecified(0,'x')<cr>
    nnoremenu &Do.Execute\ a\ command\ in\ &background\ xterm<tab>d2\<F4> :perl DoSpecified(0,'xb')<cr>
    nnoremenu &Do.Execute\ a\ command\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>d\<S-F4> :perl DoSpecified(0,'rb')<cr>
    nnoremenu &Do.&Repeat\ Last\ command<tab>d\. :perl RepeatLastShellCommand<CR>
    nnoremenu &Do.A&ccording\ to\ cmd-view.&open\ cmd<tab>cc :<c-u>:call ActivateCmdBuffer()<CR>
    nnoremenu &Do.A&ccording\ to\ cmd-view.&Execute<tab>\<F4> :call DoCmd('t')<cr>
    nnoremenu &Do.A&ccording\ to\ cmd-view.Execute\ Ol&d<tab>5\<F4> :call DoCmd('n')<cr>
    nnoremenu &Do.A&ccording\ to\ cmd-view.Execute\ in\ x&term<tab>1\<F4> :call DoCmd('x')<cr>
    nnoremenu &Do.A&ccording\ to\ cmd-view.Execute\ in\ &background\ xterm<tab>2\<F4> :call DoCmd('xb')<cr>
    nnoremenu &Do.A&ccording\ to\ cmd-view.Read\ Output\ into\ a\ &new\ buffer<tab>\<S-F4> :call DoCmd('rb')<cr>
    nnoremenu &Do.&acmd.E&xecute\ default\ command<tab>dd :perl AcmdFile 0<CR>
    nnoremenu &Do.&acmd.&menu<tab>d? :perl AcmdFile 1<CR>
    nnoremenu &Do.&acmd.R&eread\ acmd-database<tab>dr :perl AcmdInit<CR>
    nnoremenu S&ort.&Name<tab>sn :perl setSode($LL::sode&~0xff\|15);SortAndRedisp<CR>
    nnoremenu S&ort.N&ame\ (case\ ignored)<tab>sI :perl setSode($LL::sode&~0xff\|18);SortAndRedisp<CR>
    nnoremenu S&ort.Na&me\ (numerically)<tab>sN :perl setSode($LL::sode&~0xff\|19);SortAndRedisp<CR>
    nnoremenu S&ort.&Extension<tab>se :perl setSode($LL::sode&~0xff\|16);SortAndRedisp<CR>
    nnoremenu S&ort.Lengt&h<tab>sL :perl setSode($LL::sode&~0xff\|17);SortAndRedisp<CR>
    nnoremenu S&ort.De&v<tab>sd :perl setSode($LL::sode&~0xff\| 1);SortAndRedisp<CR>
    nnoremenu S&ort.In&o<tab>si :perl setSode($LL::sode&~0xff\| 3);SortAndRedisp<CR>
    nnoremenu S&ort.Mo&de<tab>sM :perl setSode($LL::sode&~0xff\| 4);SortAndRedisp<CR>
    nnoremenu S&ort.Nlin&k<tab>sl :perl setSode($LL::sode&~0xff\| 5);SortAndRedisp<CR>
    nnoremenu S&ort.&Uid<tab>su :perl setSode($LL::sode&~0xff\| 6);SortAndRedisp<CR>
    nnoremenu S&ort.&Gid<tab>sg :perl setSode($LL::sode&~0xff\| 7);SortAndRedisp<CR>
    nnoremenu S&ort.&Rdev<tab>sr :perl setSode($LL::sode&~0xff\| 8);SortAndRedisp<CR>
    nnoremenu S&ort.&Size<tab>ss :perl setSode($LL::sode&~0xff\| 9);SortAndRedisp<CR>
    nnoremenu S&ort.A&time<tab>sa :perl setSode($LL::sode&~0xff\|10);SortAndRedisp<CR>
    nnoremenu S&ort.Mt&ime<tab>sm :perl setSode($LL::sode&~0xff\|11);SortAndRedisp<CR>
    nnoremenu S&ort.&Ctime<tab>sc :perl setSode($LL::sode&~0xff\|12);SortAndRedisp<CR>
    nnoremenu S&ort.&Blksize<tab>sB :perl setSode($LL::sode&~0xff\|13);SortAndRedisp<CR>
    nnoremenu S&ort.B&locks<tab>sb :perl setSode($LL::sode&~0xff\|14);SortAndRedisp<CR>
    nnoremenu S&ort.&X-info<tab>sx :perl setSode($LL::sode&~0xff\|20);SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grou&ping.Descend\ (do&wn)<tab>S> :perl setSode($LL::sode\|0x100);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grou&ping.Ascend\ (u&p)<tab>S\< :perl setSode($LL::sode&~0x100);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grouping.&separate\ Dirs<tab>S/ :perl setSode($LL::sode\|0x200);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grouping.&don't\ separate\ Dirs<tab>S# :perl setSode($LL::sode&~0x200);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grouping.separate\ &tagged<tab>Sx :perl setSode($LL::sode\|0x400);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grouping.d&on't\ separate\ tagged<tab>SX :perl setSode($LL::sode&~0x400);   SortAndRedisp<CR>
    nnoremenu S&ort.Direction\ and\ grouping.&fix\ the\ settings\ for\ this\ dir<tab>Sf :perl fixSort<CR>
    nnoremenu &Entry.&Inspect<tab>i :perl Inspect<CR>
    nnoremenu &Entry.Split\ &Open<tab>o :perl OpenFile "split"<CR>
    nnoremenu &Entry.&Tabnew\ Open<tab>O :perl OpenFile "tabnew"<CR>
    nnoremenu &Entry.&Preview<tab>p :perl OpenFile "pedit"<CR>
    nnoremenu &Tags.&Tag<tab>xx :perl TagFile ">"<CR>
    nnoremenu &Tags.&Untag<tab>xX :perl TagFile " "<CR>
    nnoremenu &Tags.Tag\ &all<tab>xa :perl TagAll  ">"<CR>
    nnoremenu &Tags.Untag\ a&ll<tab>xA :perl TagAll  " "<CR>
    nnoremenu &Tags.to&ggle\ tags<tab>xT :perl ToggleTags<CR>
    nnoremenu &Tags.toggle\ t&his<tab>xt :perl TagFile "^"<CR>
    nnoremenu &Tags.Tag\ by\ &Pattern<tab>xp :perl TagByPattern ">"<CR>
    nnoremenu &Tags.Untag\ b&y\ Pattern<tab>xP :perl TagByPattern " "<CR>
    nnoremenu &Tags.Tag\ by\ &file<tab>xf :perl TagByFile ">"<CR>
    nnoremenu &Tags.Untag\ by\ file-&content<tab>xF :perl TagByFile " "<CR>
    nnoremenu &Tags.Tag\ by\ g&rep<tab>xg :perl TagByGrep ">"<CR>
    nnoremenu &Tags.Untag\ by\ gr&ep<tab>xG :perl TagByGrep " "<CR>
    nnoremenu &Tags.E&xecute\ a\ command<tab>x\<F4> :perl DoSpecified(1,'t')<cr>
    nnoremenu &Tags.Execute\ a\ command\ in\ xter&m<tab>x1\<F4> :perl DoSpecified(1,'x')<cr>
    nnoremenu &Tags.Execute\ a\ command\ in\ &background\ xterm<tab>x2\<F4> :perl DoSpecified(1,'xb')<cr>
    nnoremenu &Tags.Execute\ a\ command\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>x\<S-F4> :perl DoSpecified(1,'rb')<cr>
    nnoremenu &Xterm.Apply\ pwd\ in\ the\ &shell<tab>\<c-x>\<c-x> :call Shell("<c-v><esc>cc<c-v><c-u> cd ".getcwd())<cr><c-w>:LLShell<cr>
    nnoremenu &Xterm.&LL\ for\ dir\ in\ shell<tab>\<c-x>c :LT<cr>
    nnoremenu &Xterm.start\ &a\ shell<tab>\<c-x>s :LLShell<cr>
    nnoremenu &Navigate.&Back\ (Previous\ visited\ dir)<tab>\<BS> :perl previousDir<CR>
    nnoremenu &Navigate.&Forward<tab>\<tab> :perl nextDir<CR>
    nnoremenu &Navigate.&Parent\ Directory<tab>\.\. :perl LL ".."<CR>
    nnoremenu &Navigate.&Root\ Directory<tab>\./ :perl LL "/"<CR>
    nnoremenu &Navigate.&Home\ Directory<tab>\.~ :perl LL $ENV{HOME}<CR>
    nnoremenu &Navigate.&specified\ Directory<tab>\.: :perl EnterDir<CR>
    nnoremenu &Navigate.f&ollow\ the\ link<tab>ff :perl followLink<CR>
    nnoremenu &View.R&efresh<tab>\<C-R> :perl UpdateView 0;RefreshView 1<CR>
    nnoremenu &View.&Update<tab>u :perl UpdateView 1<CR>
    nnoremenu &View.Upda&te\ clean<tab>U :perl RefreshView 0<CR>
    nnoremenu &View.&Visited<tab>\.? :perl VisitedDirs<CR>
    nnoremenu &View.&DirStack<tab>\.! :perl ShowDirStack<CR>
    nnoremenu &Configure.global\ Per\ File\ &Command<tab>cxfg :perl SetxPerEntryCmd("g","file")<CR>
    nnoremenu &Configure.local\ Per\ File\ C&ommand<tab>cxfl :perl SetxPerEntryCmd("l","file")<CR>
    nnoremenu &Configure.global\ Per\ &Dir\ Command<tab>cxdg :perl SetxPerEntryCmd("g","dir")<CR>
    nnoremenu &Configure.local\ Per\ Dir\ Co&mmand<tab>cxdl :perl SetxPerEntryCmd("l","dir")<CR>
    nnoremenu &Configure.global\ &Parse\ String<tab>cpg :perl SetParseString "g"<CR>
    nnoremenu &Configure.local\ P&arse\ String<tab>cpl :perl SetParseString "l"<CR>
    nnoremenu &Configure.reread\ d&irsettings<tab>cpr :perl RereadNewViewAutocommands(0)<cr>
    nnoremenu &Configure.clear\ dirs&ettings<tab>cpc :perl ClearNewViewAutocommands('verbose')<cr>
    nnoremenu &View.technical\ &Info<tab>dt :perl showTechInfo<CR>
    nnoremap <buffer> <silent> <2-leftmouse> :perl OpenFile $LL::editcmd<CR>
    nnoremap <buffer> <silent> <CR> :perl OpenFile $LL::editcmd<CR>
    nnoremap <buffer> fr :call <sid>Help_n2f73747275782f4c4c_3()<cr>:call <sid>Help_n2f73747275782f4c4c_6e65772066696c656e616d65()<cr>:perl renameOrCopyFile "rename"<CR>
    nnoremap <buffer> fc :call <sid>Help_n2f73747275782f4c4c_4()<cr>:call <sid>Help_n2f73747275782f4c4c_6e65772066696c656e616d65()<cr>:perl renameOrCopyFile "copy"<CR>
    nnoremap <buffer> fd :call <sid>Help_n2f73747275782f4c4c_5()<cr>:perl deleteFile<CR>
    nnoremap <buffer> <silent> f+ :perl fileToClipboard('+','f')<CR>
    nnoremap <buffer> <silent> f* :perl fileToClipboard('*','f')<CR>
    nnoremap <buffer> <silent> f" :perl fileToClipboard('"','f')<CR>
    nnoremap <buffer> <silent> fp+ :perl fileToClipboard('+','p')<CR>
    nnoremap <buffer> <silent> fp* :perl fileToClipboard('*','p')<CR>
    nnoremap <buffer> <silent> fp" :perl fileToClipboard('"','p')<CR>
    nnoremap <buffer> <silent> dv :perl MailCapCmd('view')<CR>
    nnoremap <buffer> <silent> de :perl MailCapCmd('edit')<CR>
    nnoremap <buffer> <silent> dc :perl MailCapCmd('compose')<CR>
    nnoremap <buffer> <silent> dp :perl MailCapCmd('print')<CR>
    nnoremap <buffer> d<F4> :call <sid>Help_n2f73747275782f4c4c_16()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(0,'t')<cr>
    nnoremap <buffer> d1<F4> :call <sid>Help_n2f73747275782f4c4c_17()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(0,'x')<cr>
    nnoremap <buffer> d2<F4> :call <sid>Help_n2f73747275782f4c4c_18()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(0,'xb')<cr>
    nnoremap <buffer> d<S-F4> :call <sid>Help_n2f73747275782f4c4c_19()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(0,'rb')<cr>
    nnoremap <buffer> <silent> d. :perl RepeatLastShellCommand<CR>
    nnoremap <buffer> <silent> cc :<c-u>:call ActivateCmdBuffer()<CR>
    nnoremap <buffer> <silent> <F4> :call DoCmd('t')<cr>
    nnoremap <buffer> <silent> 5<F4> :call DoCmd('n')<cr>
    nnoremap <buffer> <silent> 1<F4> :call DoCmd('x')<cr>
    nnoremap <buffer> <silent> 2<F4> :call DoCmd('xb')<cr>
    nnoremap <buffer> <silent> <S-F4> :call DoCmd('rb')<cr>
    nnoremap <buffer> <silent> dd :perl AcmdFile 0<CR>
    nnoremap <buffer> <silent> d? :perl AcmdFile 1<CR>
    nnoremap <buffer> <silent> dr :perl AcmdInit<CR>
    nnoremap <buffer> <silent> sn :perl setSode($LL::sode&~0xff\|15);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sI :perl setSode($LL::sode&~0xff\|18);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sN :perl setSode($LL::sode&~0xff\|19);SortAndRedisp<CR>
    nnoremap <buffer> <silent> se :perl setSode($LL::sode&~0xff\|16);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sL :perl setSode($LL::sode&~0xff\|17);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sd :perl setSode($LL::sode&~0xff\| 1);SortAndRedisp<CR>
    nnoremap <buffer> <silent> si :perl setSode($LL::sode&~0xff\| 3);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sM :perl setSode($LL::sode&~0xff\| 4);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sl :perl setSode($LL::sode&~0xff\| 5);SortAndRedisp<CR>
    nnoremap <buffer> <silent> su :perl setSode($LL::sode&~0xff\| 6);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sg :perl setSode($LL::sode&~0xff\| 7);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sr :perl setSode($LL::sode&~0xff\| 8);SortAndRedisp<CR>
    nnoremap <buffer> <silent> ss :perl setSode($LL::sode&~0xff\| 9);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sa :perl setSode($LL::sode&~0xff\|10);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sm :perl setSode($LL::sode&~0xff\|11);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sc :perl setSode($LL::sode&~0xff\|12);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sB :perl setSode($LL::sode&~0xff\|13);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sb :perl setSode($LL::sode&~0xff\|14);SortAndRedisp<CR>
    nnoremap <buffer> <silent> sx :perl setSode($LL::sode&~0xff\|20);SortAndRedisp<CR>
    nnoremap <buffer> <silent> S> :perl setSode($LL::sode\|0x100);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> S< :perl setSode($LL::sode&~0x100);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> S/ :perl setSode($LL::sode\|0x200);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> S# :perl setSode($LL::sode&~0x200);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> Sx :perl setSode($LL::sode\|0x400);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> SX :perl setSode($LL::sode&~0x400);   SortAndRedisp<CR>
    nnoremap <buffer> <silent> Sf :perl fixSort<CR>
    nnoremap <buffer> <silent> i :perl Inspect<CR>
    nnoremap <buffer> <silent> o :perl OpenFile "split"<CR>
    nnoremap <buffer> <silent> O :perl OpenFile "tabnew"<CR>
    nnoremap <buffer> <silent> p :perl OpenFile "pedit"<CR>
    nnoremap <buffer> <silent> xx :perl TagFile ">"<CR>
    nnoremap <buffer> <silent> xX :perl TagFile " "<CR>
    nnoremap <buffer> <silent> xa :perl TagAll  ">"<CR>
    nnoremap <buffer> <silent> xA :perl TagAll  " "<CR>
    nnoremap <buffer> <silent> xT :perl ToggleTags<CR>
    nnoremap <buffer> <silent> xt :perl TagFile "^"<CR>
    nnoremap <buffer> xp :call <sid>Help_n2f73747275782f4c4c_66()<cr>:perl TagByPattern ">"<CR>
    nnoremap <buffer> xP :call <sid>Help_n2f73747275782f4c4c_67()<cr>:perl TagByPattern " "<CR>
    nnoremap <buffer> xf :call <sid>Help_n2f73747275782f4c4c_68()<cr>:perl TagByFile ">"<CR>
    nnoremap <buffer> xF :call <sid>Help_n2f73747275782f4c4c_69()<cr>:perl TagByFile " "<CR>
    nnoremap <buffer> xg :call <sid>Help_n2f73747275782f4c4c_70()<cr>:perl TagByGrep ">"<CR>
    nnoremap <buffer> xG :call <sid>Help_n2f73747275782f4c4c_71()<cr>:perl TagByGrep " "<CR>
    nnoremap <buffer> x<F4> :call <sid>Help_n2f73747275782f4c4c_72()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(1,'t')<cr>
    nnoremap <buffer> x1<F4> :call <sid>Help_n2f73747275782f4c4c_73()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(1,'x')<cr>
    nnoremap <buffer> x2<F4> :call <sid>Help_n2f73747275782f4c4c_74()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(1,'xb')<cr>
    nnoremap <buffer> x<S-F4> :call <sid>Help_n2f73747275782f4c4c_75()<cr>:call <sid>Help_n2f73747275782f4c4c_7368656c6c20636f6d6d616e64()<cr>:perl DoSpecified(1,'rb')<cr>
    nnoremap <buffer> <silent> <c-x><c-x> :call Shell("<c-v><esc>cc<c-v><c-u> cd ".getcwd())<cr><c-w>:LLShell<cr>
    nnoremap <buffer> <silent> <c-x>c :LT<cr>
    nnoremap <buffer> <silent> <c-x>s :LLShell<cr>
    nnoremap <buffer> <silent> <BS> :perl previousDir<CR>
    nnoremap <buffer> <silent> <tab> :perl nextDir<CR>
    nnoremap <buffer> <silent> .. :perl LL ".."<CR>
    nnoremap <buffer> <silent> ./ :perl LL "/"<CR>
    nnoremap <buffer> <silent> .~ :perl LL $ENV{HOME}<CR>
    nnoremap <buffer> .: :call <sid>Help_n2f73747275782f4c4c_84()<cr>:perl EnterDir<CR>
    nnoremap <buffer> <silent> ff :perl followLink<CR>
    nnoremap <buffer> <silent> <C-R> :perl UpdateView 0;RefreshView 1<CR>
    nnoremap <buffer> <silent> u :perl UpdateView 1<CR>
    nnoremap <buffer> <silent> U :perl RefreshView 0<CR>
    nnoremap <buffer> <silent> .? :perl VisitedDirs<CR>
    nnoremap <buffer> <silent> .! :perl ShowDirStack<CR>
    nnoremap <buffer> cxfg :call <sid>Help_n2f73747275782f4c4c_91()<cr>:call <sid>Help_n2f73747275782f4c4c_7065722066696c6520636f6d6d616e64()<cr>:perl SetxPerEntryCmd("g","file")<CR>
    nnoremap <buffer> cxfl :call <sid>Help_n2f73747275782f4c4c_92()<cr>:call <sid>Help_n2f73747275782f4c4c_7065722066696c6520636f6d6d616e64()<cr>:perl SetxPerEntryCmd("l","file")<CR>
    nnoremap <buffer> cxdg :call <sid>Help_n2f73747275782f4c4c_93()<cr>:call <sid>Help_n2f73747275782f4c4c_7065722064697220636f6d6d616e64()<cr>:perl SetxPerEntryCmd("g","dir")<CR>
    nnoremap <buffer> cxdl :call <sid>Help_n2f73747275782f4c4c_94()<cr>:call <sid>Help_n2f73747275782f4c4c_7065722064697220636f6d6d616e64()<cr>:perl SetxPerEntryCmd("l","dir")<CR>
    nnoremap <buffer> cpg :call <sid>Help_n2f73747275782f4c4c_95()<cr>:call <sid>Help_n2f73747275782f4c4c_506172736520537472696e67()<cr>:perl SetParseString "g"<CR>
    nnoremap <buffer> cpl :call <sid>Help_n2f73747275782f4c4c_96()<cr>:call <sid>Help_n2f73747275782f4c4c_506172736520537472696e67()<cr>:perl SetParseString "l"<CR>
    nnoremap <buffer> <silent> cpr :perl RereadNewViewAutocommands(0)<cr>
    nnoremap <buffer> <silent> cpc :perl ClearNewViewAutocommands('verbose')<cr>
    nnoremap <buffer> <silent> dt :perl showTechInfo<CR>
    augroup g2f73747275782f4c4c
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f4c4c()
    augroup END
    let b:Interface_2f73747275782f4c4c_MapsDone=1
    if !exists("b:_2f73747275782f4c4c_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f4c4c_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/LL
au BufEnter /strux/LL call InterfaceON_2f73747275782f4c4c()
" the interface
" VInterfaceOFF for /strux/LL
function!VInterfaceOFF_2f73747275782f4c4c()
  if exists("b:VInterface_2f73747275782f4c4c_MapsDone")
    vunmenu &Tags.&Tag<tab>xx
    vunmenu Tags.&Untag<tab>xX
    vunmenu Tags.toggle\ t&his<tab>xt
    unlet b:VInterface_2f73747275782f4c4c_MapsDone
  endif
endf
function!<sid>Help_v2f73747275782f4c4c()
  echo '1	xx	Tag selected files'
  echo '2	xX	Untag selected files'
  echo '3	xt	Toggle selected files'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_v2f73747275782f4c4c_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" VInterfaceON for /strux/LL
function!VInterfaceON_2f73747275782f4c4c()
  if !exists("b:VInterface_2f73747275782f4c4c_MapsDone")
    vnoremap <buffer> <F1> :<C-U>call <sid>Help_v2f73747275782f4c4c()<CR>gv
    vnoremenu &Tags.&Tag<tab>xx :perl vTagFile ">"<CR>
    vnoremenu Tags.&Untag<tab>xX :perl vTagFile " "<CR>
    vnoremenu Tags.toggle\ t&his<tab>xt :perl vTagFile "^"<CR>
    vnoremap <buffer> <silent> xx :perl vTagFile ">"<CR>
    vnoremap <buffer> <silent> xX :perl vTagFile " "<CR>
    vnoremap <buffer> <silent> xt :perl vTagFile "^"<CR>
    augroup g2f73747275782f4c4c
      au BufLeave <buffer> call VInterfaceOFF_2f73747275782f4c4c()
    augroup END
    let b:VInterface_2f73747275782f4c4c_MapsDone=1
    if !exists("b:_2f73747275782f4c4c_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f4c4c_HintGiven=1
  endif
endf
" Hooking the VInterfaces for /strux/LL
au BufEnter /strux/LL call VInterfaceON_2f73747275782f4c4c()
" the interface
" InterfaceOFF for frequentCommands
function!InterfaceOFF_6672657175656e74436f6d6d616e6473()
  if exists("b:Interface_6672657175656e74436f6d6d616e6473_MapsDone")
    nunmenu &Cmd.&Execute<tab>\<F4>
    nunmenu &Cmd.Execute\ Ol&d<tab>5\<F4>
    nunmenu &Cmd.Execute\ in\ x&term<tab>1\<F4>
    nunmenu &Cmd.Execute\ in\ &background\ xterm<tab>2\<F4>
    nunmenu &Cmd.Execute\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>\<S-F4>
    nunmenu &Cmd.E&xecute\ And\ Read\ Output<tab>1\<S-F4>
    nunmenu &Cmd.&Show\ file\ or\ Dir<tab>\<F3>
    nunmenu &Cmd.&Go\ To\ file\ or\ Dir<tab>1\<F3>
    nunmenu &Cmd.Show\ &file\ or\ Dir\ (whole\ line)<tab>2\<F3>
    nunmenu &Cmd.Go\ T&o\ file\ or\ Dir\ (whole\ line)<tab>3\<F3>
    unlet b:Interface_6672657175656e74436f6d6d616e6473_MapsDone
  endif
endf
function!<sid>Help_n6672657175656e74436f6d6d616e6473()
  echo '1	<F4>	Execute this command (old style)'
  echo '2	5<F4>	Execute this command'
  echo '3	1<F4>	Execute this command in an xterm'
  echo '4	2<F4>	Execute this command in an background xterm'
  echo '5	<S-F4>	Execute this command and read output into a new buffer'
  echo '6	1<S-F4>	Execute this command and read output'
  echo '7	<F3>	LL file under cursor, remain in command-window'
  echo '8	1<F3>	LL file under cursor'
  echo '9	2<F3>	LL file under cursor (whole line), remain in command-window'
  echo '10	3<F3>	LL file under cursor (whole line)'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n6672657175656e74436f6d6d616e6473_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for frequentCommands
function!InterfaceON_6672657175656e74436f6d6d616e6473()
  if !exists("b:Interface_6672657175656e74436f6d6d616e6473_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n6672657175656e74436f6d6d616e6473()<CR>
    nnoremenu &Cmd.&Execute<tab>\<F4> :call ExecuteCurrentLine('t')<cr>
    nnoremenu &Cmd.Execute\ Ol&d<tab>5\<F4> :call ExecuteCurrentLine('n')<cr>
    nnoremenu &Cmd.Execute\ in\ x&term<tab>1\<F4> :call ExecuteCurrentLine('x')<cr>
    nnoremenu &Cmd.Execute\ in\ &background\ xterm<tab>2\<F4> :call ExecuteCurrentLine('xb')<cr>
    nnoremenu &Cmd.Execute\ And\ Read\ Output\ into\ a\ &new\ buffer<tab>\<S-F4> :call ExecuteCurrentLine('rb')<cr>
    nnoremenu &Cmd.E&xecute\ And\ Read\ Output<tab>1\<S-F4> :call ExecuteCurrentLine('r')<cr>
    nnoremenu &Cmd.&Show\ file\ or\ Dir<tab>\<F3> :LL <c-r><c-r><c-f><cr>:call ActivateCmdBuffer()<CR>
    nnoremenu &Cmd.&Go\ To\ file\ or\ Dir<tab>1\<F3> :LL <c-r><c-r><c-f><cr>
    nnoremenu &Cmd.Show\ &file\ or\ Dir\ (whole\ line)<tab>2\<F3> :exe 'perl LL("'. substitute(getline("."),'\s*',"","") .'")'<cr>:call ActivateCmdBuffer()<CR>
    nnoremenu &Cmd.Go\ T&o\ file\ or\ Dir\ (whole\ line)<tab>3\<F3> :exe 'perl LL("'. substitute(getline("."),'\s*',"","") .'")'<cr>
    nnoremap <buffer> <silent> <F4> :call ExecuteCurrentLine('t')<cr>
    nnoremap <buffer> <silent> 5<F4> :call ExecuteCurrentLine('n')<cr>
    nnoremap <buffer> <silent> 1<F4> :call ExecuteCurrentLine('x')<cr>
    nnoremap <buffer> <silent> 2<F4> :call ExecuteCurrentLine('xb')<cr>
    nnoremap <buffer> <silent> <S-F4> :call ExecuteCurrentLine('rb')<cr>
    nnoremap <buffer> <silent> 1<S-F4> :call ExecuteCurrentLine('r')<cr>
    nnoremap <buffer> <silent> <F3> :LL <c-r><c-r><c-f><cr>:call ActivateCmdBuffer()<CR>
    nnoremap <buffer> <silent> 1<F3> :LL <c-r><c-r><c-f><cr>
    nnoremap <buffer> <silent> 2<F3> :exe 'perl LL("'. substitute(getline("."),'\s*',"","") .'")'<cr>:call ActivateCmdBuffer()<CR>
    nnoremap <buffer> <silent> 3<F3> :exe 'perl LL("'. substitute(getline("."),'\s*',"","") .'")'<cr>
    augroup g6672657175656e74436f6d6d616e6473
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_6672657175656e74436f6d6d616e6473()
    augroup END
    let b:Interface_6672657175656e74436f6d6d616e6473_MapsDone=1
    if !exists("b:_6672657175656e74436f6d6d616e6473_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_6672657175656e74436f6d6d616e6473_HintGiven=1
  endif
endf
" Hooking the Interfaces for frequentCommands
au BufEnter frequentCommands call InterfaceON_6672657175656e74436f6d6d616e6473()
" the interface
" InterfaceOFF for /strux/INSPECT
function!InterfaceOFF_2f73747275782f494e5350454354()
  if exists("b:Interface_2f73747275782f494e5350454354_MapsDone")
    nunmenu &Inspect.&this<tab>\<CR>
    unlet b:Interface_2f73747275782f494e5350454354_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f494e5350454354()
  echo '1	<2-leftmouse>	Inspect harder'
  echo '2	<CR>	Inspect harder'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f494e5350454354_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/INSPECT
function!InterfaceON_2f73747275782f494e5350454354()
  if !exists("b:Interface_2f73747275782f494e5350454354_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f494e5350454354()<CR>
    nnoremenu &Inspect.&this<tab>\<CR> :perl InspectHarder<CR>
    nnoremap <buffer> <silent> <2-leftmouse> :perl InspectHarder<CR>
    nnoremap <buffer> <silent> <CR> :perl InspectHarder<CR>
    augroup g2f73747275782f494e5350454354
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f494e5350454354()
    augroup END
    let b:Interface_2f73747275782f494e5350454354_MapsDone=1
    if !exists("b:_2f73747275782f494e5350454354_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f494e5350454354_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/INSPECT
au BufEnter /strux/INSPECT call InterfaceON_2f73747275782f494e5350454354()
" the interface
" InterfaceOFF for /strux/ACMD
function!InterfaceOFF_2f73747275782f41434d44()
  if exists("b:Interface_2f73747275782f41434d44_MapsDone")
    nunmenu &Acmd.&Show<tab>i
    nunmenu &Acmd.&do<tab>\<CR>
    unlet b:Interface_2f73747275782f41434d44_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f41434d44()
  echo '1	i	Show the command'
  echo '2	<CR>	Do the command'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f41434d44_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/ACMD
function!InterfaceON_2f73747275782f41434d44()
  if !exists("b:Interface_2f73747275782f41434d44_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f41434d44()<CR>
    nnoremenu &Acmd.&Show<tab>i :perl AcmdShowCommand -1<CR>
    nnoremenu &Acmd.&do<tab>\<CR> :perl AcmdShowCommand 1<CR>
    nnoremap <buffer> <silent> i :perl AcmdShowCommand -1<CR>
    nnoremap <buffer> <silent> <CR> :perl AcmdShowCommand 1<CR>
    augroup g2f73747275782f41434d44
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f41434d44()
    augroup END
    let b:Interface_2f73747275782f41434d44_MapsDone=1
    if !exists("b:_2f73747275782f41434d44_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f41434d44_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/ACMD
au BufEnter /strux/ACMD call InterfaceON_2f73747275782f41434d44()
" the interface
" InterfaceOFF for /strux/DIRSTACK
function!InterfaceOFF_2f73747275782f444952535441434b()
  if exists("b:Interface_2f73747275782f444952535441434b_MapsDone")
    nunmenu &View.&Select<tab>\<CR>
    nunmenu &View.S&how<tab>s
    unlet b:Interface_2f73747275782f444952535441434b_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f444952535441434b()
  echo '1	<2-leftmouse>	Select the dir'
  echo '2	<CR>	Select the dir'
  echo '3	s	Show the dir'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f444952535441434b_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/DIRSTACK
function!InterfaceON_2f73747275782f444952535441434b()
  if !exists("b:Interface_2f73747275782f444952535441434b_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f444952535441434b()<CR>
    nnoremenu &View.&Select<tab>\<CR> :perl DirStackSelect<CR>
    nnoremenu &View.S&how<tab>s :perl DirStackSelect;ShowDirStack<CR>
    nnoremap <buffer> <silent> <2-leftmouse> :perl DirStackSelect<CR>
    nnoremap <buffer> <silent> <CR> :perl DirStackSelect<CR>
    nnoremap <buffer> <silent> s :perl DirStackSelect;ShowDirStack<CR>
    augroup g2f73747275782f444952535441434b
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f444952535441434b()
    augroup END
    let b:Interface_2f73747275782f444952535441434b_MapsDone=1
    if !exists("b:_2f73747275782f444952535441434b_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f444952535441434b_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/DIRSTACK
au BufEnter /strux/DIRSTACK call InterfaceON_2f73747275782f444952535441434b()
" the interface
" InterfaceOFF for /strux/VISITED
function!InterfaceOFF_2f73747275782f56495349544544()
  if exists("b:Interface_2f73747275782f56495349544544_MapsDone")
    nunmenu &View.&Select<tab>\<CR>
    nunmenu &View.S&how<tab>s
    nunmenu &View.&forget\ this\ view<tab>dd
    unlet b:Interface_2f73747275782f56495349544544_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f56495349544544()
  echo '1	<2-leftmouse>	Select the dir'
  echo '2	<CR>	Select the dir'
  echo '3	s	Show the dir'
  echo '4	dd	Forget this dir'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f56495349544544_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/VISITED
function!InterfaceON_2f73747275782f56495349544544()
  if !exists("b:Interface_2f73747275782f56495349544544_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f56495349544544()<CR>
    nnoremenu &View.&Select<tab>\<CR> :perl VisitedSelect<CR>
    nnoremenu &View.S&how<tab>s :perl VisitedSelect;VisitedDirs<CR>
    nnoremenu &View.&forget\ this\ view<tab>dd :perl VisitedForget<CR>
    nnoremap <buffer> <silent> <2-leftmouse> :perl VisitedSelect<CR>
    nnoremap <buffer> <silent> <CR> :perl VisitedSelect<CR>
    nnoremap <buffer> <silent> s :perl VisitedSelect;VisitedDirs<CR>
    nnoremap <buffer> <silent> dd :perl VisitedForget<CR>
    augroup g2f73747275782f56495349544544
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f56495349544544()
    augroup END
    let b:Interface_2f73747275782f56495349544544_MapsDone=1
    if !exists("b:_2f73747275782f56495349544544_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f56495349544544_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/VISITED
au BufEnter /strux/VISITED call InterfaceON_2f73747275782f56495349544544()
" the interface
" VInterfaceOFF for /strux/VISITED
function!VInterfaceOFF_2f73747275782f56495349544544()
  if exists("b:VInterface_2f73747275782f56495349544544_MapsDone")
    vunmenu &View.&forget\ selected\ views<tab>dd
    unlet b:VInterface_2f73747275782f56495349544544_MapsDone
  endif
endf
function!<sid>Help_v2f73747275782f56495349544544()
  echo '1	dd	Forget selected views'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_v2f73747275782f56495349544544_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" VInterfaceON for /strux/VISITED
function!VInterfaceON_2f73747275782f56495349544544()
  if !exists("b:VInterface_2f73747275782f56495349544544_MapsDone")
    vnoremap <buffer> <F1> :<C-U>call <sid>Help_v2f73747275782f56495349544544()<CR>gv
    vnoremenu &View.&forget\ selected\ views<tab>dd :perl vVisitedForget<CR>
    vnoremap <buffer> <silent> dd :perl vVisitedForget<CR>
    augroup g2f73747275782f56495349544544
      au BufLeave <buffer> call VInterfaceOFF_2f73747275782f56495349544544()
    augroup END
    let b:VInterface_2f73747275782f56495349544544_MapsDone=1
    if !exists("b:_2f73747275782f56495349544544_HintGiven")
      unsilent echo 'special mappings from LL.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f56495349544544_HintGiven=1
  endif
endf
" Hooking the VInterfaces for /strux/VISITED
au BufEnter /strux/VISITED call VInterfaceON_2f73747275782f56495349544544()
perl <<EOT
#  protos
sub main;
sub fixSort;
sub setSode($);
sub vimvar($);
sub getcwd;
sub redrawVisitedAndDirstack;
sub previousDir;
sub nextDir;
sub EnterDir;
sub tellLinkeChain($);
sub InspectHarder;
sub AcmdShowCommand($);
sub AcmdInit;
sub AcmdFile($);
sub LLF($);
sub LLG($);
sub LLO($);
sub LLproducedlist_interactive;
sub LLproducedlist($);
sub LLorRedisp($);
sub VisitedForget;
sub vVisitedForget;
sub DirStackSelect;
sub pushDirstack;
sub VisitedSelect;
sub deleteFile;
sub renameOrCopyFile($);
sub DoSpecified($$);
sub MailCapCmd($);
sub RepeatLastShellCommand;
sub ShowDirStack;
sub VisitedDirs;
sub Inspect;
sub process($);
sub getFullname4perl($$);
sub getFullname4vim($$);
sub getFullname4shell($$);
sub visitedTerse($$);
sub stat2inspect($$);
sub liketouch($);
sub xpand($);
sub setstatvars;
sub stat2hrParsed($$);
sub SetParseString($);
sub fileToClipboard($$);
sub followLink;
sub NameWithLink;
sub SetxPerEntryCmd($$);
sub xPerFile;
sub Flags($);
sub TagByPattern($);
sub ToggleTags;
sub TagAll($);
sub TagByGrep($);
sub TagByFile($);
sub vTagFile($);
sub TagFile($);
sub RefreshView($);
sub UpdateView($);
sub OpenFile($);
sub L;
sub LL($);
sub tellbranch;
sub tellsort;
sub LL_in_function;
sub LL_out_function;
sub numerically;
sub SortAndRedisp;
sub Sort($$);
sub extension($);
sub RereadNewViewAutocommands($);
sub ClearNewViewAutocommands($);
sub ExexNewViewAutocommandPre;
sub ExexNewViewAutocommandPost;
sub hdisp($);
sub WriteTmpScript($$$$);
sub CloseTmpScript;
sub openPty;
sub echoLastCmd;
sub showTechInfo;
use POSIX qw(strftime floor);

sub main
{
  $LL::defaultParseString = $LL::globalParseString=vimvar("g:strux_LL_parsestring");
  $LL::defaultxPerFileCmd = $LL::globalxPerFileCmd=vimvar("g:strux_LL_perFileCommand");
  $LL::defaultxPerDirCmd  = $LL::globalxPerDirCmd=vimvar("g:strux_LL_perDirCommand");
  $LL::defaultxText       = $LL::globalxText=vimvar("g:strux_LL_perFileOrDirText");
  $LL::newViewAutocommands=vimvar("g:strux_LL_dirsettings");
  $LL::dateFormat=vimvar("g:strux_LL_dateFormat");
  $LL::currentHeader=vimvar("g:strux_LL_header");
  $LL::grepcmd=vimvar("g:strux_LL_grep");
  $LL::editcmd=vimvar("g:strux_LL_editcmd");
  $LL::AcmdRequires = "$ENV{HOME}/strux/bin/acmd";
  RereadNewViewAutocommands(1);
  $LL::sode=(0x300|11);                            # reversed by mtime with seperated dirs
  $LL::dirstackposition=-1;                        # no directories yet stacked
}

sub fixSort
{
  if (exists($$disp::H{sort})) {
    VIM::Msg("already fixed, you can apply a new sorting, then fix again");
  } else {
    $$disp::H{sort} = $LL::sode;
    VIM::DoCommand("setlocal modifiable");
    VIM::DoCommand('normal!ggA (fixed)');
    VIM::DoCommand('normal! ``');
    VIM::DoCommand("setlocal nomodifiable|setlocal nomodified");
    VIM::Msg("sorting fixed for this view");
  }
}

sub setSode($)
{
  local ($s) = @_;
  $LL::sode = $s;
  delete $$disp::H{sort};
}

sub vimvar($)
{
  local ($var) = @_;
  my $success;
  my $val;
  VIM::DoCommand(qq(if exists("$var")|let cmd=$var|else|let cmd=''|endif));
  ($success, $val) = VIM::Eval("cmd");
  if ($success and $val) {
    return $val;
  } else {
    return "";
  }
}

sub getcwd
{
  #****************************************
  # The reason for this function (as opposed to just using cwd)
  #****************************************
  # 1) cwd invokes external program pwd
  # 2) cwd does not work reliably under windows
  #****************************************
  (my $success, my $val) = VIM::Eval("getcwd()");
  return $val;
}

sub redrawVisitedAndDirstack
{
  VIM::DoCommand(qq(if bufwinnr('/strux/VISITED')  != -1 | exe "perl VisitedDirs" |silent wincmd p | endif));
  VIM::DoCommand(qq(if bufwinnr('/strux/DIRSTACK') != -1 | exe "perl ShowDirStack"|silent wincmd p | endif));
  my $fullname4vim=getFullname4vim("$$LL::currentH{dir}","");
  VIM::DoCommand(qq(exe 'try | silent cd '. fnameescape("$fullname4vim") . ' | catch | echohl ErrorMsg | echo "cannot enter directory, you see the last content" | echohl None | endtry'));
  my $statuslineName;
  if ($$LL::currentH{type} eq "filelist") {
    $statuslineName="Lst : $fullname4vim";
  } else {
    $statuslineName="Dir : $fullname4vim";
  }
  VIM::DoCommand(qq(let b:dir="$statuslineName"|setlocal stl=%{b:dir}%=F1\\ for\\ Help));
  $LL::dir = getcwd;
}

sub previousDir
{
  if ($LL::dirstackposition > 0) {
    (my $success, $$LL::currentH{posInfo}) = VIM::Eval("string(winsaveview())");
    hdisp($LL::currentH=$LL::Dirstack[--$LL::dirstackposition]);
    VIM::DoCommand('normal! /<BS>');               # Vim does not leave the last line in a good state.
    if ($$LL::currentH{type} eq "filelist") {
      $LL::Dirs{"Lst : $$LL::currentH{dir}"} = $LL::currentH;
    } else {
      $LL::Dirs{$$LL::currentH{dir}} = $LL::currentH;
    }
    redrawVisitedAndDirstack;
  } else {
    VIM::Msg("First on stack");
  }
}

sub nextDir
{
  if ($LL::dirstackposition < $#LL::Dirstack) {
    (my $success, $$LL::currentH{posInfo}) = VIM::Eval("string(winsaveview())");
    hdisp($LL::currentH=$LL::Dirstack[++$LL::dirstackposition]);
    VIM::DoCommand('normal! /<BS>');               # Vim does not leave the last line in a good state.
    if ($$LL::currentH{type} eq "filelist") {
      $LL::Dirs{"Lst : $$LL::currentH{dir}"} = $LL::currentH;
    } else {
      $LL::Dirs{$$LL::currentH{dir}} = $LL::currentH;
    }
    redrawVisitedAndDirstack;
  } else {
    VIM::Msg("Last on stack");
  }
}

sub EnterDir
{
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("Dir : ","","dir")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    #****************************************
    # LL($answer)
    # does not work for /tmp/dir\ with\ spaces
    # hence this workaround
    #****************************************
    VIM::DoCommand(qq(try | silent cd $answer | catch | echohl ErrorMsg | echo "cannot enter directory" | echohl None | endtry));
    LL(".");
  }
}

sub tellLinkeChain($)
{
  local ($file) = @_;
  my %Linkseen= {};
  if (-l $file) {
    while (1) {
      VIM::Msg("$file");
      if (!(-l $file)) {
        last;
      }
      $file = readlink $file;
      if ($Linkseen{$file}++) {
        VIM::Msg("Recursive link ... stopping (before going insane)");
        last;
      }
    }
  } else {
    VIM::Msg("file is not a sybolic link");
  }
}

sub InspectHarder
{
  my $l = ($curwin->Cursor())[0];
  if (($l==1)) {
    tellLinkeChain $$disp::H{Array}[0][0];
  } elsif (($l==2)) {
    VIM::Msg(`df -h '$$disp::H{fullname4shell}'`);
  } elsif (($l==15)) {
    VIM::Msg(`file -kz '$$disp::H{fullname4shell}'`);
  } elsif (($l>=19)) {
    VIM::DoCommand("call ShowProcess()");
  } else {
    VIM::Msg("not here");
  }
}

sub AcmdShowCommand($)
{
  local ($DoOrShow) = @_;
  my $l = ($curwin->Cursor())[0]-2;
  VIM::DoCommand('normal! /<BS>');                 # Vim does not leave the last line in a good state.
  if ($l > 0) {
    if ($_=choice($l*$DoOrShow)) {
      VIM::Msg($_);
    }
  } else {
    VIM::Msg("not here");
  }
}

sub AcmdInit
{
  $opt_vimcall=1;
  require $LL::AcmdRequires;
  acmd_init();
  VIM::Msg("acmd database reread");
}

sub AcmdFile($)
{
  local ($withMenu) = @_;
  $opt_vimcall=1;
  require $LL::AcmdRequires;
  my $l = ($curwin->Cursor())[0];
  my $f = @{$$disp::A[$l-2]}[0];
  find_entries($f);
  if ($withMenu) {
    disp {
      bufname => "/strux/ACMD",
      Array => \@POSSIBILITIES,
      in_function => sub {$curbuf->Append(0,$f)},
      item_function => \&poss,
      linenr => 3,
    };
  } else {
    if ($_=choice(1)) {
      VIM::Msg($_);
    }
  }
}

sub LLF($)
{
  local ($pattern) = @_;
  my $cmd;
  if ($pattern eq "") {
    #****************************************
    # position the cursor between the tow stars (*)
    #****************************************
    $cmd = "find . -iname '**'\\<home>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>";
  } else {
    #****************************************
    # surround the pattern by two stars, but only if no star is already in the pattern
    #****************************************
    if ($pattern !~ /\*/) {
      $pattern="*$pattern*";
    }
    #****************************************
    # position the cursor on the i of -iname
    #****************************************
    $cmd = "find . -iname '$pattern'\\<home>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>";
  }
  LLproducedlist_interactive($cmd);
}

sub LLG($)
{
  local ($pattern) = @_;
  my $cmd;
  if ($pattern eq "") {
    #****************************************
    # position the cursor inside the ''
    #****************************************
    $cmd = "grep -lr '' .\\<home>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>";
  } else {
    #****************************************
    # position the cursor on the first option letter
    #****************************************
    $cmd = "grep -lr '$pattern' .\\<home>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>\\<right>";
  }
  LLproducedlist_interactive($cmd);
}

sub LLO($)
{
  local ($cmd) = @_;
  if ($cmd eq '') {
    LLproducedlist_interactive();
  } else {
    LLproducedlist($cmd);
  }
}

sub LLproducedlist_interactive
{
  my ($cmd) = @_;
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("Command : ","$cmd")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if ($answer ne "") {
      LLproducedlist($answer);
    }
  }
}

sub LLproducedlist($)
{
  local ($cmd) = @_;
  VIM::DoCommand('let tn=tempname()');
  VIM::DoCommand('exe "silent new ".tn');
  $curbuf->Append(0,"$cmd 2>/dev/null");
  VIM::DoCommand('silent call ExecuteCurrentLine("r")|silent 1d|exe "normal \<esc>"');
  (my $success, my $val) = VIM::Eval('line("$")');
  if ($val == 1) {
    VIM::DoCommand("bw!");
    #****************************************
    # I need to output three lines of text, else the messages disappear
    #****************************************
    VIM::Msg("  no hits  ","Error");
    VIM::Msg("command was :");
    VIM::Msg("  $cmd");
  } else {
    VIM::DoCommand('silent $d|silent L');
    VIM::DoCommand('silent exe "bw! ".tn');
  }
}

sub LLorRedisp($)
{
  local ($d) = @_;
  if ($d) {
    LL $d;
  } elsif ($$LL::currentH{time}) {
    dodisp $LL::currentH;redrawVisitedAndDirstack();VIM::DoCommand("setl ft=$$disp::H{ft}");
  } else {
    LL '.';
  }
}

sub VisitedForget
{
  my $s;
  my $arrayIndex;
  if (!(delete $LL::Dirs{$s=@$disp::A[$arrayIndex=($curwin->Cursor())[0]-1]})) {
    VIM::Msg("internal error forgetting $s","Error");
    return;
  }
  VIM::DoCommand('setlocal modifiable|silent d|setlocal nomodifiable');
  splice(@$disp::A,$arrayIndex,1);
  VIM::Msg("forgetting $s");
}

sub vVisitedForget
{
  my ($success,$start) = VIM::Eval(q(line("'<")));
  my ($success,$end  ) = VIM::Eval(q(line("'>")));
  VIM::DoCommand('setlocal modifiable|exe "normal gvd"|setlocal nomodifiable');
  for (my $ai=$start-1;$ai<$end;$ai=$ai+1) {
    delete $LL::Dirs{@$disp::A[$ai]};
  }
  splice(@$disp::A,$start-1,my $count=$end-$start+1);
  VIM::Msg("forgetting $count views");
}

sub DirStackSelect
{
  hdisp($LL::currentH=$LL::Dirstack[$LL::dirstackposition=($curwin->Cursor())[0]-1]);
  VIM::DoCommand('normal! /<BS>');                 # Vim does not leave the last line in a good state.
  redrawVisitedAndDirstack;
}

sub pushDirstack
{
  if ($LL::dirstackposition != -1 and $LL::Dirstack[$LL::dirstackposition]{dir} eq $$LL::currentH{dir} and $$LL::currentH{type} eq 'dir') {
    return;
  }
  $#LL::Dirstack=$LL::dirstackposition++;
  push @LL::Dirstack,$LL::currentH;
}

sub VisitedSelect
{
  $LL::currentH=$LL::Dirs{ @$disp::A[($curwin->Cursor())[0]-1] };
  hdisp $LL::currentH;
  pushDirstack;
  VIM::DoCommand('normal! /<BS>');                 # Vim does not leave the last line in a good state.
  redrawVisitedAndDirstack;
}

sub deleteFile
{
  setstatvars @$disp::A[($curwin->Cursor())[0]-2];
  my $fullname4vim=getFullname4vim($$disp::H{dir},$LL::file);
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("delete file $fullname4vim : ")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if (!$answer or ($answer ne 'y' and $answer ne 'Y')) {
      VIM::Msg("delete cancelled");
      return;
    }
    if (isdir($LL::mode)) {
      local *dirhandle;
      if (opendir(dirhandle,$LL::file)) {
        my $nrOfFiles = @{ [ readdir(dirhandle) ] };
        closedir dirhandle;
        if ($nrOfFiles > 2) {
          VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
          VIM::DoCommand(qq(let cmd=input("Directory is not empty, recursive delete : ")));
          VIM::DoCommand("cunmap <c-c>");
          VIM::DoCommand("redraw");
          ($success,$answer)=VIM::Eval('cmd');
          if (!($success and $answer ne "{cancelreturn}")) {
            VIM::Msg("cancelled");
          }
          VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
          if ($success and $answer ne "{cancelreturn}") {
            if (!$answer or ($answer ne 'y' and $answer ne 'Y')) {
              VIM::Msg("delete cancelled");
              return;
            }
            my $fullname4shell=getFullname4shell($$disp::H{dir},$LL::file);
            VIM::Msg(`rm -rf -- '$fullname4shell' 2>&1`);
            if ($?) {
              return;
            }
            goto success;
          } else {
            return;
          }
        }
      }
      if (rmdir($LL::file) != 1) {
        VIM::Msg("Delete failed : $!","Error");
        return;
      }
    } else {
      if (!(unlink($LL::file) == 1)) {
        VIM::Msg("Delete failed","Error");
        return;
      }
    }
    success: {
      VIM::Msg("delete sucessfull, press ^R to refresh view");
    } # success:
  }
}

sub renameOrCopyFile($)
{
  local ($mode) = @_;
  setstatvars @$disp::A[($curwin->Cursor())[0]-2];
  my $fullname4vim=getFullname4vim($$disp::H{dir},$LL::file);
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("$mode file $fullname4vim to : ","$fullname4vim","file")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    my $newname;
    if (!($newname=$answer)) {
      VIM::Msg("$mode cancelled");
      return;
    }
    $newname =~ s:^~/:$ENV{HOME}/:;
    if (-f $newname or -d $newname and -e "$newname/$LL::file") {
      VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
      VIM::DoCommand(qq(let cmd=input("file exists, $mode anyway : ")));
      VIM::DoCommand("cunmap <c-c>");
      VIM::DoCommand("redraw");
      ($success,$answer)=VIM::Eval('cmd');
      if (!($success and $answer ne "{cancelreturn}")) {
        VIM::Msg("cancelled");
      }
      VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
      if ($success and $answer ne "{cancelreturn}") {
        if (!$answer or ($answer ne 'y' and $answer ne 'Y')) {
          VIM::Msg("$mode cancelled");
          return;
        }
      } else {
        return;
      }
    }
    my $fullname4shell=getFullname4shell($$disp::H{dir},$LL::file);
    #****************************************
    # dilemma
    #****************************************
    # vim already might have escaped some characters (such as blank) due to tab-completion.
    # So if the input is a mix of tab-completion and entered characters, some might be escaped, some not.
    # And there is no way to tell which is which.
    # I remove all \-es here.
    #****************************************
    if ($newname =~ /\\\\/) {
      VIM::Msg("filenames with backslash are not supported, $mode failed");
      return;
    }
    (my $newnameNoBackslash = $newname) =~ s:\\::g;
    my $newfullname4shell=getFullname4shell($$disp::H{dir},$newnameNoBackslash);
    if ($mode eq "rename") {
      if (!(rename $LL::file,$newname)) {
        #****************************************
        # rename failed
        #****************************************
        # try to let mv do the job
        #****************************************
        VIM::Msg(`mv '$fullname4shell' '$newfullname4shell' 2>&1`);
        if ($?) {
          return;
        }
      }
    } elsif ($mode eq "copy") {
      if (-d $LL::file) {
        VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
        VIM::DoCommand(qq(let cmd=input("file is a directory, copy recursively? : ")));
        VIM::DoCommand("cunmap <c-c>");
        VIM::DoCommand("redraw");
        ($success,$answer)=VIM::Eval('cmd');
        if (!($success and $answer ne "{cancelreturn}")) {
          VIM::Msg("cancelled");
        }
        VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
        if ($success and $answer ne "{cancelreturn}") {
          if (!$answer or ($answer ne 'y' and $answer ne 'Y')) {
            VIM::Msg("$mode cancelled");
            return;
          }
        } else {
          return;
        }
      }
      VIM::Msg(`cp -pr '$fullname4shell' '$newfullname4shell' 2>&1`);
      if ($?) {
        return;
      }
    } else {
      return;
    }
    VIM::Msg("$mode sucessfull, press ^R to refresh view");
  }
}

sub DoSpecified($$)
{
  local ($tagged,$mode) = @_;
  my $prompt;
  if ($mode eq 'rb' or VIM::Eval('has("gui_running")')) {
    $prompt = "Cmd : ";
  } else {
    $prompt = "Cmd : ";
  }
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("$prompt","","shellcmd")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if (!($answer)) {
      return;
    }
    if ($tagged) {
      for (grep($$_[1]{x_tagged} eq ">",@$disp::A)) {
        WriteTmpScript($answer,$$_[0],' "$f"', $mode);
      }
      VIM::DoCommand("call ExecuteScript('$mode')");
    } else {
      $LL::lastShellCommand=$answer;
      $LL::scriptmode=$mode;
      RepeatLastShellCommand;
    }
  }
}

sub MailCapCmd($)
{
  local ($action) = @_;
  if (($curwin->Cursor())[0] > 1) {
    setstatvars @$disp::A[($curwin->Cursor())[0]-2];
    local @stderr = `run-mailcap --nopager --action=$action '$LL::file' 2>&1`;
    if ($stderr[0] =~ /^Unescaped left brace in regex is deprecated, passed through in regex/) {
      shift @stderr;                               # this message may come from perl. Skip it
    }
    if ($! and !@stderr) {
      VIM::Msg("it seems the package mime-support is not installed");
    } elsif (@stderr) {
      VIM::Msg("@stderr");
    }
  }
}

sub RepeatLastShellCommand
{
  if (!($LL::lastShellCommand)) {
    VIM::Msg("No last command","Error");
    return;
  }
  $$LL::currentH{posInfo} = VIM::Eval("string(winsaveview())");
  VIM::DoCommand("call RepeatLastShellCommand('$LL::scriptmode')");
}

sub ShowDirStack
{
  disp {
    bufname => "/strux/DIRSTACK",
    Array => \@LL::Dirstack,
    linenr => $LL::dirstackposition+1,
    item_function => sub { (($$disp::A[$i]{type} eq "filelist") ? "Lst : " : "" ). $$disp::A[$i]{dir} },
  };
}

sub VisitedDirs
{
  my @A = sort keys %LL::Dirs;
  my $linenr=1;
  for (my $i=0;$i<@A;$i=$i+1) {
    #****************************************
    # find the line of the current dir
    #****************************************
    # don't use $$LL::currentH instead of $$disp::H here, it is still the old dir
    #****************************************
    if ($$disp::H{type} eq 'filelist') {
      if ($A[$i] eq "Lst : $$disp::H{dir}") {
        $linenr += $i;
        last;
      }
    } else {
      if ($A[$i] eq $$disp::H{dir}) {
        $linenr += $i;
        last;
      }
    }
  }
  disp {
    bufname => "/strux/VISITED",
    Array => \@A,
    linenr => $linenr,
    item_function => \&visitedTerse,
    tabify => 1,
  };
}

sub Inspect
{
  my $l = ($curwin->Cursor())[0];                  # The line-nr
  if ($l > 1) {
    disp {
      bufname => "/strux/INSPECT",
      Array => [[@{$$disp::A[$l-2]}[0..1],lstat(@{$$disp::A[$l-2]}[0])]],
      item_function => \&stat2inspect,
    };
    VIM::DoCommand("setlocal ts=8|wincmd p");
  } else {
    VIM::Msg("not here","Error");
  }
}

sub process($)
{
  local ($file) = @_;
  local *dirhandle;
  if (lstat $file) {
    if (isdir((lstat _)[2]) and ($opt_r || $opt_x) and !(-l $file) || $opt_h) {
      $opt_x=0;                                    # ony one level deep
      if (chdir $file) {
        opendir(dirhandle,".") or VIM::Msg("cannot open dir $file : $!","Error");
        while ($_=readdir dirhandle) {
          process $_;
        }
        closedir dirhandle;
      }
    } else {
      @$LL::Dir[scalar @$LL::Dir] = [ $file,{},lstat _ ]; # stat ok
    }
  } else {
    @$LL::Dir[scalar @$LL::Dir] = [ $file,{} ];    # cannot stat this file
  }
}

sub getFullname4perl($$)
{
  local ($dir,$file) = @_;
  #****************************************
  # returns filename suitable for perl
  #****************************************
  # each of $dir and $file may be empty
  # if $file is an absolute path or if $dir is empty then $file is returned unchanged
  # if $file is empty then $dir is returned
  #****************************************
  if ($file eq "") {
    return $dir;
  }
  if (substr($file,0,1) ne "/" and $dir) {
    if ($dir eq "/") {
      return "/$file";
    } else {
      return "$dir/$file";
    }
  } else {
    return $file;
  }
}

sub getFullname4vim($$)
{
  local ($dir,$file) = @_;
  #****************************************
  # returns filename suitable for vim
  #****************************************
  # use fnameescape("$fullname4vim") in vim to make it suitable here
  #****************************************
  (my $tmp = getFullname4perl($dir,$file)) =~ s/(['"])/\\$1/g; # to make filenames like a'"b   (yes 4 characters a ' " and b) work
  $tmp;
}

sub getFullname4shell($$)
{
  local ($dir,$file) = @_;
  (my $tmp = getFullname4perl($dir,$file)) =~ s/'/'"'"'/g; # to make filenames like "Leonard Cohen - First, We'll Take Manhattan" work
  $tmp;
}

sub visitedTerse($$)
{
  local ($D,$i) = @_;
  my $f = @$D[$i];
  if ($f eq "/") {
    return "/\t/";
  }
  if ($f =~ m(^[A-Z]:/$)i) {
    return "$f\t$f";
  }
  $f =~ m:([^/]+)$:;
  return "$1\t$f";
}

sub stat2inspect($$)
{
  local ($D,$i) = @_;
  setstatvars @$D[$i];
  my $additionalSizeInfo;
  my $magicStr;
  my $packageStr;
  my @packageStr;
  my $fullname4internal=getFullname4perl($$LL::currentH{dir},$LL::file);
  my $fullname4shell = $$disp::H{fullname4shell} = getFullname4shell($$LL::currentH{dir},$LL::file);
  if (!($LL::size)) {
    $additionalSizeInfo.="0B\tEMPTY";
  } else {
    $additionalSizeInfo=sprintf("%sB",$LL::size);
    if ($LL::size >= 1024) {
      $additionalSizeInfo.=sprintf "\t%.2fkB",floor(100*$LL::size/(1024)                )/100;
      if ($LL::size >= 1024*1024) {
        $additionalSizeInfo.=sprintf "\t%.2fMB",floor(100*$LL::size/(1024*1024)           )/100;
        if ($LL::size >= 1024*1024*1024) {
          $additionalSizeInfo.=sprintf "\t%.2fGB",floor(100*$LL::size/(1024*1024*1024)      )/100;
          if ($LL::size >= 1024*1024*1024*1024) {
            $additionalSizeInfo.=sprintf "\t%.2fTB",floor(100*$LL::size/(1024*1024*1024*1024) )/100;
          }
        }
      }
    }
  }
  chomp($magicStr =`file -b '$fullname4shell'`);
  #****************************************
  # the package
  #****************************************
  ($packageStr) = `dpkg -S '$fullname4shell'` =~ /(.*?):/;
  if ($packageStr eq "") {
    $packageStr = '<unknown>';
  }
  chomp(@lsof=`lsof '$fullname4shell' 2>/dev/null`);
  if (@lsof) {
    map {
      s/^/  /;
    } @lsof;
    unshift @lsof,"Processes currently accessing this file:";
  } else {
    unshift @lsof,"No Process currently accessing this file (as far as I can tell)";
  }
  $curbuf->Append($item++,"name\t$fullname4internal");
  $curbuf->Append($item++,sprintf("dev\t%d,%d",$LL::dev>>8,$LL::dev&0xff));
  $curbuf->Append($item++,"ino\t$LL::ino");
  $curbuf->Append($item++,sprintf "mode\t0%o\t\t%s",$LL::mode,Flags($LL::mode));
  $curbuf->Append($item++,"nlink\t$LL::nlink");
  $curbuf->Append($item++,"uid\t$LL::uid\t\t".s_getpwuid $LL::uid);
  $curbuf->Append($item++,"gid\t$LL::gid\t\t".s_getgrgid $LL::gid);
  $curbuf->Append($item++,"rdev\t$LL::rdev".((S_ISCHR($LL::mode) or S_ISBLK($LL::mode)) ? sprintf( "\t\t%d, %3d",($LL::rdev >> 8),($LL::rdev & 0xff) ): ""));
  $curbuf->Append($item++,"size\t$additionalSizeInfo");
  $curbuf->Append($item++,"blksize\t$LL::blksize");
  $curbuf->Append($item++,"blocks\t$LL::blocks");
  $curbuf->Append($item++,"atime\t$LL::atime\t".liketouch($LL::atime)."\t".xpand($LL::atime));
  $curbuf->Append($item++,"ctime\t$LL::ctime\t".liketouch($LL::ctime)."\t".xpand($LL::ctime));
  $curbuf->Append($item++,"mtime\t$LL::mtime\t".liketouch($LL::mtime)."\t".xpand($LL::mtime));
  $curbuf->Append($item++,"magic\t$magicStr");
  $curbuf->Append($item++,"package\t$packageStr");
  $curbuf->Append($item,@lsof);
  $item+=@lsof;
  return undef;
}
### 
#  return a string that looks like the one needed by the touch(1) command

sub liketouch($)
{
  local ($time) = @_;
  strftime('%Y%m%d%H%M.%S',localtime($time));
}

sub xpand($)
{
  local ($time) = @_;
  strftime($LL::dateFormat,localtime($time));
}

sub setstatvars
{
  *LL::file=\$_[0][0];
  *LL::dev=\$_[0][2];
  *LL::ino=\$_[0][3];
  *LL::mode=\$_[0][4];
  *LL::nlink=\$_[0][5];
  *LL::uid=\$_[0][6];
  *LL::gid=\$_[0][7];
  *LL::rdev=\$_[0][8];
  *LL::size=\$_[0][9];
  *LL::atime=\$_[0][10];
  *LL::mtime=\$_[0][11];
  *LL::ctime=\$_[0][12];
  *LL::blksize=\$_[0][13];
  *LL::blocks=\$_[0][14];
  *LL::xInfo=\$_[0][15];
  $LL::tags=$_[0][1];
}

sub stat2hrParsed($$)
{
  local ($D,$i) = @_;
  my $escapedfile;
  my $line="";                                     # output is constructed here in
  my $called4desc = !$D and !$i;                   # we are called for the header line
  if (!($called4desc)) {
    setstatvars @$D[$i];
    ($escapedfile=$LL::file) =~ s/\t/\\t/g;
  }
  for (my $j=0;$j<length($LL::currentParseString);$j++) {
    my $c=substr $LL::currentParseString,$j,1;
    if ($c eq "%") {
      $c=substr $LL::currentParseString,++$j,1;
      parse: {
        if ($c eq '%') { $line.= ( $called4desc?("%"):('%'));last parse }
        if ($c eq 't') { $line.= ( $called4desc?("  "):($$LL::tags{x_tagged} || " "));last parse }
        if ($c eq 'T') { $line.= ( $called4desc?("\t"):("\t"));last parse }
        if ($c eq 'n') { $line.= ( $called4desc?("name"):($escapedfile));last parse }
        if ($c eq '/') { $line.= ( $called4desc?("name"):(isdir($LL::mode) ? "$escapedfile/" : NameWithLink()));last parse }
        if ($c eq 'i') { $line.= ( $called4desc?("inode"):($LL::ino));last parse }
        if ($c eq 'F') { $line.= ( $called4desc?("mod"):(sprintf "%03o",$LL::mode&0777));last parse }
        if ($c eq 'f') { $line.= ( $called4desc?("mode      "):(Flags($LL::mode)));last parse }
        if ($c eq 'u') { $line.= ( $called4desc?("uid"):($LL::uid));last parse }
        if ($c eq 'U') { $line.= ( $called4desc?("uid"):((local $tmp = s_getpwuid $LL::uid)?$tmp:$LL::uid));last parse }
        if ($c eq 'g') { $line.= ( $called4desc?("gid"):($LL::gid));last parse }
        if ($c eq 'G') { $line.= ( $called4desc?("gid"):((local $tmp = s_getgrgid $LL::gid)?$tmp:$LL::gid));last parse }
        if ($c eq 's') { $line.= ( $called4desc?("           size"):((S_ISCHR($LL::mode) or S_ISBLK($LL::mode)) ? sprintf( "%10d, %3d",($LL::rdev >> 8),($LL::rdev & 0xff) ): sprintf "%15s",$LL::size));last parse }
        if ($c eq 'a') { $line.= ( $called4desc?("atime"):(xpand($LL::atime)));last parse }
        if ($c eq 'c') { $line.= ( $called4desc?("ctime"):(xpand($LL::ctime)));last parse }
        if ($c eq 'm') { $line.= ( $called4desc?("mtime"):(xpand($LL::mtime)));last parse }
        if ($c eq 'd') { $line.= ( $called4desc?("dev"):($LL::dev));last parse }
        if ($c eq 'l') { $line.= ( $called4desc?("nlink"):($LL::nlink+0));last parse }
        if ($c eq 'r') { $line.= ( $called4desc?("rdev"):($LL::rdev));last parse }
        if ($c eq 'b') { $line.= ( $called4desc?("blksize"):($LL::blksize));last parse }
        if ($c eq 'S') { $line.= ( $called4desc?("blocks"):($LL::blocks+0));last parse }
        if ($c eq 'A') { $line.= ( $called4desc?("atime"):($LL::atime));last parse }
        if ($c eq 'C') { $line.= ( $called4desc?("ctime"):($LL::ctime));last parse }
        if ($c eq 'M') { $line.= ( $called4desc?("mtime"):($LL::mtime));last parse }
        if ($c eq '!') { $line.= ( $called4desc?("!"):((local $tmp = $$LL::tags{_ll_})?$tmp:" "));last parse }
        if ($c eq 'x') { $line.= ( $called4desc?("$LL::currentxText"):(xPerFile));last parse }
        $line.="ERROR";
      } # parse:
    } else {
      $line.="$c";
    }
  }
  $line;
}

sub SetParseString($)
{
  local ($scope) = @_;
  if ($scope eq "g") {
    #****************************************
    # global parse string
    #****************************************
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("global ParseString : ","$LL::globalParseString")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      if ($answer ne $LL::globalParseString) {
        if ($answer) {
          $LL::globalParseString=$answer;
        } else {
          $LL::globalParseString=$LL::defaultParseString;
        }
        UpdateView 1;                              # Assure, that the changes are applied immediatly
      }
    }
  } else {
    #****************************************
    # local parse string
    #****************************************
    local $lps=$LL::P{$LL::dir}?$LL::P{$LL::dir}:$LL::globalParseString;
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("local ParseString : ","$lps")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      if ($answer ne $LL::P{$LL::dir}) {
        if ($answer) {
          $LL::P{$LL::dir}=$answer;
        } else {
          undef($LL::P{$LL::dir});
        }
        UpdateView 1;                              # Assure, that the changes are applied immediatly
      }
    }
  }
  if (!($LL::currentParseString =~ m:%/$:)) {
    $$disp::H{ft}='LL-common';
    VIM::DoCommand("setl ft=$$disp::H{ft}");
  }
}

sub fileToClipboard($$)
{
  local ($register,$what) = @_;
  setstatvars @$disp::A[($curwin->Cursor())[0]-2];
  my $fullname4vim;
  if ($what eq 'f') {
    $fullname4vim=getFullname4vim("",$LL::file);
  } else {
    $fullname4vim=getFullname4vim($$disp::H{dir},$LL::file);
  }
  VIM::DoCommand qq(exe 'let \@$register="'.fnameescape("$fullname4vim").'"');
  VIM::DoCommand qq(echo "yanked" \@$register);
}

sub followLink
{
  setstatvars @$disp::A[($curwin->Cursor())[0]-2];
  if ($LL::file =~ m:/:) {
    LL($LL::file);
  } elsif (S_ISLNK $LL::mode) {
    if (substr((my $l=readlink $LL::file),0,1) ne '/') {
      (my $f=$LL::file) =~ s:[^/]*$::;
      LL($f.readlink $LL::file);
    } else {
      LL(readlink $LL::file);
    }
  } elsif (isdir($LL::mode)) {
    LL($LL::file);
  } elsif ($LL::file eq ".git") {
    local *GF;
    if (open(GF,$LL::file)) {
      while (<GF>) {
        if (m/gitdir: (.*)/) {
          LL($1);
          last;
        }
      }
    }
  } else {
    VIM::Msg("File is neither a symbolic link nor is it in a subdir");
  }
}

sub NameWithLink
{
  my $str=$LL::file;
  if (S_ISLNK $LL::mode) {
    my ($f,$l);
    if (substr(($l=readlink $LL::file),0,1) ne '/') {
      ($f=$LL::file) =~ s:[^/]*$::;
    }
    if ( $l =~ /^pipe|socket:\[\d+\]$/ or -e $f.readlink $LL::file) {
      $str.=" -> ";
    } else {
      $str.=" -!> ";
    }
    $str.=$l;
    # ?	-d readlink $LL::file	$str.="/"
    #  don't do the above or at least also check if the link already ends in /
    #  I think it's better to show links as they are
  }
  $str=~s/\t/\\t/g;
  $str;
}

sub SetxPerEntryCmd($$)
{
  local ($scope,$type) = @_;
  local *globalxPerEntryCmd;
  local *defaultxPerEntryCmd;
  local *XPe;
  if ($type eq "dir") {
    *globalxPerEntryCmd  = \$LL::globalxPerDirCmd;
    *defaultxPerEntryCmd = \$LL::defaultxPerDirCmd;
    *XPe                 = \%LL::Xd;
  } else {
    *globalxPerEntryCmd  = \$LL::globalxPerFileCmd;
    *defaultxPerEntryCmd = \$LL::defaultxPerFileCmd;
    *XPe                 = \%LL::Xf;
  }
  if ($scope eq "g") {
    #****************************************
    # global x per entry command
    #****************************************
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("(optional) description : ","$LL::globalxText")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      $LL::currentxText = $LL::globalxText = $answer;
    }
    (my $xpf=$globalxPerEntryCmd) =~ s/(['"])/\\$1/g;
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("global x per $type command : ","$xpf")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      if ($answer ne $globalxPerEntryCmd) {
        if ($answer) {
          $globalxPerEntryCmd=$answer;
        } else {
          $globalxPerEntryCmd=$defaultxPerEntryCmd;
        }
        RefreshView 0;                             # Assure, that the changes are applied immediatly
      }
    }
  } else {
    #****************************************
    # local x per entry command
    #****************************************
    my $xpf=$XPe{$LL::dir}?$XPe{$LL::dir}:$globalxPerEntryCmd;
    $xpf =~ s/(['"])/\\$1/g;
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("(optional) description : ","$Xt{$LL::dir}")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      $LL::currentxText = $Xt{$LL::dir} = $answer;
    }
    VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
    VIM::DoCommand(qq(let cmd=input("local x per $type command : ","$xpf")));
    VIM::DoCommand("cunmap <c-c>");
    VIM::DoCommand("redraw");
    ($success,$answer)=VIM::Eval('cmd');
    if (!($success and $answer ne "{cancelreturn}")) {
      VIM::Msg("cancelled");
    }
    VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
    if ($success and $answer ne "{cancelreturn}") {
      if ($answer ne $XPe{$LL::dir}) {
        if ($answer) {
          $XPe{$LL::dir}=$answer;
        } else {
          undef($XPe{$LL::dir});
        }
        RefreshView 0;                             # Assure, that the changes are applied immediatly
      }
    }
  }
}

sub xPerFile
{
  #****************************************
  # execute the LL::currentxPerFileCmd for files.
  # execute the LL::currentxPerDirCmd  for directories (not for . and .. ).
  # but only if the command is not empty.
  # stderr is redirected to stdout.
  # command starting with "P " are Perl-commands.
  # these vars are set
  #   $F	filename (as shown by LL)			morepath/file.ext
  #   $d	base-directory (as shown in the header-line)	/path/to/
  #   $f	filename with path				/path/to/morepath/file.ext
  #   $p	path to file					/path/to/morepath
  #****************************************
  if (!($LL::mode)) {
    return "";
  }
  if (defined($LL::xInfo)) {
    return $LL::xInfo;
  }
  local *cmd;
  if (isdir($LL::mode)) {
    if ($LL::file eq "." or $LL::file eq "..") {
      return "";
    }
    *cmd = \$LL::currentxPerDirCmd;
  } else {
    *cmd = \$LL::currentxPerFileCmd;
  }
  if (substr($cmd,0,1) eq "#") {
    return;
  }
  if ($LL::currentxIn and !$LL::xinDone++) {
    if (substr($LL::currentxIn,0,2) eq "P ") {
      $XPE::d = $$disp::H{dir};
      eval("package XPE;".substr($LL::currentxIn,2));
    } else {
      $ENV{d} = $$disp::H{dir};
      `2>&1 $LL::currentxIn`;
    }
  }
  $F = $LL::file;
  $d = $$disp::H{dir};
  $f = $LL::file;
  if (!($f =~ m:^/:)) {
    #****************************************
    # if filename is not already absolute prepend the path
    #****************************************
    $f="$$disp::H{dir}/$f";
  }
  ($p = $f) =~ s:/[^/]*$::;
  if (substr($cmd,0,2) eq "P ") {
    $XPE::F = $F;
    $XPE::d = $d;
    $XPE::f = $f;
    $XPE::p = $p;
    return $LL::xInfo=eval("package XPE;".substr($cmd,2));
  } else {
    $ENV{F} = $F;
    $ENV{d} = $d;
    $ENV{f} = $f;
    $ENV{p} = $p;
    $f =~ s/'/'"'"'/g;
    chomp(my $tmp=`2>&1 $cmd '$f'`);
    return $LL::xInfo=$tmp;
  }
}

sub Flags($)
{
  local ($f) = @_;
  my ($str,$i,$b);
  if ((isreg($LL::mode))) {
    $str = '-';
  } elsif ((isdir($LL::mode))) {
    $str = 'd';
  } elsif ((S_ISSOCK($LL::mode))) {
    $str = 's';
  } elsif ((S_ISLNK($LL::mode))) {
    $str = 'l';
  } elsif ((S_ISCHR($LL::mode))) {
    $str = 'c';
  } elsif ((S_ISBLK($LL::mode))) {
    $str = 'b';
  } elsif ((S_ISFIFO($LL::mode))) {
    $str = 'p';
  } else {
    $str = ' ';
  }
  for ($i = 1,$b = 0400; $i<=9 ; $b>>=1,$i++) {
    $str .= $f & $b ? substr("drwxrwxrwx",$i,1) : '-';
  }
  if ($f & $S_ISUID) {
    substr($str,3,1) = 's';
  }
  if ($f & $S_ISGID) {
    substr($str,6,1) = 's';
  }
  if ($f & $S_ISVTX) {
    substr($str,9,1) = 't';
  }
  $str;
}

sub TagByPattern($)
{
  local ($v) = @_;
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("Pattern : ")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if (!($answer)) {
      return;
    }
    for (grep(@$_[0]=~$answer,@$disp::A)) {
      $$_[1]{x_tagged}=$v;
    }
    redisp;
  }
}

sub ToggleTags
{
  map {
    $$_[1]{x_tagged}=$$_[1]{x_tagged} eq ">"?" ":">";
  } @{$$disp::H{Array}};
  redisp;
}

sub TagAll($)
{
  local ($v) = @_;
  map {
    $$_[1]{x_tagged}=$v;
  } @{$$disp::H{Array}};
  redisp;
}

sub TagByGrep($)
{
  local ($v) = @_;
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("Grepcmd : ")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if (!($answer)) {
      return;
    }
    my $f;
    my $count=0;
    my $greperror=0;
    local *TF;
    if (open(TF,$LL::grepcmd." $answer|")) {
      while ($f=<TF>) {
        chop $f;
        $count++;
        for (grep(@$_[0] eq $f,@$disp::A)) {
          $$_[1]{x_tagged}=$v;
        }
      }
      close TF;
      #****************************************
      # for $greperror see note about grepcmd in main
      #****************************************
      if ($? & ~0x300) {
        $greperror=1;
      }
      redisp;
      if ($greperror) {
        VIM::Msg("Error invoking grep");
      } else {
        VIM::Msg("$count hits");
      }
    } else {
      VIM::Msg("Cannot grep (fork failed)");
    }
  }
}

sub TagByFile($)
{
  local ($v) = @_;
  VIM::DoCommand("cnoremap <c-c> <C-e><C-u>{cancelreturn}<esc>");
  VIM::DoCommand(qq(let cmd=input("File : ","","file")));
  VIM::DoCommand("cunmap <c-c>");
  VIM::DoCommand("redraw");
  ($success,$answer)=VIM::Eval('cmd');
  if (!($success and $answer ne "{cancelreturn}")) {
    VIM::Msg("cancelled");
  }
  VIM::DoCommand("call histdel('input','^{cancelreturn}\$')");
  if ($success and $answer ne "{cancelreturn}") {
    if (!($answer)) {
      return;
    }
    my $f;
    local *TF;
    if (-r $answer) {
      if (open(TF,$answer)) {
        while ($f=<TF>) {
          chop $f;
          for (grep(@$_[0] eq $f,@$disp::A)) {
            $$_[1]{x_tagged}=$v;
          }
        }
        close TF;
        redisp;
      } else {
        VIM::Msg("File $answer not found");
      }
    } else {
      VIM::Msg("File $answer not found");
    }
  }
}

sub vTagFile($)
{
  local ($v) = @_;
  my ($success,$start) = VIM::Eval(q(line("'<")));
  my ($success,$end  ) = VIM::Eval(q(line("'>")));
  VIM::DoCommand("setlocal modifiable");
  for (my $ai=$start-2;$ai<$end-1;$ai=$ai+1) {
    setstatvars @$disp::A[$ai];
    if ($v eq "^") {
      $$LL::tags{x_tagged} =($$LL::tags{x_tagged} eq ">")? " " : ">";
    } else {
      $$LL::tags{x_tagged} = $v;
    }
    my $vi=$ai+2;
    VIM::DoCommand("normal! ${vi}G0r$$LL::tags{x_tagged}$vc ");
  }
  VIM::DoCommand("setlocal nomodifiable|setlocal nomodified");
}

sub TagFile($)
{
  local ($v) = @_;
  my ($vi,$vc)=($curwin->Cursor());                # the line in vim
  my $ai=$vi-2;                                    # the index in A
  setstatvars @$disp::A[$ai];
  if ($v eq "^") {
    $$LL::tags{x_tagged} =($$LL::tags{x_tagged} eq ">")? " " : ">";
  } else {
    $$LL::tags{x_tagged} = $v;
  }
  VIM::DoCommand("setlocal modifiable");
  #****************************************
  # motivation for s instead of r
  #****************************************
  # normally I'd rather do
  #   VIM::DoCommand("normal! 0r$$LL::tags{x_tagged}$vc ")
  # but then, if a file gets tagged and showmatch is set then vim beeps
  # Due to some plugins it may also not be suffient to simply
  #   setlocal matchpairs=
  #****************************************
  VIM::DoCommand("normal! 0s<$$LL::tags{x_tagged}0x$vc ");
  VIM::DoCommand("setlocal nomodifiable|setlocal nomodified");
}

sub RefreshView($)
{
  local ($RemoveDeleted) = @_;
  my $nameUnderCursor;
  if ($RemoveDeleted) {
    VIM::Msg("Refreshing view for $$disp::H{dir}");
  } else {
    VIM::Msg("Clean-updating view for $$disp::H{dir}");
  }
  $$disp::H{time} = time;
  if (($curwin->Cursor())[0] > 1) {
    $nameUnderCursor=$$disp::A[($curwin->Cursor())[0]-2][0];
  }
  for (@{$$disp::H{Array}}) {
    if (lstat $$_[0]) {
      $_=[$$_[0],$$_[1],lstat _];
      $$_[1]{_ll_} = "";
    } else {
      $$_[1]{_ll_}="d";
    }
  }
  if ($RemoveDeleted) {
    @{$$disp::H{Array}} = grep { $$_[1]{_ll_} ne "d" } @{$$disp::H{Array}};
  }
  SortAndRedisp $nameUnderCursor;
}

sub UpdateView($)
{
  local ($verbose) = @_;
  if ($verbose) {
    VIM::Msg("Updating view for $$disp::H{dir}");
  }
  my $oldDir = $$disp::H{Array};
  $LL::Dir = [];                                   # here process puts it's stuff in
  my $newDir = $LL::Dir;
  my $oi=0;
  my $ni=0;
  my @D=();
  my $nameUnderCursor;
  if ($$disp::H{type} eq "dir") {
    if (($curwin->Cursor())[0] > 1) {
      $nameUnderCursor=$$disp::A[($curwin->Cursor())[0]-2][0];
    }
    $opt_x=1;process $$disp::H{dir};
    Sort $newDir,15;                               # sort by name
    Sort $oldDir,15;                               # sort like newDir
  } else {
    #****************************************
    # this is a filelist-view
    #****************************************
    # we only process the items in the list
    #****************************************
    for (@$oldDir) {
      @$LL::Dir[scalar @$LL::Dir] = [ @$_[0],@$_[1],lstat @$_[0] ];
    }
  }
  while ($oi<=$#$oldDir and $ni<=$#$newDir) {
    my $check=$$newDir[$ni][0] cmp $$oldDir[$oi][0];
    if ($check == 0) {
      # new == old
      push @D,$$oldDir[$oi];
      if ($#{$$newDir[$ni]} == 1) {
        $D[-1][1]{_ll_} = "d";
      } else {
        if ($$newDir[$ni][2] != $$oldDir[$oi][2] or $$newDir[$ni][3] != $$oldDir[$oi][3] or $$newDir[$ni][4] != $$oldDir[$oi][4] or $$newDir[$ni][5] != $$oldDir[$oi][5] or $$newDir[$ni][6] != $$oldDir[$oi][6] or $$newDir[$ni][7] != $$oldDir[$oi][7] or $$newDir[$ni][8] != $$oldDir[$oi][8] or $$newDir[$ni][9] != $$oldDir[$oi][9] or $$newDir[$ni][11] != $$oldDir[$oi][11] or $$newDir[$ni][12] != $$oldDir[$oi][12] or $$newDir[$ni][13] != $$oldDir[$oi][13] or $$newDir[$ni][14] != $$oldDir[$oi][14]) {
          $D[-1][1]{_ll_} = "c";
        } else {
          if ($D[-1][1]{_ll_} ne "n") {
            $D[-1][1]{_ll_} = "";
          }
        }
      }
      $ni++;
      $oi++;
    } elsif ($check == -1) {
      # new < old
      push @D,$$newDir[$ni];
      $D[-1][1]{_ll_} = "n";
      $ni++;
    } elsif ($check == 1) {
      # new > old
      push @D,$$oldDir[$oi];
      $D[-1][1]{_ll_} = "d";
      $oi++;
    }
  }
  while ($oi<=$#$oldDir) {
    push @D,$$oldDir[$oi++];
    $D[-1][1]{_ll_} = "d";
  }
  while ($ni<=$#$newDir) {
    push @D,$$newDir[$ni++];
    $D[-1][1]{_ll_} = "n";
  }
  $disp::A = $$disp::H{Array} = \@D;
  (my $success, $$disp::H{posInfo}) = VIM::Eval("string(winsaveview())");
  if ($$disp::H{type} eq "dir") {
    SortAndRedisp $nameUnderCursor;
  } else {
    dodisp $disp::H;
  }
}

sub OpenFile($)
{
  local ($editcmd) = @_;
  my $lineNr = ($curwin->Cursor())[0];
  if ($lineNr == 1) {
    $$disp::H{showdesc} = !$$disp::H{showdesc};
    LLorRedisp('');
    VIM::DoCommand "1";
  } else {
    if (chdir $$disp::H{dir}) {
      setstatvars @$disp::A[$lineNr-2];
      my $fullname4vim=getFullname4vim($$disp::H{dir},$LL::file);
      if (isdir $LL::mode or S_ISLNK $LL::mode and -d readlink $LL::file) {
        (my $success, $$disp::H{posInfo}) = VIM::Eval("string(winsaveview())");
        LL $LL::file;
      } else {
        VIM::DoCommand qq(exe "$editcmd " . fnameescape("$fullname4vim"));
      }
    } else {
      VIM::Msg("cannot reenter $$disp::H{dir}","Error");
    }
  }
}

sub L
{
  (my $success, my $result) = VIM::Eval("exists('b:dir')");
  if ($result) {
    VIM::Msg("L not applicable for this buffer","Error");
    return;
  }
  VIM::Msg("Converting to LL");
  my $count=$curbuf->Count();
  my $dir=getcwd;
  my $Dir;
  for (my $i=1;$i<=$count;$i++) {
    if (my $file=$curbuf->Get($i)) {
      $file =~ s:^\s+::;
      $file =~ s:\t.*::;
      $file =~ s:^~/:$ENV{HOME}/:;
      my @lstat = lstat $file;
      @$Dir[scalar @$Dir] = [ $file,@lstat?{}:{ _ll_ => 'd' },@lstat ];
    }
  }
  ExexNewViewAutocommandPre($dir);
  disp {
    bufname => "/strux/LL",
    time => time,
    dir => $dir,
    sort => 0,
    type => "filelist",
    in_function => \&LL_in_function,
    out_function => \&LL_out_function,
    Array => $Dir,
    item_function => \&stat2hrParsed,
    linenr => 2,
    tabify => 2,
    ft => "LL-default",
  };
  ExexNewViewAutocommandPost($dir);
  $LL::Dirs{"Lst : $dir"} = $disp::H;
  $LL::currentH = $disp::H;
  LLorRedisp('');
  pushDirstack;
  redrawVisitedAndDirstack;
}

sub LL($)
{
  local ($ndir) = @_;
  $ndir =~ s:^~(/|$):$ENV{HOME}/:;
  my $file;
  if (!( -d $ndir)) {
    ($ndir,$file) = $ndir =~ m:(.*/)?(.*):;
    if ($ndir eq "") {
      $ndir = '.';
    }
  }
  if ($ndir eq ".." and $LL::dir =~ m.^([a-zA-Z]:)?/$.) {
    VIM::Msg("Already at rootdir","Error");
  } elsif ($ndir eq "." or chdir $ndir) {
    # the part '$ndir eq "."' is needed for windows. Else .:y: will not work
    #****************************************
    # if :LL is invoked from within a LL-window BufLeave had no chance to set the linenr
    #****************************************
    if ($curbuf->Name() eq '/strux/LL') {
      (my $success, $$disp::H{posInfo}) = VIM::Eval("string(winsaveview())");
    }
    $LL::dir = getcwd;
    if (defined(my $knownH = $LL::Dirs{$LL::dir})) {
      VIM::Msg("Using known view for $LL::dir");
      if ($file ne "") {
        my $knownArray = $$knownH{Array};
        for (my $i=0;$i<@$knownArray;$i=$i+1) {
          if ($$knownArray[$i][0] eq $file) {
            $$knownH{linenr} = $i+2;
            last;
          }
        }
      }
      hdisp $knownH;
    } else {
      $LL::Dir=();
      ExexNewViewAutocommandPre($LL::dir);
      VIM::Msg("New view for $LL::dir");
      $opt_x=1;process $LL::dir;
      Sort $LL::Dir,$LL::sode;                     # sort default
      my $linenr = 2;
      if ($file ne "") {
        for (my $i=0;$i<@$LL::Dir;$i=$i+1) {
          if ($$LL::Dir[$i][0] eq $file) {
            $linenr += $i;
            last;
          }
        }
      }
      disp {
        bufname => "/strux/LL",
        time => time,
        dir => $LL::dir,
        type => "dir",
        in_function => \&LL_in_function,
        out_function => \&LL_out_function,
        Array => $LL::Dir,
        item_function => \&stat2hrParsed,
        linenr => $linenr,
        tabify => 2,
        currentSort => $LL::sode,
        ft => "LL-default",
      };
      ExexNewViewAutocommandPost($LL::dir);
      $LL::Dirs{$LL::dir} = $disp::H;
      if (($LL::sode&0xff) == 20) {
        SortAndRedisp;                             # for sorting along x-info the info was not yet applied when sorting before disp
      }
    }
    $LL::currentH = $disp::H;
    pushDirstack;
    redrawVisitedAndDirstack;
  } else {
    VIM::Msg("cannot enter $ndir","Error");
  }
}

sub tellbranch
{
  local $branch = `git rev-parse --abbrev-ref HEAD 2>/dev/null`;
  if (!($?)) {
    chop $branch;
    return "[$branch]";
  }
}

sub tellsort
{
  my $str;
  my $currentSode = $$disp::H{currentSort};
  my $i = $currentSode &0xff;
  if ($i ==0) { $str ="not sorted " }
  if ($i ==1) { $str ="dev " }
  if ($i ==3) { $str ="ino " }
  if ($i ==4) { $str ="mode " }
  if ($i ==5) { $str ="nlink " }
  if ($i ==6) { $str ="uid " }
  if ($i ==7) { $str ="gid " }
  if ($i ==8) { $str ="rdev " }
  if ($i ==9) { $str ="size " }
  if ($i ==10) { $str ="atime " }
  if ($i ==11) { $str ="mtime " }
  if ($i ==12) { $str ="ctime " }
  if ($i ==13) { $str ="blksize " }
  if ($i ==14) { $str ="blocks " }
  if ($i ==15) { $str ="Name " }
  if ($i ==16) { $str ="Extension " }
  if ($i ==17) { $str ="Length of Basename " }
  if ($i ==18) { $str ="Name (case ignored) " }
  if ($i ==19) { $str ="Name (numerically) " }
  if ($i ==20) { $str ="X-Info " }
  if ($i) {
    $str.=($currentSode&0x100)?"descending":"ascending";
    $str.=",dirs "  .(($currentSode&0x200)?"separated":"not separated");
    $str.=",tagged ".(($currentSode&0x400)?"separated":"not separated");
  }
  if (exists($$disp::H{sort})) {
    $str.=" (fixed)";
  }
  $str;
}

sub LL_in_function
{
  if ($LL::P{$$disp::H{dir}}) {
    ($LL::currentParseString = $LL::P{$$disp::H{dir}}) =~ s/%:/$LL::globalParseString/g;
  } else {
    $LL::currentParseString = $LL::globalParseString;
  }
  $LL::xinDone=0;
  chdir $$disp::H{dir};
  if ($LL::Xf{$$disp::H{dir}}) {
    $LL::currentxPerFileCmd = $LL::Xf{$$disp::H{dir}};
  } else {
    $LL::currentxPerFileCmd = $LL::globalxPerFileCmd;
  }
  if ($LL::Xd{$$disp::H{dir}}) {
    $LL::currentxPerDirCmd  = $LL::Xd{$$disp::H{dir}};
  } else {
    $LL::currentxPerDirCmd  = $LL::globalxPerDirCmd;
  }
  if ($LL::Xin{$$disp::H{dir}}) {
    $LL::currentxIn         = $LL::Xin{$$disp::H{dir}};
  } else {
    $LL::currentxIn         = '';
  }
  if ($LL::Xout{$$disp::H{dir}}) {
    $LL::currentxOut        = $LL::Xout{$$disp::H{dir}};
  } else {
    $LL::currentxOut        = '';
  }
  if ($LL::Xt{$$disp::H{dir}}) {
    $LL::currentxText       = $LL::Xt{$$disp::H{dir}};
  } else {
    $LL::currentxText       = $LL::globalxText;
  }
  if ($$disp::H{showdesc}) {
    $$disp::H{tabify} = 1;                         # also tabalign the header-line (holds the descriptions here)
    $curbuf->Append(0,stat2hrParsed(0,0));
  } else {
    my $line="";                                   # output is constructed here in
    $$disp::H{tabify} = 2;                         # do not tabalign the header-line
    for (my $j=0;$j<length($LL::currentHeader);$j++) {
      my $c=substr $LL::currentHeader,$j,1;
      if ($c eq "%") {
        $c=substr $LL::currentHeader,++$j,1;
        parse: {
          if ($c eq '%') { $line.='%';last parse }
          if ($c eq 'T') { $line.="\t";last parse }
          if ($c eq 'd') { $line.=$$disp::H{dir};last parse }
          if ($c eq 't') { $line.=xpand($$disp::H{time});last parse }
          if ($c eq 'n') { $line.=@{$$disp::H{Array}};last parse }
          if ($c eq 's') { $line.=tellsort;last parse }
          if ($c eq 'g') { $line.=tellbranch;last parse }
          $line.="ERROR";
        } # parse:
      } else {
        $line.="$c";
      }
    }
    $curbuf->Append(0,$line);
  }
}

sub LL_out_function
{
  if ($LL::xinDone and $LL::currentxOut) {
    if (substr($LL::currentxOut,0,2) eq "P ") {
      $d = $$disp::H{dir};
      eval("package XPE;".substr($LL::currentxOut,2));
    } else {
      $ENV{d} = $$disp::H{dir};
      `2>&1 $LL::currentxOut`;
    }
  }
}

sub numerically
{
  my $na;
  my $nb;
  ($na) = @$a[0] =~ /(\d+)/;
  ($nb) = @$b[0] =~ /(\d+)/;
  $na <=> $nb or @$a[0] cmp @$b[0];
}

sub SortAndRedisp
{
  my $thisLine = $$disp::H{linenr};
  if ($LL::SortAndRedispSkip) {
    return;
  }
  my ($nameUnderCursor) = @_;
  my $currentSode;
  if (exists($$disp::H{sort})) {
    $currentSode = $$disp::H{sort};
  } else {
    $currentSode = $LL::sode;
  }
  $$disp::H{currentSort} = $currentSode;
  if (!$nameUnderCursor and ($curwin->Cursor())[0] > 1) {
    $nameUnderCursor = $$disp::A[($curwin->Cursor())[0]-2][0];
  }
  if (($currentSode&0xff) == 20) {
    dodisp $disp::H;                               # for sorting along x-info it must be made sure, that the info is applied
  }
  if ($currentSode) {
    Sort $disp::A,$currentSode;
  }
  my $i;
  for ($i=0;$i<@$disp::A;$i=$i+1) {
    if ($nameUnderCursor eq $$disp::A[$i][0]) {
      $$disp::H{linenr}=$i+2;
      last;
    }
  }
  if ($i >= @$disp::A) {
    $$disp::H{linenr}=$thisLine;
  }
  if ($$disp::H{linenr} >= @$disp::A+2) {
    $$disp::H{linenr}=1;
  }
  (my $success, $$disp::H{posInfo}) = VIM::Eval("string(winsaveview())");
  dodisp $disp::H;
}

sub Sort($$)
{
  local ($A,$i) = @_;
  my $sortdescending = $i&0x100;
  my $seperateDirs   = $i&0x200;
  my $seperateTagged = $i&0x400;
  $i&=0xff;
  if (2<=$i and $i <=14) {
    @$A = sort {           @$a[$i] <=> @$b[$i]           or @$a[0] cmp @$b[0] } @$A;
  }
  if ($i ==15) {
    @$A = sort {            @$a[0] cmp @$b[0]                                 } @$A;
  } elsif ($i ==16) {
    @$A = sort { extension(@$a[0]) cmp extension(@$b[0]) or @$a[0] cmp @$b[0] } @$A;
  } elsif ($i ==17) {
    @$A = sort {     length @$a[0] <=> length @$b[0]     or @$a[0] cmp @$b[0] } @$A;
  } elsif ($i ==18) {
    @$A = sort {         lc @$a[0] cmp lc @$b[0]                              } @$A;
  } elsif ($i ==19) {
    @$A = sort numerically @$A;
  } elsif ($i ==20) {
    @$A = sort {           @$a[15] cmp @$b[15]           or @$a[0] cmp @$b[0] } @$A;
  }
  if ($sortdescending) {
    @$A = reverse @$A;
  }
  if ($seperateDirs) {
    @$A = (grep(isdir(@$_[4]),@$A),grep(!isdir(@$_[4]),@$A));
  }
  if ($seperateTagged) {
    @$A = (grep($$_[1]{x_tagged} eq ">",@$A),grep($$_[1]{x_tagged} ne ">",@$A));
  }
}

sub extension($)
{
  local ($str) = @_;
  $str =~ m(\.([^.]+?)$);
  $1;
}
#****************************************
# NewViewAutocommands
#****************************************
# they are read from $LL::newViewAutocommands (defaults : ~/LL.dirsettings,~/strux/etc/LL.dirsettings) and stored in the internal Data Structure @LL::AC
# @LL::AC looks basically like this
#   [ dir-pattern1 , { P => parsestring , Xf => 'xstring for files', Xd => 'xstring for directories' } ],
#   [ dir-pattern2 , { P => parsestring                } ],
# So if ~/strux/etc/LL.dirsettings looks like this
#   ^/proc$
#     P	%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/%TI'm in /proc
#   /tmp
#     P	%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/%TI'm in /tmp
#     Xf	file
#     Xt	magic	can contain tabs
#     Xd
# then @LL::AC will look like this
#   @LL::AC = [
#           [
#             '^/proc$',
#             {
#               'P' => '%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/%TI\'m in /proc'
#             }
#           ],
#           [
#             '/tmp',
#             {
#               'Xf' => 'file',
#               'Xd' => '',
#               'Xt' => 'magic	can contain tabs'
#               'P' => '%t%f %!%T%l%T%U%T%G%T%m%T%s%T%/%TI\'m in /tmp'
#             }
#           ]
#         ];
#****************************************

sub RereadNewViewAutocommands($)
{
  local ($initial) = @_;
  @LL::AC = ();
  for $f (split(/,/,$LL::newViewAutocommands)) {
    $f =~ s:^~/:$ENV{HOME}/:;
    if ($initial and ! -e $f) {
      next;
    }
    local *AC_stream;
    if (!(open(AC_stream,$f))) {
      VIM::Msg("cannot read file $f");
      next;
    }
    while (<AC_stream>) {
      chomp;
      if (/^\s*#/ or !$_) {
        next;
      }
      if (!(/^\s/)) {
        #****************************************
        # we have a dirname-pattern here
        #****************************************
        push @LL::AC,[ $_ , {} ];
      } else {
        #****************************************
        # we have an action for pattern for previous dirname
        #****************************************
        my ($name,$val) = /\s+(.*?)\t+(.*)/;
        $LL::AC[-1][1]{ $name }  = $val;
      }
    }
    if (!($initial)) {
      VIM::Msg("$f reread succcessfully");
    }
    close AC_stream;
  }
}

sub ClearNewViewAutocommands($)
{
  local ($mode) = @_;
  undef($LL::P{$$disp::H{dir}});
  undef($LL::Xf{$$disp::H{dir}});
  undef($LL::Xd{$$disp::H{dir}});
  undef($LL::Xt{$$disp::H{dir}});
  undef($LL::Xin{$$disp::H{dir}});
  undef($LL::Xout{$$disp::H{dir}});
  undef($LL::currentParseString);
  undef($LL::currentPerFileCmd);
  undef($LL::currentPerDirCmd);
  undef($LL::currentIn);
  undef($LL::currentOut);
  undef($LL::currentText);
  undef($$disp::H{NewViewPattern});
  if ($mode =~ /verbose/) {
    RefreshView(0) ;                               # Update the current view (keep deleted)
    VIM::Msg("Autocommands cleared for dir $$disp::H{dir}");
  }
}

sub ExexNewViewAutocommandPre
{
  local ($dir,$pattern) = @_;
  if (!($pattern)) {
    $pattern = $dir;
  }
  for (my $i=0;$i<@LL::AC;$i=$i+1) {
    if ($pattern =~ /$LL::AC[$i][0]/) {
      while (my ($key,$val) = each %{$LL::AC[$i][1]}) {
        if ($key eq 'P') {
          if (!(defined($LL::P{$dir}))) {
            $LL::P{$dir}=$val;
          }
        } elsif ($key eq 'Xf') {
          if (!(defined($LL::Xf{$dir}))) {
            $LL::Xf{$dir}=$val;
          }
        } elsif ($key eq 'Xd') {
          if (!(defined($LL::Xd{$dir}))) {
            $LL::Xd{$dir}=$val;
          }
        } elsif ($key eq 'Xt') {
          if (!(defined($LL::Xt{$dir}))) {
            $LL::Xt{$dir}=$val;
          }
        } elsif ($key eq 'Xi') {
          $LL::Xin{$dir} =$val;
        } elsif ($key eq 'Xo') {
          $LL::Xout{$dir}=$val;
        }
      }
      return;
    }
  }
}

sub ExexNewViewAutocommandPost
{
  local ($dir,$pattern) = @_;
  if (!($pattern)) {
    $pattern = $dir;
  }
  VIM::DoCommand("setl ft=$$disp::H{ft}");
  for (my $i=0;$i<@LL::AC;$i=$i+1) {
    if ($pattern =~ /$LL::AC[$i][0]/) {
      #****************************************
      # NewViewPattern
      #****************************************
      # is not really needed. it is just set so that it can be examined with showTechInfo
      # it must be set here in ExexNewViewAutocommandPost since in ExexNewViewAutocommandPre $disp::H still points to the 'parent'
      #****************************************
      $$disp::H{NewViewPattern} = $LL::AC[$i][0];
      while (my ($key,$val) = each %{$LL::AC[$i][1]}) {
        if ($key eq 'V') {
          VIM::DoCommand($val);
        } elsif ($key eq 'S') {
          my $sode=$LL::sode;
          $LL::SortAndRedispSkip=1;
          VIM::DoCommand("normal ${val}Sf");
          $LL::SortAndRedispSkip=0;
          $LL::sode=$sode;
          SortAndRedisp();
        }
      }
      last;
    }
  }
  (my $success, my $val) = VIM::Eval("&ft");
  $$disp::H{ft}=$val;
}

sub hdisp($)
{
  local ($tH) = @_;
  disp $tH;
  if (!$$disp::H{sort} and $$disp::H{currentSort} != $LL::sode) {
    SortAndRedisp;
  }
  VIM::DoCommand("setl ft=$$disp::H{ft}");
}
### 
#  cmdarg
#    is appended to cmd if cmd does not contain a $
#    is supposed to be something like "$F"

sub WriteTmpScript($$$$)
{
  local ($cmd,$filename,$cmdarg,$mode) = @_;
  my ($f,$p,$F,$r,$e);
  $cmd =~ s/^\s*//;                                # remove leading spaces
  if (!($cmd =~ /\$/)) {
    $cmd.=$cmdarg;
  }
  $f = getFullname4shell($$LL::currentH{dir},$filename);
  ($p = $f) =~ s:/[^/]*$::;
  ($F = $f) =~ s:.*/::;
  ($r = $F) =~ s/\.[^.]*$//;
  if ($f =~ /\./) {
    ($e=$f) =~ s/.*\.//;
  } else {
    $e = "";
  }
  if (!($LL::tmpScriptIsOpen)) {
    VIM::DoCommand('let g:strux_LL_scriptname=tempname()');
    $$LL::tmpname = VIM::Eval('g:strux_LL_scriptname');
    if (!(open(FPC,">$$LL::tmpname"))) {
      VIM::Msg("opening tempfile $$LL::tmpname for writing failed : $!","Error");
      return;
    }
    $LL::tmpScriptIsOpen = 1;
    $LL::lastCmd = $cmd;
    print FPC "# for the sake of 'binary' data in filenames. (to avoid 'cannot execute binary file')"."\n" ; #
    if ($mode eq 't') {
      #	clear the tmp-script invocation
        print FPC qq[tput -S <<!\n] ; #
        print FPC qq[\tcuu1\n] ; #Cursor up
        print FPC qq[\tel\n] ; #clear to end of line
        print FPC qq[!\n] ; #
      #	handle cwd mismatch
        local $shellpid=vimvar('g:strux_shellpid');
        if ($shellpid and readlink("/proc/$shellpid/cwd") ne getcwd()) {
          #****************************************
          # if $shellpid is not set, then the LLShell is not yet open
          #****************************************
          # it will be opened automatically in the cwd
          #****************************************
          print FPC qq[cd '$p' >/dev/null\n] ; #
          print FPC qq[tput rev;echo -n "changed cd to : " ; pwd ;tput rmso\n] ; #
        }
    }
  }
  print FPC qq[f='$f'\n] ; #$f : /dir/name.ext
  print FPC qq[p='$p'\n] ; #$p : /dir
  print FPC qq[F='$F'\n] ; #$F : name.ext
  print FPC qq[r='$r'\n] ; #$r : name
  print FPC qq[e='$e'\n] ; #$e : ext
  if ($mode eq 't') {
    #	echo the command
      print FPC qq[cat <<-END\n] ; #
      print FPC qq[\t$cmd\n] ; #
      print FPC qq[END\n] ; #
  }
  #	invoke the command
    print FPC qq[(\n] ; #
    print FPC qq[$cmd\n] ; #the command
    print FPC qq[)\n] ; #
}

sub CloseTmpScript
{
  print FPC qq[rm -f $$LL::tmpname\n] ; #removing the just executed script, doesn't semm to disturb bash
  close FPC;
  $LL::tmpScriptIsOpen = 0;
  # I cannot delete the tmp-file here since an background xterm might still need it.
}

sub openPty
{
  local $shellpid=vimvar('g:strux_shellpid');
  if (!(open(PTY,">>/proc/$shellpid/fd/1"))) {
    VIM::Msg("cannot open PTY");
  }
  autoflush PTY 1;
}

sub echoLastCmd
{
  print PTY "\e[7m$LL::lastCmd\e[27m\n";
}

sub showTechInfo
{
  my @A;
  push @A,"Tech Info";
  use Data::Dumper;
  push @A,split(/\n/,Data::Dumper->Dump([\$disp::H],["*disp::H"]));
  push @A,split(/\n/,Data::Dumper->Dump([\%LL::Dirs],["*LL::Dirs"]));
  push @A,split(/\n/,Data::Dumper->Dump([\%XPE::],["*XPE"]));
  push @A,split(/\n/,Data::Dumper->Dump([\@LL::AC],["*LL::AC"]));
  push @A,split(/\n/,Data::Dumper->Dump([\%LL::P],["*LL::P"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentParseString],["*LL::currentParseString"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentHeader],["*LL::currentHeader"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentxIn],["*LL::currentxIn"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentxOut],["*LL::currentxOut"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentxPerDirCmd],["*LL::currentxPerDirCmd"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentxPerFileCmd],["*LL::currentxPerFileCmd"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::currentxText],["*LL::currentxText"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::globalParseString],["*LL::globalParseString"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::globalxPerDirCmd],["*LL::globalxPerDirCmd"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::globalxPerFileCmd],["*LL::globalxPerFileCmd"]));
  push @A,split(/\n/,Data::Dumper->Dump([\$LL::globalxText],["*LL::globalxText"]));
  disp {
    bufname => "/strux/techinfo",
    Array => \@A,
  };
}
main();
EOT
"****************************************
" additional notes
"****************************************
" g:strux_shellpida and g:strux_LL_scriptname cannot be made script-local (s:) since acmd needs them too
"****************************************
