"
" Autogenerated from vim_tru using pstree.vimTR
" do not edit this file, look for pstree.vimTR and change this
" or you may loose all your changes and probably choose the wrong method.
" goto http://www.strux.net to find more information.
"
" based on pstree.vimTR , version : 4.0
"usage for pstree.vim
"	investigate the pstree.
"	some of the commands only work on debian-based systems.
"
"	start it by editing /strux/pstree
"
"	Note that this file (/strux/pstree) is not supposed to really exist.
"
"	You can also (in your shell) try
"	  pst
"	or
"	  pst vim
"
"	to install this plugin put this file into ~/.vim/plugin/
"	n-mappings for buffer /strux/pstree
"	r	Refresh view
"	  refreshes the view reflecting the changes in the pstree
"	P	Goto next pid
"	  move cursor to the next Pid
"	p	Search next Pid and show info
"	  move cursor to the next Pid and show info for this pid
"	K	Kill this process
"	  prompts for a kill-command,
"	  the PID under or right of the cursor is inserted.
"	  the cursor is right of the signal
"	  You may wish to adjust the signal before pressing <ENTER>
"	i	Info about this pid
"	  shows info for the pid under the cursor.
"	  If there is no pid under the cursor, the next pid in this line right of the cursor is tryed
"	  If there is no pid right of the cursor, the pid left of the cursor is used
"	a	LL of /proc/<pid>
"	  for the pid under the cursor start LL in /proc/<pid>
"
"---------------------------------------------
function <sid>Help_n2f73747275782f707374726565_1()
  echohl WarningMsg
  echo 'Refresh view (bound to r)'
  echohl None
  echo ''
  echo 'refreshes the view reflecting the changes in the pstree'
endfunction
function <sid>Help_n2f73747275782f707374726565_2()
  echohl WarningMsg
  echo 'Goto next pid (bound to P)'
  echohl None
  echo ''
  echo 'move cursor to the next Pid'
endfunction
function <sid>Help_n2f73747275782f707374726565_3()
  echohl WarningMsg
  echo 'Search next Pid and show info (bound to p)'
  echohl None
  echo ''
  echo 'move cursor to the next Pid and show info for this pid'
endfunction
function <sid>Help_n2f73747275782f707374726565_4()
  echohl WarningMsg
  echo 'Kill this process (bound to K)'
  echohl None
  echo ''
  echo 'prompts for a kill-command,'
  echo 'the PID under or right of the cursor is inserted.'
  echo 'the cursor is right of the signal'
  echo 'You may wish to adjust the signal before pressing <ENTER>'
endfunction
function <sid>Help_n2f73747275782f707374726565_5()
  echohl WarningMsg
  echo 'Info about this pid (bound to i)'
  echohl None
  echo ''
  echo 'shows info for the pid under the cursor.'
  echo 'If there is no pid under the cursor, the next pid in this line right of the cursor is tryed'
  echo 'If there is no pid right of the cursor, the pid left of the cursor is used'
endfunction
function <sid>Help_n2f73747275782f707374726565_6()
  echohl WarningMsg
  echo 'LL of /proc/<pid> (bound to a)'
  echohl None
  echo ''
  echo 'for the pid under the cursor start LL in /proc/<pid>'
endfunction
" the interface
" InterfaceOFF for /strux/pstree
function!InterfaceOFF_2f73747275782f707374726565()
  if exists("b:Interface_2f73747275782f707374726565_MapsDone")
    nunmenu &Strux.&pstree.&refresh<tab>r
    nunmenu &Strux.&pstree.&next<tab>P
    nunmenu &Strux.&pstree.next\ &and\ info<tab>p
    nunmenu &Strux.&pstree.&kill<tab>K
    nunmenu &Strux.&pstree.&info<tab>i
    nunmenu &Strux.&pstree.&LL<tab>a
    unlet b:Interface_2f73747275782f707374726565_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f707374726565()
  echo '1	r	Refresh view'
  echo '2	P	Goto next pid'
  echo '3	p	Search next Pid and show info'
  echo '4	K	Kill this process'
  echo '5	i	Info about this pid'
  echo '6	a	LL of /proc/<pid>'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f707374726565_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/pstree
function!InterfaceON_2f73747275782f707374726565()
  if !exists("b:Interface_2f73747275782f707374726565_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f707374726565()<CR>
    nnoremenu &Strux.&pstree.&refresh<tab>r :call Pstree()<CR>
    nnoremenu &Strux.&pstree.&next<tab>P :call NextPid()<CR>
    nnoremenu &Strux.&pstree.next\ &and\ info<tab>p :call NextPid()<CR>:call PsInfo()<CR>
    nnoremenu &Strux.&pstree.&kill<tab>K f)%l:!kill -9 <C-R><C-W><Home><Right><Right><Right><Right><Right><Right><Right><Right>
    nnoremenu &Strux.&pstree.&info<tab>i :call PsInfo()<CR>
    nnoremenu &Strux.&pstree.&LL<tab>a :call PsLL()<CR>
    nnoremap <buffer> <silent> r :call Pstree()<CR>
    nnoremap <buffer> <silent> P :call NextPid()<CR>
    nnoremap <buffer> <silent> p :call NextPid()<CR>:call PsInfo()<CR>
    nnoremap <buffer> K :call <sid>Help_n2f73747275782f707374726565_4()<cr>f)%l:!kill -9 <C-R><C-W><Home><Right><Right><Right><Right><Right><Right><Right><Right>
    nnoremap <buffer> <silent> i :call PsInfo()<CR>
    nnoremap <buffer> <silent> a :call PsLL()<CR>
    augroup g2f73747275782f707374726565
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f707374726565()
    augroup END
    let b:Interface_2f73747275782f707374726565_MapsDone=1
    if !exists("b:_2f73747275782f707374726565_HintGiven")
      unsilent echo 'special mappings from pstree.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f707374726565_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/pstree
au BufEnter /strux/pstree call InterfaceON_2f73747275782f707374726565()
au BufEnter /strux/pstree call PsInit()
function!PsInfo_pid() 
  :put =s:currpid
  silent 1d
endfunc
function!PsInfo_exe() 
  silent exe "r!ls -l /proc/".s:currpid."/exe 2>/dev/null"
  :-
  :j
  s/ /\t/
endfunc
function!PsInfo_environ() 
  $
  mark a
  let l:lnr=line(".")
  silent! exe "r /proc/".s:currpid."/environ"
  if l:lnr != line("$")
    s/.$//
    s/\%x00/\t/g
    s/^/environ\t/
    silent 'a+1,$>
  else
    d
  endif
endfunc
function!PsInfo_cmdline() 
  $
  exe "r /proc/".s:currpid."/cmdline"
  s/.$//
  s/\%x00/\t/g
  s/^/cmdline\t/
endfunc
function!PsInfo_cwd() 
  silent exe "r!ls -l /proc/".s:currpid."/cwd 2>/dev/null"
  if stridx(getline("."),">") != -1
    exe "normal df>xI  cwd\t\t\<ESC>"
  else
    silent d
  endif
endfunc
function!PsInfo_root() 
  silent exe "r!ls -l /proc/".s:currpid."/root 2>/dev/null"
  if stridx(getline("."),">") != -1
    exe "normal! df>xI  root\t\t\<ESC>"
  else
    silent d
  endif
endfunc
function!PsInfo_statm() 
  $
  silent exe "r /proc/".s:currpid."/statm"
  exe "normal! I  statm\t\t\<ESC>"
endfunc
function!PsInfo_stat() 
  $
  silent exe "r /proc/".s:currpid."/stat"
  exe "normal! I  stat\t\t\<ESC>"
endfunc
function!PsInfo_fd() 
  $
  mark a
  let l:lnr=line(".")
  silent exe "r!ls -l /proc/".s:currpid."/fd 2>/dev/null"
  if l:lnr != line("$")
    :'a+1 d
    silent 'a+1,$>
    silent 'a+1,$>
    :'a put ='  fd'
  endif
endfunc
function!PsInfo_status() 
  $
  mark a
  let l:lnr=line(".")
  silent exe "r /proc/".s:currpid."/status"
  if l:lnr != line("$")
    silent 'a+1,$>
    silent 'a+1,$>
    :'a put ='  status'
  endif
endfunc
function!PsInfo_maps() 
  $
  mark a
  let l:lnr=line(".")
  silent exe "r /proc/".s:currpid."/maps"
  if l:lnr != line("$")
    silent 'a+1,$>
    silent 'a+1,$>
    :'a put ='  maps'
  endif
endfunc
function!PsInfo_lsof() 
  $
  mark a
  let l:lnr=line(".")
  silent exe "r !lsof -p ".s:currpid
  if l:lnr != line("$")
    silent 'a+1,$>
    silent 'a+1,$>
    :'a put ='  lsof'
  endif
endfunc
function!Pstree() 
  setlocal modifiable
  let currline = line(".")
  silent %d
  " TERM= to force Ascii-output (independent of version of pstree)
  silent r!TERM= pstree -upl
  silent 1d
  se nomodified
  exe "normal!".currline."G"
  setlocal nomodifiable
  " to get rid of the : "/strux/pstree" [New File]
  redraw
endfunc
function!NextPid() 
  exe "normal! /\\<\\d\\+/\<cr>"
endfunc
function!PsLL() 
  normal! f)%l
  if match(expand("<cword>"),"[^0-9]") != -1
    echo 'Not a valid pid '.expand("<cword>")
    return
  endif
  let s:currpid=expand("<cword>")
  exe "LL /proc/".s:currpid
endfunc
function!PsInfo() 
  let switchbuf=&switchbuf
  set switchbuf=useopen
  if b:hfname == ''
    let b:hfname=tempname()
    exe "sp ".b:hfname
    exe "resize ". g:strux_pstree_InitialInfoWinHeight
    wincmd p
  endif
  normal! f)%l
  if match(expand("<cword>"),"[^0-9]") != -1
    normal! F(l
    if match(expand("<cword>"),"[^0-9]") != -1
      echo 'Not a valid pid '.expand("<cword>")
      return
    endif
  endif
  let s:currpid=expand("<cword>")
  exe "sb ".b:hfname
  let currline = line(".")
  %d
  silent! call PsInfo_pid()
  silent! call PsInfo_exe()
  silent! call PsInfo_cmdline()
  silent! call PsInfo_environ()
  silent! call PsInfo_cwd()
  silent! call PsInfo_root()
  silent! call PsInfo_statm()
  silent! call PsInfo_stat()
  silent! call PsInfo_fd()
  silent! call PsInfo_status()
  silent! call PsInfo_maps()
  silent! call PsInfo_lsof()
  se nomodified
  exe "normal!".currline."G"
  wincmd p
  let &switchbuf=switchbuf
endfunc
function!PsInit() 
  if exists("b:Inited")
    return
  else
    let b:Inited=1
  endif
  set ft=pstree
  let b:hfname=''
  if !(exists("g:strux_pstree_InitialInfoWinHeight"))
    let g:strux_pstree_InitialInfoWinHeight=10
  endif
  call Pstree()
endfunc
