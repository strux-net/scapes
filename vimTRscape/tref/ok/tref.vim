"
" Autogenerated from vim_tru using tref.vimTR
" do not edit this file, look for tref.vimTR and change this
" or you may loose all your changes and probably choose the wrong method.
" goto http://www.strux.net to find more information.
"
" based on tref.vimTR , version : 4.0
"usage for tref
"	this plugin provides the mapping \tr for opening a context-view for the current line.
"
"	It requires vim with +perl.
"
"	a new window is opened which contains only the parent (wrt. to indent) lines of the current line.
"
"	the \ below indicates the leader, you can redefine it (:help leader)
"	To choose a completely different mapping, put the following into your ~/.vimrc
"	    map whatever :perl loc<CR>:exe "resize ". line("$")<CR>mxgg'x<C-W>p:<BS>
"	  in this case \tr remains untouched, it is not mapped here again.
"
"	to install this plugin put this file into ~/.vim/plugin/
"	you also need to have LL installed, since this provides disp.vim, which is also required here.
"	n-mappings for buffer /strux/Context
"	<CR>	go to the line
"	  go to this line
"	\tr	open context for the current line
"
"---------------------------------------------
function <sid>Help_n2f73747275782f436f6e74657874_1()
  echohl WarningMsg
  echo 'go to the line (bound to <CR>)'
  echohl None
  echo ''
  echo 'go to this line'
endfunction
if !(has("perl"))
  finish
endif
runtime disp.vim
" the interface
" InterfaceOFF for /strux/Context
function!InterfaceOFF_2f73747275782f436f6e74657874()
  if exists("b:Interface_2f73747275782f436f6e74657874_MapsDone")
    nunmenu &Strux.&Context.&go\ to\ line<tab>\<CR>
    unlet b:Interface_2f73747275782f436f6e74657874_MapsDone
  endif
endf
function!<sid>Help_n2f73747275782f436f6e74657874()
  echo '1	<CR>	go to the line'
  if exists('<SID>Help()')
    call <SID>Help()
  endif
  while 1 == 1
    echo '' | " due to a bug in vim. Else the prompt will get partly overwritten
    call inputsave()
    let ans=input("Type Nr of Item for more help on this item, or just press ENTER : ")
    call inputrestore()
    let ans='<sid>Help_n2f73747275782f436f6e74657874_'.ans
    if exists('*'.ans)
      echo "\r"
      exe 'call '.ans.'()'
    else
      break
    endif
  endwhile
endf
" InterfaceON for /strux/Context
function!InterfaceON_2f73747275782f436f6e74657874()
  if !exists("b:Interface_2f73747275782f436f6e74657874_MapsDone")
    nnoremap <buffer> <F1> :<C-U>call <sid>Help_n2f73747275782f436f6e74657874()<CR>
    nnoremenu &Strux.&Context.&go\ to\ line<tab>\<CR> :perl gotoTheLine()<CR>
    nnoremap <buffer> <silent> <CR> :perl gotoTheLine()<CR>
    augroup g2f73747275782f436f6e74657874
      au! BufLeave <buffer>
      au BufLeave <buffer> call InterfaceOFF_2f73747275782f436f6e74657874()
    augroup END
    let b:Interface_2f73747275782f436f6e74657874_MapsDone=1
    if !exists("b:_2f73747275782f436f6e74657874_HintGiven")
      unsilent echo 'special mappings from tref.vimTR available. Press <F1> for a list'
    endif
    let b:_2f73747275782f436f6e74657874_HintGiven=1
  endif
endf
" Hooking the Interfaces for /strux/Context
au BufEnter /strux/Context call InterfaceON_2f73747275782f436f6e74657874()
if !hasmapto(":perl loc<CR>:exe \"resize \". line(\"$\")<CR>mxgg'x<C-W>p:<BS>")
  " \tr       -> open context for the current line
  map \tr :perl loc<CR>:exe "resize ". line("$")<CR>mxgg'x<C-W>p:<BS>
endif
perl <<EOT
#  protos
sub loc;
sub indent($);
sub showline($$);
sub gotoTheLine;

sub loc
{
  my $ln=($curwin->Cursor())[0];
  my $l=$curbuf->Get($ln);
  (my $success, local $ts) = VIM::Eval("&ts");
  my $indent=indent($l);
  (my $success, my $foldignore) = VIM::Eval("&foldignore");
  if ($foldignore) {
    $foldignore_regexp = '\s*\\'.$foldignore;
  } else {
    $foldignore_regexp='';
  }
  my @A=();
  while (--$ln>-1) {
    if ((my $ni=indent(my $nl=$curbuf->Get($ln))) < $indent) {
      unshift @A,[$ln,$nl];
      if (!($nl =~ /\s*-$/)) {
        $indent=$ni;
      }
    }
  }
  disp {
    bufname => "/strux/Context",
    Array => \@A,
    item_function => \&showline,
    bufferNr => $curbuf->Number(),
    in_function => sub { VIM::DoCommand("setlocal ts=$ts") },
  };
}

sub indent($)
{
  local ($l) = @_;
  if ($l eq "") {
    return 99999999;
  }
  if ($foldignore_regexp and $l =~ /$foldignore_regexp/) {
    return 99999999;
  }
  (my $tabs,my $spaces) = $l =~ /^(\t*)( *)/;
  length($tabs)*$ts+length($spaces);
}

sub showline($$)
{
  local ($D,$i) = @_;
  @{@$D[$i]}[1];
}

sub gotoTheLine
{
  VIM::DoCommand("sb $$disp::H{bufferNr}|@{@$disp::A[($curwin->Cursor())[0]-1]}[0]");
}
EOT
